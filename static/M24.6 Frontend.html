<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>E8 Mind-Crystal (Live HUD) — M30 Frontend</title>
    <style>
        :root {
            --bg: #0b0f17;
            --fg: #d9e1ff;
            --muted: #a7b0d6;
            --glow: #7aa2ff;
            --glass: rgba(16, 22, 33, 0.65);
            --glass-2: rgba(16, 22, 33, 0.35);
            --accent: #8ef1ff;
            --accent-2: #c792ea;
            --ok: #6ee7b7;
            --warn: #fde047;
            --bad: #fb7185;
            --border-color: rgba(255, 255, 255, 0.06);
            --rotor-label-bg: rgba(16, 22, 33, 0.8);
            --gold: #FFD700;
            --white-glow: #FFFFFF;
        }

        html[data-theme="light"] {
            --bg: #f0f2f7;
            --fg: #1c1e26;
            --muted: #5a647e;
            --glow: #0052d6;
            --glass: rgba(255, 255, 255, 0.6);
            --glass-2: rgba(255, 255, 255, 0.3);
            --accent: #0097b3;
            --accent-2: #9e28d4;
            --ok: #069668;
            --warn: #d97706;
            --bad: #e11d48;
            --border-color: rgba(0, 0, 0, 0.1);
            --rotor-label-bg: rgba(240, 242, 247, 0.8);
            --gold: #d97706;
            --white-glow: #333333;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .main-view {
            position: fixed;
            inset: 0;
        }

        .webgl {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            display: grid;
            grid-template-columns: 380px 1fr 400px;
            grid-template-rows: 60px 1fr 40px;
            grid-template-areas: "header header header" "left main right" "footer footer footer";
            gap: 16px;
            padding: 16px;
        }

        .panel {
            backdrop-filter: blur(12px);
            background: var(--glass);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .left-panel {
            grid-area: left;
        }

        .right-panel {
            grid-area: right;
        }

        /* New Floating Panel for Memory Etching */
        #floatingEtchingPanel {
            position: fixed;
            bottom: 56px;
            /* Above the footer */
            left: 16px;
            width: 400px;
            height: 320px;
            z-index: 10;
            pointer-events: auto;
        }

        @media (max-width: 1300px) {
            .ui-overlay {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
                grid-template-areas: "header" "main" "right" "left" "footer";
                gap: 12px;
                padding: 12px;
            }

            .right-panel,
            .left-panel {
                width: 100%;
                min-height: 400px;
            }

            #floatingEtchingPanel {
                display: none;
            }

            /* Hide on smaller screens to avoid clutter */
        }

        header {
            grid-area: header;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            pointer-events: auto;
            background: linear-gradient(to right, rgba(20, 26, 40, 0.7), rgba(20, 26, 40, 0.3));
            border-bottom: 1px solid var(--border-color);
            border-radius: 12px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .brand {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: .5px;
            color: var(--accent);
        }

        .brand span {
            opacity: .7;
            font-weight: 400;
            font-size: 14px;
        }

        .status-tag {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(125, 145, 255, 0.15);
            color: #9ab0ff;
            border: 1px solid rgba(125, 145, 255, 0.25);
        }

        .footer {
            grid-area: footer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            color: var(--muted);
            font-size: 12px;
        }

        .hint {
            opacity: .7;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            cursor: grab;
            user-select: none;
        }

        .panel-header.dragging {
            cursor: grabbing;
        }

        .panel-title {
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: .5px;
            opacity: .8;
        }

        .panel-content {
            padding: 16px;
            overflow: auto;
            flex-grow: 1;
        }

        .panel-content.no-padding {
            padding: 0;
            position: relative;
        }

        .weather-box {
            margin-top: 12px;
            padding: 8px 12px;
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 12px;
        }

        .weather-box .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .weather-box .label {
            color: var(--muted);
        }

        .weather-box .value {
            color: var(--fg);
            font-weight: 600;
            text-align: right;
        }

        .ring {
            position: relative;
            width: 92px;
            height: 92px;
        }

        .ring canvas {
            position: absolute;
            inset: 0;
        }

        .ring .ring-label {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--muted);
        }

        .ticker {
            position: absolute;
            left: 16px;
            right: 16px;
            bottom: 64px;
            pointer-events: none;
        }

        .ticker .tape {
            white-space: nowrap;
            overflow: hidden;
            border: 1px solid var(--border-color);
            background: var(--glass);
            border-radius: 12px;
            padding: 10px 14px;
        }

        .ticker .scroll {
            display: inline-block;
            animation: scroll 30s linear infinite;
        }

        @keyframes scroll {
            from {
                transform: translateX(0);
            }

            to {
                transform: translateX(-50%);
            }
        }

        .goals-overlay {
            pointer-events: none;
            position: absolute;
            top: 80px;
            left: 0;
            right: 0;
            height: 220px;
        }

        .goals-overlay canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #flash-overlay {
            position: fixed;
            inset: 0;
            background: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity .5s ease-out;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
            opacity: 0;
            z-index: 1000;
            transform: translate(-50%, -110%);
            font-size: 12px;
            text-align: left;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .theme-toggle-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--fg);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .theme-toggle-btn:hover {
            background-color: var(--glass-2);
        }
    </style>

    <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
    <script>
        // Theme initialization script
        (function () {
            const storedTheme = localStorage.getItem('theme');
            const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
            if (storedTheme) {
                document.documentElement.setAttribute('data-theme', storedTheme);
            } else if (prefersLight) {
                document.documentElement.setAttribute('data-theme', 'light');
            }
        })();
    </script>
</head>

<body>
    <div id="flash-overlay"></div>
    <div id="tooltip" class="tooltip"></div>

    <div class="main-view">
        <canvas class="webgl" id="scene"></canvas>
        <div class="goals-overlay"><canvas id="goalsCanvas"></canvas></div>
        <div class="ticker">
            <div class="tape"><span class="scroll" id="tickerText"></span></div>
        </div>
    </div>

    <div class="ui-overlay">
        <header>
            <div class="brand">E8 Mind-Crystal <span>// M30 Live HUD</span></div>
            <div style="display:flex; align-items:center; gap:16px;">
                <div class="status-tag" id="runTag" title="Data link status">OFFLINE</div>
                <button id="themeToggle" class="theme-toggle-btn" title="Toggle Theme">☀️</button>
            </div>
        </header>

        <aside class="left-panel panel">
            <div class="panel-header">
                <div class="panel-title">System Vitals</div>
            </div>
            <div class="panel-content">
                <div class="weather-box">
                    <div class="row"><span class="label">Weather</span><span class="value" id="wx-mood">—</span></div>
                    <div class="row"><span class="label">Region</span><span class="value" id="wx-region">—</span></div>
                    <div class="row"><span class="label">BH Pressure</span><span class="value"
                            id="wx-pressure">0.00</span></div>
                </div>

                <div style="margin-top: 16px; display:flex; gap:14px; flex-wrap:wrap;">
                    <div class="ring"><canvas width="92" height="92" id="ringPressure"></canvas>
                        <div class="ring-label">Collapse</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringTeacher"></canvas>
                        <div class="ring-label">Teacher</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringExplorer"></canvas>
                        <div class="ring-label">Explorer</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringReward"></canvas>
                        <div class="ring-label">Reward</div>
                    </div>
                </div>

                <div style="margin-top: 16px">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Mood Vectors</div>
                    <div class="weather-box">
                        <div class="row"><span class="label">Intensity</span><progress id="mood-intensity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Entropy</span><progress id="mood-entropy" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Coherence</span><progress id="mood-coherence" max="1"
                                value="0.5" style="width:160px"></progress></div>
                    </div>
                </div>

                <div style="margin-top: 16px;">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Dialogue</div>
                    <div class="weather-box">
                        <div class="row" style="align-items: flex-start;">
                            <span class="label" style="padding-top:2px; flex-shrink: 0;">Teacher</span>
                            <span class="value" id="teacher-question"
                                style="white-space: normal; text-align: right;">—</span>
                        </div>
                        <div class="row" style="align-items: flex-start; margin-top: 8px;">
                            <span class="label" style="padding-top:2px; flex-shrink: 0;">Explorer</span>
                            <span class="value" id="explorer-answer"
                                style="white-space: normal; text-align: right;">—</span>
                        </div>
                    </div>
                </div>

                <div id="vitals" style="margin-top: 16px"></div>
            </div>

            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Goals Field</div>
            </div>
            <div class="panel-content">
                <div id="goalsList"></div>
            </div>

            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Selection Wavefunction</div>
            </div>
            <div class="panel-content no-padding">
                <canvas id="wavefunctionCanvas" style="width:100%; height:120px;"></canvas>
            </div>
        </aside>

        <aside class="right-panel panel">
            <div class="panel-header">
                <div class="panel-title">Dimensional Rotors</div>
            </div>
            <div class="panel-content no-padding" style="flex-grow: 1; display: flex;">
                <canvas id="rotorCanvas" style="width:100%; height:100%;"></canvas>
            </div>

            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Shell Tensions</div>
            </div>
            <div class="panel-content">
                <div id="shellTensionSparklines" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;"></div>
            </div>

            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Encoder</div>
            </div>
            <div class="panel-content" style="font-size:12px; flex-grow: 0; flex-shrink: 0;">
                <div class="weather-box">
                    <div class="row"><span class="label">Autoencoder</span><span class="value"
                            id="encoder-status">Untrained</span></div>
                    <div class="row"><span class="label">Global Tension</span><span class="value"
                            id="global-tension">0.000</span></div>
                </div>
                <div style="margin-top:12px"> <small style="opacity:0.7">Geometric tension between shells. High tension
                        can trigger dreams or insights.</small> </div>
            </div>
        </aside>

        <footer class="footer">
            <div class="hint"></div>
            <div id="status">Initializing...</div>
        </footer>
    </div>

    <div id="floatingEtchingPanel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Memory Etching</div>
        </div>
        <div class="panel-content no-padding" id="etchingContainer">
            <canvas id="etchingCanvas"></canvas>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        /* ---------- Config & API ---------- */
        const API_BASE_URL = new URLSearchParams(location.search).get('api') || (location.origin.startsWith('http') ? location.origin : 'http://localhost:7870');
        const API = {
            telemetryStream: `${API_BASE_URL}/api/telemetry/stream`,
            telemetryLatest: `${API_BASE_URL}/api/telemetry/latest`,
        };

        /* ---------- State & Parameters ---------- */
        const state = {
            running: false,
            rotors: {},
            etchings: [],
            lastMemoryCount: 0,
            currentTelemetry: {},
            shellSparklines: new Map(),
            smooth: {
                // MODIFICATION: Removed 'dream' and added 'pressure'
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                wxPressure: 0,
                globalTension: 0,
            },
            targets: {
                // MODIFICATION: Removed 'dream' and added 'pressure'
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                wxPressure: 0,
                globalTension: 0,
            },
        };
        let clock = new THREE.Clock();
        let blackHole;
        const cameraRig = {
            targetRadius: 15,
            currentRadius: 15,
        };
        const scratch = {
            targetVec: new THREE.Vector3(),
            dirVec: new THREE.Vector3(),
        };
        let etchingScene, etchingCamera, etchingRenderer, etchingGrid, etchingComposer, etchingBloomPass;
        const ETCHING_BOUNDS = 10;

        /* ---------- DOM Elements (Cached) ---------- */
        const DOM = {
            runTag: document.getElementById('runTag'),
            flashOverlay: document.getElementById('flash-overlay'),
            tooltip: document.getElementById('tooltip'),
            rotorCanvas: document.getElementById('rotorCanvas'),
            etchingCanvas: document.getElementById('etchingCanvas'),
            etchingContainer: document.getElementById('etchingContainer'),
            floatingEtchingPanel: document.getElementById('floatingEtchingPanel'),
            floatingEtchingHeader: document.querySelector('#floatingEtchingPanel .panel-header'),
            status: document.getElementById('status'),
            themeToggle: document.getElementById('themeToggle'),
            sceneCanvas: document.getElementById('scene'),
            wavefunctionCanvas: document.getElementById('wavefunctionCanvas'),
            wxMood: document.getElementById('wx-mood'),
            wxRegion: document.getElementById('wx-region'),
            wxPressure: document.getElementById('wx-pressure'),
            moodIntensity: document.getElementById('mood-intensity'),
            moodEntropy: document.getElementById('mood-entropy'),
            moodCoherence: document.getElementById('mood-coherence'),
            vitals: document.getElementById('vitals'),
            encoderStatus: document.getElementById('encoder-status'),
            globalTension: document.getElementById('global-tension'),
            // MODIFICATION: Changed ringDream to ringPressure
            ringPressure: document.getElementById('ringPressure'),
            ringTeacher: document.getElementById('ringTeacher'),
            ringExplorer: document.getElementById('ringExplorer'),
            ringReward: document.getElementById('ringReward'),
            goalsList: document.getElementById('goalsList'),
            tickerText: document.getElementById('tickerText'),
            shellTensionSparklines: document.getElementById('shellTensionSparklines'),
            goalsCanvas: document.getElementById('goalsCanvas'),
            teacherQuestion: document.getElementById('teacher-question'),
            explorerAnswer: document.getElementById('explorer-answer'),
        };

        // UPGRADE: Make the floating panel draggable
        function enableDrag(panel, handle) {
            if (!panel || !handle) return;
            let startX = 0, startY = 0, startLeft = 0, startTop = 0, dragging = false;

            const start = (e) => {
                dragging = true;
                handle.classList.add('dragging');
                const pt = ('touches' in e) ? e.touches[0] : e;
                startX = pt.clientX; startY = pt.clientY;
                const rect = panel.getBoundingClientRect();
                panel.style.top = rect.top + 'px';
                panel.style.left = rect.left + 'px';
                panel.style.bottom = '';
                startLeft = rect.left; startTop = rect.top;
                window.addEventListener('mousemove', move);
                window.addEventListener('touchmove', move, { passive: false });
                window.addEventListener('mouseup', end);
                window.addEventListener('touchend', end);
                e.preventDefault?.();
            };
            const move = (e) => {
                if (!dragging) return;
                const pt = ('touches' in e) ? e.touches[0] : e;
                const dx = pt.clientX - startX;
                const dy = pt.clientY - startY;
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                const vw = window.innerWidth, vh = window.innerHeight;
                const { width: w, height: h } = panel.getBoundingClientRect();
                newLeft = Math.max(8, Math.min(vw - w - 8, newLeft));
                newTop = Math.max(8, Math.min(vh - h - 8, newTop));
                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
                e.preventDefault?.();
            };
            const end = () => {
                dragging = false;
                handle.classList.remove('dragging');
                window.removeEventListener('mousemove', move);
                window.removeEventListener('touchmove', move);
                window.removeEventListener('mouseup', end);
                window.removeEventListener('touchend', end);
            };
            handle.addEventListener('mousedown', start);
            handle.addEventListener('touchstart', start, { passive: false });
        }


        const rctx = DOM.rotorCanvas.getContext('2d');
        const wctx = DOM.wavefunctionCanvas.getContext('2d');

        /* ---------- Utility Functions ---------- */
        function num(x, d = 0) { const v = Number(x); return Number.isFinite(v) ? v : d; }
        function pick(obj, keys, d = undefined) { for (const k of keys) { if (obj && obj[k] !== undefined) return obj[k]; } return d; }

        function setStatus(msg) { if (DOM.status) DOM.status.textContent = msg; }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            return hash;
        }
        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.match(/^#([A-Fa-f0-9]{3}){1,2}$/)) {
                let c = hex.substring(1).split('');
                if (c.length === 3) { c = [c[0], c[0], c[1], c[1], c[2], c[2]]; }
                c = '0x' + c.join('');
                r = (c >> 16) & 255; g = (c >> 8) & 255; b = c & 255;
            }
            return `rgba(${r},${g},${b},${alpha})`;
        }
        function getBloomingGoldColor() {
            const gold = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--gold').trim());
            const white = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--white-glow').trim());
            return gold.lerp(white, Math.random() * 0.4);
        }
        function drawRing(canvas, frac, colorVar = '--accent') {
            const ctx = canvas.getContext('2d'); const w = canvas.width, h = canvas.height; const r = Math.min(w, h) / 2 - 6;
            ctx.clearRect(0, 0, w, h);
            ctx.save(); ctx.translate(w / 2, h / 2);
            ctx.lineWidth = 8;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--glass-2'); ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke();
            const color = getComputedStyle(document.documentElement).getPropertyValue(colorVar) || '#8ef1ff';
            ctx.strokeStyle = color.trim(); ctx.beginPath();
            ctx.arc(0, 0, r, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * Math.max(0, Math.min(1, frac)))); ctx.stroke();
            ctx.restore();
        }
        function sparkline(elem, values, maxPoints = 64) {
            const canvas = elem.querySelector('canvas') || (() => {
                const c = document.createElement('canvas'); c.width = 300; c.height = 40; elem.appendChild(c); return c;
            })();
            const ctx = canvas.getContext('2d'); const w = canvas.width, h = canvas.height;
            while (values.length > maxPoints) values.shift();
            ctx.clearRect(0, 0, w, h);
            const min = Math.min(...values, 0), max = Math.max(...values, 1e-6);
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            ctx.beginPath();
            values.forEach((v, i) => {
                const x = (i / (maxPoints - 1)) * w;
                const y = h - ((v - min) / (max - min + 1e-6)) * (h - 6) - 3;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }
        function pct(x) { return Math.max(0, Math.min(1, x)); }

        /* ---------------- Theme Toggle Logic ---------------- */
        function applyTheme(scene, bloomPass) {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const isLight = currentTheme === 'light';

            scene.background = new THREE.Color(isLight ? 0xf0f2f7 : 0x0b0f17);
            DOM.themeToggle.textContent = isLight ? '🌙' : '☀️';
            bloomPass.strength = isLight ? 0.25 : 0.3;
            bloomPass.threshold = 0.9;
            if (etchingBloomPass) { etchingBloomPass.strength = isLight ? 0.28 : 0.35; etchingBloomPass.threshold = 0.85; etchingBloomPass.radius = 0.55; }
            bloomPass.radius = 0.5;

            if (blackHole) {
                const horizonColor = isLight ? '#0b1633' : '#040810';
                const highlightColor = isLight ? '#1f3f8c' : '#2656c5';
                blackHole.horizon.uniforms.uTint.value.set(horizonColor);
                blackHole.horizon.uniforms.uHighlight.value.set(highlightColor);

                const innerDisk = isLight ? '#ff9f5a' : '#ffc98a';
                const outerDisk = isLight ? '#3a6bff' : '#1f3ce6';
                blackHole.disk.uniforms.uColorInner.value.set(innerDisk);
                blackHole.disk.uniforms.uColorOuter.value.set(outerDisk);

                blackHole.photonRing.material.color.set(isLight ? 0xffc27d : 0xffe2af);
                blackHole.photonRing.material.opacity = isLight ? 0.68 : 0.82;
                blackHole.jets.forEach((jet) => {
                    jet.uniforms.uColor.value.set(isLight ? 0x3fb4ff : 0x7dd9ff);
                });
                if (blackHole.starField?.material) {
                    blackHole.starField.material.opacity = isLight ? 0.55 : 0.85;
                }
                if (blackHole.lights?.ambient) {
                    blackHole.lights.ambient.intensity = isLight ? 0.12 : 0.08;
                }
            }

            if (etchingScene) {
                etchingScene.background = null;
                if (etchingGrid) {
                    etchingGrid.material.color.set(isLight ? '#000000' : '#c0c0c0');
                }
            }
        }


        DOM.themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            applyTheme(scene, bloomPass);
        });

        /* ---------------- Three.js Core Setup ---------------- */
        const renderer = new THREE.WebGLRenderer({ canvas: DOM.sceneCanvas, antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.autoClear = false;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.enablePan = false;
        controls.minDistance = 6;
        controls.maxDistance = 36;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.22;
        camera.position.set(0, 2.5, 18);
        controls.target.set(0, 0, 0);
        cameraRig.targetRadius = camera.position.distanceTo(controls.target);
        cameraRig.currentRadius = cameraRig.targetRadius;
        let isUserInteracting = false;
        controls.addEventListener('start', () => { isUserInteracting = true; });
        controls.addEventListener('end', () => {
            isUserInteracting = false;
            cameraRig.targetRadius = camera.position.distanceTo(controls.target);
            cameraRig.currentRadius = cameraRig.targetRadius;
        });
        window.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'r') {
                controls.reset();
                camera.position.set(0, 2.5, 18);
                cameraRig.targetRadius = camera.position.distanceTo(controls.target);
                cameraRig.currentRadius = cameraRig.targetRadius;
            }
        });
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 0.3, 0.5, 0.9);
        composer.addPass(bloomPass);

        function resize() {
            const w = DOM.sceneCanvas.clientWidth; const h = DOM.sceneCanvas.clientHeight;
            renderer.setSize(w, h, false);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            composer.setSize(w, h);
            if (etchingCamera) resizeEtchingView();
            if (etchingComposer) { etchingComposer.setSize(w, h); }
        }
        new ResizeObserver(resize).observe(DOM.sceneCanvas);

        /* ---------------- Kerr Black Hole Visualization ---------------- */
        function createKerrBlackHole() {
            const group = new THREE.Group();
            group.name = 'kerrBlackHole';

            const horizonUniforms = {
                uTime: { value: 0 },
                uSpin: { value: 0.9 },
                uFalloff: { value: 2.2 },
                uTint: { value: new THREE.Color('#04060d') },
                uHighlight: { value: new THREE.Color('#162447') },
            };
            const horizon = new THREE.Mesh(
                new THREE.SphereGeometry(1.9, 96, 96),
                new THREE.ShaderMaterial({
                    uniforms: horizonUniforms,
                    vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPos;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
                    fragmentShader: `
                uniform float uTime;
                uniform float uSpin;
                uniform float uFalloff;
                uniform vec3 uTint;
                uniform vec3 uHighlight;
                varying vec3 vNormal;
                varying vec3 vPos;
                void main() {
                    float r = length(vPos);
                    float angle = atan(vPos.z, vPos.x);
                    float swirl = sin((angle + uTime * uSpin) * 4.0) * 0.15;
                    float horizon = smoothstep(1.9, uFalloff, r + swirl);
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0))), 2.0);
                    vec3 color = mix(uTint, uHighlight, fresnel);
                    color *= 0.55 + horizon * 0.45;
                    gl_FragColor = vec4(color, 1.0);
                }`,
                    depthWrite: true,
                })
            );
            group.add(horizon);

            const diskUniforms = {
                uTime: { value: 0 },
                uLuminosity: { value: 0.5 },
                uHeat: { value: 0.5 },
                uColorInner: { value: new THREE.Color('#ffbb73') },
                uColorOuter: { value: new THREE.Color('#2f5fff') },
            };
            const diskGeometry = new THREE.RingGeometry(2.6, 8.8, 320, 1);
            diskGeometry.rotateX(-Math.PI / 2);
            const disk = new THREE.Mesh(
                diskGeometry,
                new THREE.ShaderMaterial({
                    uniforms: diskUniforms,
                    vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
                    fragmentShader: `
                uniform float uTime;
                uniform float uLuminosity;
                uniform float uHeat;
                uniform vec3 uColorInner;
                uniform vec3 uColorOuter;
                varying vec2 vUv;
                void main() {
                    float radius = vUv.y;
                    float theta = vUv.x * 6.28318;
                    float swirl = theta * 6.0 + uTime * (1.2 + uHeat * 2.0);
                    float turbulence = sin(swirl + radius * 22.0) * 0.5 + 0.5;
                    float sparks = sin(swirl * 3.0 + uTime * 4.0) * 0.5 + 0.5;
                    vec3 baseColor = mix(uColorOuter, uColorInner, pow(radius, 0.35));
                    vec3 color = baseColor + (turbulence * uLuminosity) * vec3(1.4, 1.0, 0.6);
                    color += (sparks * uHeat) * vec3(1.4, 0.6, 0.2);
                    float alpha = smoothstep(0.02, 0.12, radius) * (1.0 - smoothstep(0.92, 1.0, radius));
                    alpha *= 0.55 + uLuminosity * 0.5;
                    if (alpha < 0.015) discard;
                    gl_FragColor = vec4(color, alpha);
                }`,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                })
            );
            disk.position.y = 0.05;
            group.add(disk);

            const photonRing = new THREE.Mesh(
                new THREE.TorusGeometry(2.25, 0.12, 48, 320),
                new THREE.MeshBasicMaterial({ color: 0xffd7a4, transparent: true, opacity: 0.75, blending: THREE.AdditiveBlending })
            );
            photonRing.name = 'photonRing';
            group.add(photonRing);

            const jetGeometry = new THREE.CylinderGeometry(0.4, 0.08, 14, 32, 1, true);
            const jetUniformTemplate = {
                uTime: { value: 0 },
                uStrength: { value: 0.3 },
                uColor: { value: new THREE.Color('#6bd3ff') },
            };
            const jetVertexShader = `
            varying float vPosY;
            void main() {
                vPosY = position.y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }`;
            const jetFragmentShader = `
            uniform float uTime;
            uniform float uStrength;
            uniform vec3 uColor;
            varying float vPosY;
            void main() {
                float band = 1.0 - abs(vPosY) / 7.0;
                band = clamp(band, 0.0, 1.0);
                float pulse = sin(uTime * 5.0 + vPosY * 2.2) * 0.5 + 0.5;
                float alpha = pow(band, 1.8) * (uStrength * 1.1) * (0.6 + pulse * 0.6);
                if (alpha < 0.02) discard;
                vec3 color = uColor * (0.7 + pulse * 0.6);
                gl_FragColor = vec4(color, alpha);
            }`;
            const createJetMaterial = () => new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(jetUniformTemplate),
                vertexShader: jetVertexShader,
                fragmentShader: jetFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });
            const jetTop = new THREE.Mesh(jetGeometry, createJetMaterial());
            jetTop.position.y = 7.5;
            const jetBottom = new THREE.Mesh(jetGeometry, createJetMaterial());
            jetBottom.position.y = -7.5;
            jetBottom.rotation.x = Math.PI;
            group.add(jetTop, jetBottom);

            const starCount = 4000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 80 + Math.random() * 80;
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.cos(phi);
                const z = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i3 + 0] = x;
                starPositions[i3 + 1] = y;
                starPositions[i3 + 2] = z;
                const c = 0.75 + Math.random() * 0.25;
                starColors[i3 + 0] = c;
                starColors[i3 + 1] = c;
                starColors[i3 + 2] = 1.0;
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            const starMaterial = new THREE.PointsMaterial({
                size: 0.8,
                transparent: true,
                opacity: 0.85,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            starField.frustumCulled = false;
            group.add(starField);

            const rimLight = new THREE.PointLight(0xffb37a, 3.4, 180);
            rimLight.position.set(9, 6, 4);
            const coolLight = new THREE.PointLight(0x4c7fff, 2.2, 180);
            coolLight.position.set(-10, -4, -6);
            const ambient = new THREE.AmbientLight(0xffffff, 0.08);
            group.add(rimLight, coolLight, ambient);

            return {
                group,
                horizon: { mesh: horizon, uniforms: horizonUniforms },
                disk: { mesh: disk, uniforms: diskUniforms },
                photonRing,
                jets: [
                    { mesh: jetTop, uniforms: jetTop.material.uniforms },
                    { mesh: jetBottom, uniforms: jetBottom.material.uniforms },
                ],
                starField: { mesh: starField, material: starMaterial },
                lights: { rimLight, coolLight, ambient },
            };
        }

        function updateKerrBlackHole(dt, time) {
            if (!blackHole) return;

            const pressure = state.smooth.pressure;
            const reward = state.smooth.reward;
            const teacher = state.smooth.teacher;
            const explorer = state.smooth.explorer;
            const moodIntensity = state.smooth.moodIntensity;
            const moodEntropy = state.smooth.moodEntropy;
            const moodCoherence = state.smooth.moodCoherence;
            const tension = state.smooth.globalTension;

            const diff = THREE.MathUtils.clamp((teacher - explorer) * 0.5 + 0.5, 0, 1); // 0..1 tilt bias

            blackHole.horizon.uniforms.uTime.value = time;
            blackHole.horizon.uniforms.uSpin.value = THREE.MathUtils.lerp(0.6, 2.6, moodCoherence);
            blackHole.horizon.uniforms.uFalloff.value = THREE.MathUtils.lerp(1.7, 2.5, 1 - moodIntensity);

            blackHole.disk.uniforms.uTime.value = time;
            blackHole.disk.uniforms.uLuminosity.value = THREE.MathUtils.lerp(0.25, 1.8, pressure);
            blackHole.disk.uniforms.uHeat.value = THREE.MathUtils.lerp(0.15, 1.2, pressure);

            blackHole.photonRing.material.opacity = THREE.MathUtils.lerp(0.35, 0.9, pressure);
            const ringHue = THREE.MathUtils.lerp(0.06, 0.12, pressure);
            const ringSat = THREE.MathUtils.lerp(0.78, 1.0, reward);
            const ringLight = THREE.MathUtils.lerp(0.55, 0.82, pressure);
            blackHole.photonRing.material.color.setHSL(ringHue, ringSat, ringLight);

            blackHole.jets.forEach((jet, idx) => {
                jet.uniforms.uTime.value = time + idx * 0.5;
                jet.uniforms.uStrength.value = THREE.MathUtils.lerp(0.05, 1.35, reward);
            });

            blackHole.starField.mesh.rotation.y += dt * THREE.MathUtils.lerp(0.01, 0.05, moodEntropy);

            const wobble = (Math.sin(time * 0.35) * 0.12 + (diff - 0.5) * 0.4) * (0.4 + tension * 0.6);
            blackHole.group.rotation.x = THREE.MathUtils.lerp(blackHole.group.rotation.x, wobble, 0.08);
            blackHole.group.rotation.z = THREE.MathUtils.lerp(blackHole.group.rotation.z, (diff - 0.5) * 0.6, 0.08);
            blackHole.group.rotation.y += dt * THREE.MathUtils.lerp(0.15, 0.55, moodCoherence);

            controls.autoRotateSpeed = THREE.MathUtils.lerp(0.12, 0.65, moodEntropy);
            cameraRig.targetRadius = THREE.MathUtils.lerp(9, 24, 1 - moodIntensity);
        }

        /* ---------------- 2D Rotor Visualization ---------------- */
        function updateRotorState(shellsData) {
            if (!shellsData) return;
            for (const dim in shellsData) {
                if (!state.rotors[dim]) {
                    state.rotors[dim] = { angle: Math.random() * Math.PI * 2, speed: 0, targetSpeed: 0 };
                }
                const orientationStr = JSON.stringify(shellsData[dim].orientation || '');
                const hash = simpleHash(orientationStr);
                state.rotors[dim].targetSpeed = ((hash % 1000) / 1000 - 0.5) * 2.0;
            }
        }

        function drawRotors(dt) {
            const dpr = devicePixelRatio || 1;
            const p = DOM.rotorCanvas.parentElement.getBoundingClientRect();
            if (!p || p.width === 0 || p.height === 0) return;
            const w = Math.floor(p.width * dpr); const h = Math.floor(p.height * dpr);
            if (DOM.rotorCanvas.width !== w || DOM.rotorCanvas.height !== h) { DOM.rotorCanvas.width = w; DOM.rotorCanvas.height = h; }
            const styles = getComputedStyle(document.documentElement);
            const accentColor = styles.getPropertyValue('--accent').trim(); const fgColor = styles.getPropertyValue('--fg').trim();
            const labelBgColor = styles.getPropertyValue('--rotor-label-bg').trim(); const glowColor = styles.getPropertyValue('--glow').trim();
            rctx.clearRect(0, 0, w, h); const cx = w / 2; const cy = h / 2;
            const dims = Object.keys(state.rotors).map(Number).sort((a, b) => b - a);
            if (dims.length === 0) return;
            const maxRadius = Math.min(w, h) * 0.40; const minRadius = maxRadius * 0.2;
            dims.forEach((dim, i) => {
                const rotor = state.rotors[dim];
                rotor.speed += (rotor.targetSpeed - rotor.speed) * 0.1; rotor.angle += rotor.speed * dt * 1.5;
                const zFactor = 0.95 + Math.abs(rotor.speed) * 0.15;
                const baseRadius = dims.length > 1 ? maxRadius - (i / (dims.length - 1)) * (maxRadius - minRadius) : maxRadius;
                const radius = baseRadius * zFactor;
                rctx.shadowColor = hexToRgba(glowColor, 0.4); rctx.shadowBlur = 12 * dpr * zFactor;
                rctx.shadowOffsetX = 0; rctx.shadowOffsetY = 0;
                rctx.strokeStyle = hexToRgba(accentColor, 0.25); rctx.lineWidth = 1 * dpr * zFactor;
                rctx.beginPath(); rctx.arc(cx, cy, radius, 0, Math.PI * 2); rctx.stroke();
                const numSpokes = 3 + Math.floor(Math.log2(dim));
                rctx.strokeStyle = hexToRgba(accentColor, 0.4 + (i / dims.length) * 0.5);
                rctx.lineWidth = 1.5 * dpr * zFactor;
                for (let j = 0; j < numSpokes; j++) {
                    const angle = rotor.angle + (j / numSpokes) * Math.PI * 2;
                    const innerRad = radius * 0.85;
                    const startX = cx + Math.cos(angle) * innerRad, startY = cy + Math.sin(angle) * innerRad;
                    const endX = cx + Math.cos(angle) * radius, endY = cy + Math.sin(angle) * radius;
                    rctx.beginPath(); rctx.moveTo(startX, startY); rctx.lineTo(endX, endY); rctx.stroke();
                }
                rctx.shadowColor = 'transparent'; rctx.shadowBlur = 0;
                const labelAngle = rotor.angle * 0.5 + (i * 1.1);
                const labelX = cx + Math.cos(labelAngle) * radius, labelY = cy + Math.sin(labelAngle) * radius;
                rctx.fillStyle = labelBgColor; rctx.beginPath();
                rctx.arc(labelX, labelY, 10 * dpr * zFactor, 0, Math.PI * 2); rctx.fill();
                rctx.fillStyle = fgColor; rctx.font = `${9 * dpr * zFactor}px system-ui, sans-serif`;
                rctx.textAlign = 'center'; rctx.textBaseline = 'middle';
                rctx.fillText(`${dim}D`, labelX, labelY);
            });
        }

        /* ---------------- Quantum Wavefunction Visualization ---------------- */
        function drawWavefunction(time) {
            const dpr = devicePixelRatio || 1;
            const p = DOM.wavefunctionCanvas.parentElement.getBoundingClientRect();
            if (!p || p.width === 0 || p.height === 0) return;
            const w = Math.floor(p.width * dpr);
            const h = Math.floor(p.height * dpr);
            if (DOM.wavefunctionCanvas.width !== w || DOM.wavefunctionCanvas.height !== h) {
                DOM.wavefunctionCanvas.width = w; DOM.wavefunctionCanvas.height = h;
            }
            wctx.clearRect(0, 0, w, h);
            const styles = getComputedStyle(document.documentElement);
            const accentColor = styles.getPropertyValue('--accent').trim();
            const glowColor = styles.getPropertyValue('--glow').trim();
            const waves = [{ amp: h * 0.25, freq: 2.5, speed: 1.5, phase: 0.5 }, { amp: h * 0.15, freq: 5.5, speed: -1.0, phase: 1.5 }, { amp: h * 0.10, freq: 8.0, speed: 2.0, phase: 2.0 }];
            wctx.lineWidth = 1.8 * dpr; wctx.strokeStyle = accentColor;
            wctx.shadowColor = glowColor; wctx.shadowBlur = 10 * dpr;
            wctx.globalAlpha = 0.8;
            wctx.beginPath();
            for (let x = 0; x < w; x++) {
                const t = x / w;
                let y = h / 2;
                for (const wave of waves) {
                    y += Math.sin(t * Math.PI * 2 * wave.freq + time * wave.speed + wave.phase) * wave.amp * (Math.sin(time * 0.3 + wave.phase) * 0.2 + 0.8);
                }
                if (x === 0) wctx.moveTo(x, y); else wctx.lineTo(x, y);
            }
            wctx.stroke(); wctx.shadowBlur = 0; wctx.globalAlpha = 1.0;
        }

        /* ---------------- 3D Memory Etching ---------------- */
        function initEtchingScene() {
            etchingScene = new THREE.Scene();
            etchingRenderer = new THREE.WebGLRenderer({ canvas: DOM.etchingCanvas, antialias: true, alpha: true });
            etchingRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const B = ETCHING_BOUNDS;
            etchingGrid = new THREE.GridHelper(B * 2, 20, '#333333', '#333333');
            etchingGrid.material.opacity = 0.2;
            etchingGrid.material.transparent = true;
            etchingGrid.position.y = -B;
            etchingScene.add(etchingGrid);

            etchingScene.add(new THREE.AmbientLight(0xffffff, 0.5));

            const aspect = DOM.etchingContainer.clientWidth / DOM.etchingContainer.clientHeight;
            const frustumSize = 20;
            etchingCamera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
            etchingCamera.position.set(25, 25, 25);
            etchingCamera.lookAt(0, 0, 0);
            etchingScene.add(etchingCamera);

            etchingComposer = new EffectComposer(etchingRenderer);
            etchingComposer.addPass(new RenderPass(etchingScene, etchingCamera));
            etchingBloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 0.35, 0.6, 0.85);
            etchingComposer.addPass(etchingBloomPass);

            resizeEtchingView();
        }
        function resizeEtchingView() {
            const p = DOM.etchingContainer;
            if (!p || !etchingCamera) return;
            const w = p.clientWidth; const h = p.clientHeight;
            if (w === 0 || h === 0) return;
            etchingRenderer.setSize(w, h);
            const aspect = w / h;
            const frustumSize = 20;
            etchingCamera.left = frustumSize * aspect / -2;
            etchingCamera.right = frustumSize * aspect / 2;
            etchingCamera.top = frustumSize / 2;
            etchingCamera.bottom = frustumSize / -2;
            etchingCamera.updateProjectionMatrix();
        }
        function triggerEtchingAnimation(count) {
            const B = ETCHING_BOUNDS;
            for (let i = 0; i < count; i++) {
                const points = [];
                const startPoint = new THREE.Vector3((Math.random() - 0.5) * B * 2, (Math.random() - 0.5) * B * 2, (Math.random() - 0.5) * B * 2);
                points.push(startPoint);
                let currentPoint = startPoint.clone();
                const numSegments = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numSegments; j++) {
                    const nextPoint = currentPoint.clone().add(new THREE.Vector3((Math.random() - 0.5) * B, (Math.random() - 0.5) * B, (Math.random() - 0.5) * B));
                    nextPoint.clampScalar(-B, B);
                    points.push(nextPoint);
                    currentPoint = nextPoint;
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeo = new THREE.TubeGeometry(curve, 64, 0.1, 8, false);
                const color = getBloomingGoldColor();
                const tubeMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
                const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
                tubeMesh.geometry.setDrawRange(0, 0);
                etchingScene.add(tubeMesh);
                state.etchings.push({ mesh: tubeMesh, progress: 0, totalDrawCount: tubeMesh.geometry.attributes.position.count, speed: 0.8 + Math.random() * 0.4, isComplete: false });
            }
        }
        function updateMemoryEtching(dt) {
            if (!etchingScene) return;
            const remainingEtchings = [];
            for (const etch of state.etchings) {
                if (etch.isComplete) {
                    etch.mesh.material.opacity -= dt * 0.1;
                    if (etch.mesh.material.opacity > 0) {
                        remainingEtchings.push(etch);
                    } else {
                        etchingScene.remove(etch.mesh);
                        etch.mesh.geometry.dispose();
                        etch.mesh.material.dispose();
                    }
                    continue;
                }
                etch.progress += etch.speed * dt;
                const currentDrawCount = Math.floor(etch.totalDrawCount * Math.min(etch.progress, 1));
                etch.mesh.geometry.setDrawRange(0, currentDrawCount * 3);
                if (etch.progress >= 1.0) {
                    etch.isComplete = true;
                }
                remainingEtchings.push(etch);
            }
            state.etchings = remainingEtchings;
            etchingScene.rotation.y += dt * 0.05;
        }

        /* ---------- Goals overlay renderer ---------- */
        function drawGoalsOverlay(entries) {
            const c = DOM.goalsCanvas; const ctx = c.getContext('2d');
            const w = c.width = c.clientWidth; const h = c.height = c.clientHeight;
            ctx.clearRect(0, 0, w, h);
            const cx = w / 2, cy = h / 2, R = Math.min(w, h) * 0.42;
            const n = Math.max(1, entries.length);
            entries.forEach(([name, val], i) => {
                const t = i / n; const ang = t * Math.PI * 2;
                const r = R * (0.5 + 0.5 * (val));
                const x = cx + r * Math.cos(ang), y = cy + r * Math.sin(ang);
                ctx.globalAlpha = 0.35; ctx.lineWidth = 1.2;
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x, y); ctx.stroke();
                ctx.globalAlpha = 0.9; ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2').trim();
                ctx.beginPath(); ctx.arc(x, y, 3 + 4 * val, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 0.9; ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim();
                ctx.font = '11px system-ui';
                ctx.fillText(name, x + 6, y - 6);
            });
            ctx.globalAlpha = 0.25;
            ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim(); ctx.stroke();
        }

        /* ---------- UI Update Functions (centralized) ---------- */
        function updateUI(telemetry) {
            if (!telemetry) return;
            const wx = telemetry.symbolic_weather || {};
            if (DOM.wxMood) {
                DOM.wxMood.textContent = wx.mood ?? telemetry.mood_label ?? '—';
            }
            if (DOM.wxRegion) {
                DOM.wxRegion.textContent = wx.region ?? telemetry.environment_theme ?? telemetry.region ?? telemetry.context ?? '—';
            }
            const pRaw = (typeof wx.pressure === 'number')
                ? wx.pressure
                : (typeof telemetry.bh_pressure === 'number')
                    ? telemetry.bh_pressure
                    : (typeof telemetry.pressure === 'number')
                        ? telemetry.pressure
                        : 0;
            state.targets.wxPressure = Math.max(0, Math.min(1, pRaw));
            state.targets.pressure = state.targets.wxPressure;

            const m = telemetry.mood || { intensity: pick(telemetry, ['mood_intensity'], 0.5), entropy: pick(telemetry, ['mood_entropy'], 0.5), coherence: pick(telemetry, ['mood_coherence'], 0.5) };
            const clamp = (v) => Math.max(0, Math.min(1, v || 0.5));
            state.targets.moodIntensity = clamp(m.intensity);
            state.targets.moodEntropy = clamp(m.entropy);
            state.targets.moodCoherence = clamp(m.coherence);

            if (DOM.vitals) {
                DOM.vitals.innerHTML = `
            <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--muted);padding:4px;"><label>Cycle Step</label><span>${telemetry.step ?? 'N/A'}</span></div>
            <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--muted);padding:4px;"><label>Active Memories</label><span>${telemetry.memory_count ?? 'N/A'}</span></div>
        `;
            }

            DOM.teacherQuestion.textContent = pick(telemetry, ['teacher_question', 'teacher_last_question', 'teacher_prompt'], '—');
            DOM.explorerAnswer.textContent = pick(telemetry, ['explorer_answer', 'explorer_last_answer', 'explorer_response'], '—');

            const clamp01 = (v) => Math.max(0, Math.min(1, Number.isFinite(v) ? v : 0));
            const tNext = telemetry.teacher_ticks_to_next ?? telemetry.teacher_in ?? telemetry.teacher_ticks ?? 0;
            const eNext = telemetry.explorer_ticks_to_next ?? telemetry.explorer_in ?? telemetry.explorer_ticks ?? 0;
            state.targets.teacher = clamp01(1 - (tNext / 10));
            state.targets.explorer = clamp01(1 - (eNext / 10));
            const rewardRaw = telemetry.insight_agent_avg_reward ?? telemetry.avg_reward ?? telemetry.reward ?? 0;
            state.targets.reward = clamp01(rewardRaw);

            const goals = telemetry.goals || {};
            const entries = Object.entries(goals).sort((a, b) => b[1] - a[1]).slice(0, 16);
            DOM.goalsList.innerHTML = entries.map(([k, v]) => `<div class="row"><span class="label">${k}</span><span class="value">${v.toFixed(3)}</span></div>`).join('');
            drawGoalsOverlay(entries);

            const sn = (pick(telemetry, ['subconscious_narrative', 'narrative', 'ticker'], '') || '').replace(/\s+/g, ' ').trim();
            DOM.tickerText.textContent = sn ? (sn + ' • '.repeat(3)) : '';

            if (DOM.encoderStatus) {
                DOM.encoderStatus.textContent = telemetry.autoencoder_trained ? 'Trained' : 'Untrained';
            }

            const gt = typeof telemetry.global_tension === 'number' ? telemetry.global_tension : 0;
            state.targets.globalTension = gt;

            let st = telemetry.shell_tensions || {};
            if ((!st || Object.keys(st).length === 0) && telemetry.shells) {
                // derive from shells[dim].tension if present
                st = {};
                Object.keys(telemetry.shells).forEach(dim => {
                    const v = telemetry.shells[dim]?.tension;
                    if (v !== undefined) st[dim] = v;
                });
            }
            DOM.shellTensionSparklines.innerHTML = '';
            Object.keys(st).sort((a, b) => Number(a) - Number(b)).forEach(dim => {
                const wrap = document.createElement('div');
                wrap.className = 'weather-box';
                wrap.innerHTML = `<div class="row"><span class="label">Shell ${dim}D</span><span class="value">${(st[dim] || 0).toFixed(3)}</span></div>`;
                DOM.shellTensionSparklines.appendChild(wrap);
                const series = state.shellSparklines.get(dim) || [];
                series.push(st[dim] || 0);
                state.shellSparklines.set(dim, series);
                sparkline(wrap, series);
            });

            DOM.status.textContent = `Step ${telemetry.step ?? 'N/A'} • ${entries.length} goals • ${Object.keys(st).length} shells`;
        }

        /* ---------------- Main Loop & Data Stream ---------------- */
        function startDataStream() {
            let pollTimer = null;
            function stopPolling() { if (pollTimer) { clearInterval(pollTimer); pollTimer = null; } }
            async function startPolling() {
                stopPolling();
                setStatus('Falling back to polling…');
                DOM.runTag.textContent = 'POLL'; DOM.runTag.style.color = 'var(--warn)';
                pollTimer = setInterval(async () => {
                    try {
                        const r = await fetch(API.telemetryLatest, { cache: 'no-store' });
                        if (r.ok) { const telemetry = await r.json(); state.currentTelemetry = telemetry; updateUI(telemetry); if (telemetry.shells) updateRotorState(telemetry.shells); }
                    } catch (e) { console.error('Polling error', e); }
                }, 1000);
            }

            setStatus('Connecting to telemetry stream...');
            let eventSource = new EventSource(API.telemetryStream);

            const connect = () => {
                eventSource = new EventSource(API.telemetryStream);

                eventSource.onopen = () => {
                    stopPolling();
                    console.log("Telemetry stream connected.");
                    setStatus('Connected to active cognitive cycle.');
                    DOM.runTag.textContent = `ONLINE`;
                    DOM.runTag.style.color = 'var(--ok)';
                    state.running = true;
                };

                const handleMsg = (raw) => {
                    try {
                        const telemetry = JSON.parse(raw.data);
                        state.currentTelemetry = telemetry;
                        updateUI(telemetry);
                        if (telemetry.shells) updateRotorState(telemetry.shells);
                        const currentMemoryCount = telemetry.memory_count ?? state.lastMemoryCount;
                        if (currentMemoryCount > state.lastMemoryCount) { triggerEtchingAnimation(currentMemoryCount - state.lastMemoryCount); }
                        state.lastMemoryCount = currentMemoryCount;
                    } catch (e) {
                        console.error('Failed to parse telemetry data:', e);
                    }
                };
                eventSource.addEventListener('telemetry', (event) => handleMsg(event));
                eventSource.onmessage = (event) => handleMsg(event);

                eventSource.onerror = (err) => {
                    console.error("EventSource failed:", err);
                    setStatus('Stream disconnected. Reconnecting in 5s...');
                    state.running = false;
                    DOM.runTag.textContent = 'OFFLINE';
                    DOM.runTag.style.color = 'var(--muted)';
                    eventSource.close();
                    startPolling();
                    setTimeout(connect, 5000);
                };
            }

            connect();
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const now = clock.getElapsedTime();

            if (blackHole) {
                updateKerrBlackHole(dt, now);
            }

            drawRotors(dt);
            updateMemoryEtching(dt);
            drawWavefunction(now);

            // __SMOOTH_UPDATE_BLOCK__
            const s = 0.12; // smoothing factor per frame
            // MODIFICATION: Smooth the new 'pressure' state
            state.smooth.pressure = lerp(state.smooth.pressure, state.targets.pressure, s);
            state.smooth.moodIntensity = lerp(state.smooth.moodIntensity, state.targets.moodIntensity, s);
            state.smooth.moodEntropy = lerp(state.smooth.moodEntropy, state.targets.moodEntropy, s);
            state.smooth.moodCoherence = lerp(state.smooth.moodCoherence, state.targets.moodCoherence, s);
            state.smooth.teacher = lerp(state.smooth.teacher, state.targets.teacher, s);
            state.smooth.explorer = lerp(state.smooth.explorer, state.targets.explorer, s);
            state.smooth.reward = lerp(state.smooth.reward, state.targets.reward, s);
            state.smooth.wxPressure = lerp(state.smooth.wxPressure, state.targets.wxPressure, s);
            state.smooth.globalTension = lerp(state.smooth.globalTension, state.targets.globalTension, s);

            // Apply to DOM
            if (DOM.moodIntensity) DOM.moodIntensity.value = Math.max(0, Math.min(1, state.smooth.moodIntensity));
            if (DOM.moodEntropy) DOM.moodEntropy.value = Math.max(0, Math.min(1, state.smooth.moodEntropy));
            if (DOM.moodCoherence) DOM.moodCoherence.value = Math.max(0, Math.min(1, state.smooth.moodCoherence));

            // MODIFICATION: Draw the new 'pressure' ring
            drawRing(DOM.ringPressure, state.smooth.pressure, '--bad'); // Use red for pressure
            drawRing(DOM.ringTeacher, state.smooth.teacher);
            drawRing(DOM.ringExplorer, state.smooth.explorer);
            drawRing(DOM.ringReward, state.smooth.reward, '--ok');

            if (DOM.wxPressure) {
                const p = state.smooth.wxPressure;
                DOM.wxPressure.textContent = p.toFixed(2);
                DOM.wxPressure.style.color = p > 0.85 ? 'var(--bad)' : p > 0.6 ? 'var(--warn)' : 'var(--ok)';
            }
            if (DOM.globalTension) {
                const g = state.smooth.globalTension;
                DOM.globalTension.textContent = g.toFixed(3);
                DOM.globalTension.style.color = g > 0.85 ? 'var(--bad)' : g > 0.6 ? 'var(--warn)' : 'var(--ok)';
            }

            if (!isUserInteracting) {
                scratch.targetVec.set(0, THREE.MathUtils.lerp(-1.0, 2.8, state.smooth.moodEntropy), 0);
                controls.target.lerp(scratch.targetVec, 0.05);
                scratch.dirVec.copy(camera.position).sub(controls.target);
                const currentDistance = scratch.dirVec.length();
                cameraRig.currentRadius = THREE.MathUtils.lerp(currentDistance, cameraRig.targetRadius, 0.04);
                cameraRig.currentRadius = THREE.MathUtils.clamp(cameraRig.currentRadius, controls.minDistance, controls.maxDistance);
                scratch.dirVec.setLength(cameraRig.currentRadius);
                camera.position.copy(controls.target).add(scratch.dirVec);
            }

            controls.update();

            composer.render();
            if (etchingComposer) { etchingComposer.render(); } else if (etchingRenderer) { etchingRenderer.render(etchingScene, etchingCamera); }
        }

        /* ---------- Initialization ---------- */
        async function init() {
            setStatus('Building visualization...');
            blackHole = createKerrBlackHole();
            scene.add(blackHole.group);
            initEtchingScene();
            setStatus('Visualization ready. Waiting for cognitive cycle...');
            applyTheme(scene, bloomPass);
            resize();
            startDataStream();
            animate();
        }

        enableDrag(DOM.floatingEtchingPanel, DOM.floatingEtchingHeader);
        init();
    </script>
</body>

</html>