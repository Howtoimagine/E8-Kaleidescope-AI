-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>E8 Mind-Crystal (Live HUD) - M20</title>
    <style>
        :root {
            --bg: #0b0f17;
            --fg: #d9e1ff;
            --muted: #a7b0d6;
            --glow: #7aa2ff;
            --glass: rgba(16, 22, 33, 0.65);
            --glass-2: rgba(16, 22, 33, 0.35);
            --accent: #8ef1ff;
            --accent-2: #c792ea;
            --ok: #6ee7b7;
            --warn: #fde047;
            --bad: #fb7185;
            --border-color: rgba(255, 255, 255, 0.06);
        }

        html[data-theme="light"] {
            --bg: #f0f2f7;
            --fg: #1c1e26;
            --muted: #5a647e;
            --glow: #0052d6;
            --glass: rgba(255, 255, 255, 0.6);
            --glass-2: rgba(255, 255, 255, 0.3);
            --accent: #0097b3;
            --accent-2: #9e28d4;
            --ok: #069668;
            --warn: #d97706;
            --bad: #e11d48;
            --border-color: rgba(0, 0, 0, 0.1);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden;
        }

        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            display: grid;
            grid-template-columns: clamp(300px, 24vw, 380px) 1fr clamp(320px, 26vw, 420px);
            grid-template-rows: 60px 1fr 40px;
            grid-template-areas: "header header header" "left main right" "footer footer footer";
            gap: 16px;
            padding: 16px;
        }

        .panel {
            background: rgba(16, 22, 33, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* panel layout */

        .left-panel {
            grid-area: left;
        }

        .right-panel {
            grid-area: right;
            min-width: 300px;
            max-width: 100%;
        }

        #tetraPanel {
            grid-area: main;
        }

        #tetraCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .panel-title {
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: .5px;
            opacity: .8;
            flex-grow: 1;
        }

        .collapse-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--muted);
            width: 22px;
            height: 22px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background .2s, color .2s;
        }

        .collapse-btn:hover {
            background: var(--glass-2);
            color: var(--accent);
        }

        .collapsed+.panel-content {
            display: none !important;
        }

        .panel-content {
            padding: 16px;
            overflow-y: auto;
            overflow-x: hidden;
            flex-grow: 1;
            scrollbar-width: thin;
        }

        .panel-content.no-padding {
            padding: 0;
            position: relative;
        }

        header {
            grid-area: header;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            pointer-events: auto;
            background: linear-gradient(to right, rgba(20, 26, 40, 0.7), rgba(20, 26, 40, 0.3));
            border-bottom: 1px solid var(--border-color);
            border-radius: 12px;
        }

        .brand {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent);
        }

        .brand span {
            opacity: .7;
            font-weight: 400;
            font-size: 14px;
        }

        .status-tag {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(125, 145, 255, 0.15);
            color: #9ab0ff;
            border: 1px solid rgba(125, 145, 255, 0.25);
        }

        .footer {
            grid-area: footer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            color: var(--muted);
            font-size: 12px;
        }

        .weather-box {
            margin-top: 12px;
            padding: 8px 12px;
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 12px;
        }

        .weather-box .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .weather-box .label {
            color: var(--muted);
        }

        .weather-box .value {
            color: var(--fg);
            font-weight: 600;
            text-align: right;
        }

        .ring {
            position: relative;
            width: 92px;
            height: 92px;
        }

        .ring canvas {
            position: absolute;
            inset: 0;
        }

        .ring .ring-label {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--muted);
        }

        .tab-header {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            padding: 0 8px;
            flex-shrink: 0;
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--muted);
            padding: 10px 16px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 2px solid transparent;
        }

        .tab-btn.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            display: none;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
            min-height: 0;
            /* allow flex children to shrink */
        }

        .tab-content.active {
            display: flex;
        }

        .theme-toggle-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--fg);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* NEW STYLES FOR COMBINED SHELL DYNAMICS PANEL */
        #shellDynamicsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .shell-card {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            font-size: 12px;
        }

        .shell-card .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .shell-card .label {
            color: var(--muted);
        }

        .shell-card .value {
            color: var(--fg);
            font-weight: 600;
        }

        .shell-card canvas {
            width: 100%;
            height: 40px;
            margin-top: 8px;
        }

        /* --- Slice 1: Adaptive Proximity Styles --- */
        #proximityPanel {
            font-size: 12px;
        }

        #proximityEventsList {
            display: flex;
            flex-direction: column-reverse;
            gap: 4px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .proximity-event {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 6px 8px;
            background: var(--glass-2);
            display: flex;
            flex-direction: column;
            gap: 2px;
            line-height: 1.25;
        }

        .proximity-event .meta {
            display: flex;
            justify-content: space-between;
        }

        .proximity-tier-lock {
            border-color: var(--accent-2);
            box-shadow: 0 0 0 1px var(--accent-2) inset;
        }

        .proximity-tier-strong {
            border-color: var(--accent);
        }

        .proximity-tier-moderate {
            border-color: var(--warn);
        }

        .proximity-tier-weak,
        .proximity-tier-noise {
            opacity: 0.65;
        }

        .proximity-metric-chip {
            display: inline-block;
            background: var(--glass);
            padding: 2px 6px;
            border-radius: 999px;
            margin: 2px 4px 2px 0;
            border: 1px solid var(--border-color);
            font-size: 10px;
            letter-spacing: .3px;
        }

        #proximitySummary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 6px;
            margin-bottom: 8px;
        }

        .prox-stat {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            padding: 6px 8px;
            border-radius: 8px;
        }

        .prox-stat .k {
            display: block;
            font-size: 10px;
            opacity: .6;
            text-transform: uppercase;
        }

        .prox-stat .v {
            font-size: 12px;
            font-weight: 600;
        }

        .proximity-empty {
            opacity: .6;
            font-style: italic;
        }

        /* --- Slice 2 Additions --- */
        .proximity-badge {
            background: var(--accent-2);
            color: #fff;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            margin-left: 8px;
            letter-spacing: .5px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .proximity-badge span {
            font-weight: 600;
        }

        #proximityFilters {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 4px 0 10px;
        }

        #proximityFilters button {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            color: var(--muted);
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            letter-spacing: .4px;
        }

        #proximityFilters button.active {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--glass);
        }

        #proximitySparkline {
            width: 100%;
            height: 45px;
            display: block;
            margin: 2px 0 8px;
        }

        /* Slice 3: Proximity controls and tooltip */
        #proximityControls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        #proximityControls .left,
        #proximityControls .right {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        #proximityControls button {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid var(--border-color);
            background: var(--panel-bg);
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
        }

        #proximityControls button:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        #proximitySparklineTooltip {
            position: fixed;
            display: none;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            z-index: 9999;
            white-space: nowrap;
        }

        .threshold-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 6px;
        }

        .threshold-chips .chip {
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 999px;
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            letter-spacing: .4px;
        }

        .chip-lock {
            border-color: var(--accent-2);
        }

        .chip-strong {
            border-color: var(--accent);
        }

        .chip-moderate {
            border-color: var(--warn);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>

    <script>
        // Fix TWEEN reference for UMD version
        if (typeof TWEEN === 'undefined' && typeof window.TWEEN !== 'undefined') {
            TWEEN = window.TWEEN;
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "d3-delaunay": "https://cdn.skypack.dev/d3-delaunay"
            }
        }
    </script>
</head>

<body>

    <div class="ui-overlay">
        <header>
            <div class="brand">E8 Mind-Crystal <span>// M20 Fluid HUD</span></div>
            <div style="display:flex; align-items:center; gap:16px;">
                <div class="status-tag" id="runTag">OFFLINE</div>
                <button id="themeToggle" class="theme-toggle-btn">Light</button>
            </div>
        </header>

        <aside class="left-panel panel">
            <div class="panel-header">
                <div class="panel-title">System Vitals</div>
            </div>
            <div class="panel-content">
                <div class="weather-box">
                    <div class="row"><span class="label">Weather</span><span class="value" id="wx-mood">-</span></div>
                    <div class="row"><span class="label">Region</span><span class="value" id="wx-region">-</span></div>
                    <div class="row"><span class="label">BH Pressure</span><span class="value"
                            id="wx-pressure">0.00</span></div>
                </div>
                <div style="margin-top: 16px; display:flex; gap:14px; flex-wrap:wrap;">
                    <div class="ring"><canvas width="92" height="92" id="ringPressure"></canvas>
                        <div class="ring-label">Collapse</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringTeacher"></canvas>
                        <div class="ring-label">Teacher</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringExplorer"></canvas>
                        <div class="ring-label">Explorer</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringReward"></canvas>
                        <div class="ring-label">Reward</div>
                    </div>
                </div>

                <div style="margin-top: 16px">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Mood Vectors</div>
                    <div class="weather-box">
                        <div class="row"><span class="label">Intensity</span><progress id="mood-intensity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Entropy</span><progress id="mood-entropy" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Coherence</span><progress id="mood-coherence" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Positivity</span><progress id="mood-positivity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Fluidity</span><progress id="mood-fluidity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Intelligibility</span><progress id="mood-intelligibility"
                                max="1" value="0.5" style="width:160px"></progress></div>
                    </div>
                </div>

                <div style="margin-top: 16px;">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Dialogue</div>
                    <div class="weather-box">
                        <div class="row" style="align-items: flex-start;"><span class="label">Teacher</span><span
                                class="value" id="teacher-question">-</span></div>
                        <div class="row" style="align-items: flex-start; margin-top: 8px;"><span
                                class="label">Explorer</span><span class="value" id="explorer-answer">-</span></div>
                    </div>
                </div>
            </div>
            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Quantum Attention</div>
            </div>
            <div class="panel-content">
                <div style="display:flex; gap:14px; flex-wrap:wrap;">
                    <div class="ring"><canvas width="92" height="92" id="ringPsi"></canvas>
                        <div class="ring-label">Psi Entropy</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringLambda"></canvas>
                        <div class="ring-label">Lambda (L<->V)</div>
                    </div>
                </div>
                <div class="weather-box" style="margin-top:10px;">
                    <div class="row"><span class="label">Psi Entropy</span><span class="value" id="val-psi">N/A</span>
                    </div>
                    <div class="row"><span class="label">Lambda (Laplacian vs Potential)</span><span class="value"
                            id="val-lam">N/A</span></div>
                    <div class="row"><span class="label">Disagreement</span><span class="value"
                            id="val-disagreement">N/A</span></div>
                    <div class="row" style="margin-top: 6px; opacity: 0.6;"><span class="label"
                            style="font-style: italic;">Engine Params</span><span class="value"></span></div>
                    <div class="row"><span class="label">Q. Time Step (dt)</span><span class="value"
                            id="val-q-dt">N/A</span></div>
                    <div class="row"><span class="label">Q. Hamiltonian (gamma)</span><span class="value"
                            id="val-q-gamma">N/A</span></div>
                    <div class="row"><span class="label">Q. Dephasing</span><span class="value"
                            id="val-q-dephase">N/A</span></div>
                </div>
            </div>
            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Goals Field</div>
            </div>
            <div class="panel-content" id="goalsList"></div>
        </aside>

        <div id="tetraPanel" class="panel">
            <div class="panel-header">
                <div class="panel-title">E8 Lattice Projection</div>
            </div>
            <div class="panel-content no-padding">
                <canvas id="tetraCanvas"></canvas>
            </div>
        </div>

        <aside class="right-panel panel">
            <div class="tab-header">
                <button class="tab-btn active" data-tab="dynamics">Core Dynamics</button>
                <button class="tab-btn" data-tab="insights">System Insights</button>
            </div>

            <div id="tab-dynamics" class="tab-content active">
                <div class="panel-header">
                    <div class="panel-title">Encoder</div>
                    <button class="collapse-btn" data-collapse="encoder">-</button>
                </div>
                <div class="panel-content" data-section="encoder" style="font-size:12px; flex-grow: 0; flex-shrink: 0;">
                    <div class="weather-box">
                        <div class="row"><span class="label">Autoencoder</span><span class="value"
                                id="encoder-status">Untrained</span></div>
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Discovery Metrics</div>
                    <button class="collapse-btn" data-collapse="discovery">-</button>
                </div>
                <div class="panel-content" data-section="discovery">
                    <div class="weather-box">
                        <div class="row"><span class="label">Novelty</span><span class="value"
                                id="val-novelty">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-novelty" style="margin-top:6px;"></div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Compression Delta</span><span class="value"
                                id="val-compression">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-compression" style="margin-top:6px;"></div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Disagreement</span><span class="value"
                                id="val-discovery-disagreement">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-disagreement" style="margin-top:6px;"></div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">🕳️ BH Console</div>
                    <button class="collapse-btn" data-collapse="bh-console">-</button>
                </div>
                <div class="panel-content" data-section="bh-console">
                    <div class="weather-box">
                        <pre id="bhPanel" class="mono"
                            style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.3; color: var(--fg); margin: 0; white-space: pre;">Q(t)      : —
sQ_global : —
t′        : —
Phase     : —
Scale     : —
Target    : —
VAE β     : —</pre>
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Shell Dynamics</div>
                    <button class="collapse-btn" data-collapse="shell-dynamics">-</button>
                </div>
                <div class="panel-content" data-section="shell-dynamics">
                    <div class="weather-box">
                        <div class="row"><span class="label">Global Tension</span><span class="value"
                                id="global-tension">0.000</span></div>
                        <div class="row"><span class="label">KDTree Failures</span><span class="value"
                                id="val-kdtree">N/A</span></div>
                    </div>
                    <div id="shellDynamicsGrid" style="margin-top: 12px;">
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Fluid Consciousness</div>
                    <button class="collapse-btn" data-collapse="fluid">-</button>
                </div>
                <div class="panel-content" data-section="fluid">
                    <div class="weather-box">
                        <div class="row"><span class="label">Fluid Steps</span><span class="value"
                                id="m20-fluid-steps">0</span></div>
                        <div class="row"><span class="label">Valence Updates</span><span class="value"
                                id="m20-valence-updates">0</span></div>
                        <div class="row"><span class="label">Energy Explorations</span><span class="value"
                                id="m20-energy-explorations">0</span></div>
                        <div class="row"><span class="label">Topology Adaptations</span><span class="value"
                                id="m20-topology-adaptations">0</span></div>
                        <div class="row"><span class="label">Recursive Implementations</span><span class="value"
                                id="m20-recursive-implementations">0</span></div>
                    </div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Flow Rate</span><span class="value"
                                id="m20-flow-rate">0.000</span></div>
                        <div class="row"><span class="label">Spacetime Curvature</span><span class="value"
                                id="m20-curvature">0.000</span></div>
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Mantle Metrics</div>
                    <button class="collapse-btn" data-collapse="mantle">-</button>
                </div>
                <div class="panel-content" data-section="mantle">
                    <div class="weather-box">
                        <div class="row"><span class="label">Flux</span><span class="value"
                                id="mantle-flux">1.000</span></div>
                        <div class="row"><span class="label">Curvature</span><span class="value"
                                id="mantle-curvature">6.000</span></div>
                        <div class="row"><span class="label">Flow</span><span class="value"
                                id="mantle-flow">1.500</span></div>
                        <div class="row"><span class="label">Tension</span><span class="value"
                                id="mantle-tension">0.700</span></div>
                    </div>
                </div>
            </div>

            <div id="tab-insights" class="tab-content">
                <div class="panel-header">
                    <div class="panel-title">Ingestion Feed</div>
                    <button class="collapse-btn" data-collapse="ingestion">-</button>
                </div>
                <div class="panel-content" data-section="ingestion" id="ingestionFeed">...</div>
                <!-- Slice 2: Adaptive Proximity Panel (enhanced) -->
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title" style="display:flex; align-items:center; gap:6px;">Adaptive Proximity <div
                            id="proximityBadge" class="proximity-badge" style="display:none;">LOCK <span
                                id="proximityBadgeCount">0</span></div>
                    </div>
                    <button class="collapse-btn" data-collapse="proximity">-</button>
                </div>
                <div class="panel-content" data-section="proximity" id="proximityPanel">
                    <div id="proximitySummary"></div>
                    <div id="proximityControls">
                        <div class="left">
                            <span class="chip chip-lock" id="proxCountLock">LOCK 0</span>
                            <span class="chip chip-strong" id="proxCountStrong">STRONG 0</span>
                            <span class="chip chip-moderate" id="proxCountModerate">MODERATE 0</span>
                        </div>
                        <div class="right">
                            <button id="proxResetFilters">Reset Filters</button>
                            <button id="proxExportCsv">Export CSV</button>
                        </div>
                    </div>
                    <div class="threshold-chips" id="proximityThresholdChips"></div>
                    <canvas id="proximitySparkline"></canvas>
                    <div id="proximityFilters"></div>
                    <div id="proximityEventsList" class="weather-box"
                        style="background:transparent; border:none; padding:0;"></div>
                </div>
                <div id="proximitySparklineTooltip"></div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Validation Lab</div>
                    <button class="collapse-btn" data-collapse="validation">-</button>
                </div>
                <div class="panel-content" data-section="validation" id="validationLab">...</div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Insight Holocron</div>
                    <button class="collapse-btn" data-collapse="holocron">-</button>
                </div>
                <div class="panel-content" data-section="holocron" id="insightHolocron">...</div>
            </div>
        </aside>

        <footer class="footer">
            <div id="status">Initializing...</div>
        </footer>
    </div>

    <script type="module">
        /*
         * Patch Rev C (UI Consolidation)
         * - Combined "Shell Tensions" and "Shell Stats" into a single "Shell Dynamics" panel.
         * - Updated JS to populate the new unified panel structure.
         */
        // --- Non-blocking processing of insight bursts ---
        const insightsQueue = [];
        let insightsIdleHandle = null;

        // Global utility: hexToRgba (hoisted once)
        function hexToRgba(hex, a = 1) {
            try {
                if (!hex) return `rgba(255,255,255,${a})`;
                hex = String(hex).trim();
                if (hex.startsWith('var(')) {
                    const m = /var\((--[^)]+)\)/.exec(hex);
                    if (m) {
                        const styles = getComputedStyle(document.documentElement);
                        const resolved = styles.getPropertyValue(m[1]).trim();
                        if (resolved) hex = resolved;
                    }
                }
                if (!hex.startsWith('#')) return `rgba(255,255,255,${a})`;
                const raw = hex.slice(1);
                let r, g, b;
                if (raw.length === 3 || raw.length === 4) {
                    r = parseInt(raw[0] + raw[0], 16);
                    g = parseInt(raw[1] + raw[1], 16);
                    b = parseInt(raw[2] + raw[2], 16);
                } else if (raw.length === 6 || raw.length === 8) {
                    r = parseInt(raw.slice(0, 2), 16);
                    g = parseInt(raw.slice(2, 4), 16);
                    b = parseInt(raw.slice(4, 6), 16);
                } else {
                    return `rgba(255,255,255,${a})`;
                }
                const alpha = Math.max(0, Math.min(1, a));
                return `rgba(${r},${g},${b},${alpha})`;
            } catch (_) {
                return `rgba(255,255,255,${a})`;
            }
        }

        // Readiness queue for early tetra insertions arriving before tetra system init
        const earlyTetraQueue = [];
        function enqueueEarlyTetra(data) {
            earlyTetraQueue.push(data);
        }
        function flushEarlyTetras() {
            // Explicit, defensive readiness check for tetra system before applying queued updates.
            const meshes = Array.isArray(window.tetraMeshes) ? window.tetraMeshes : [];
            const meshesAvailable = meshes.length > 0 && meshes.every(m => m && m.isInstancedMesh === true || m instanceof THREE.InstancedMesh);
            // require both initialization flags and at least one instanced mesh available
            if (!tetraInitialized || !tetraMeshesReady || !meshesAvailable) return;

            if (earlyTetraQueue.length) console.log(`[tetra] Flushing ${earlyTetraQueue.length} queued tetra updates`);
            while (earlyTetraQueue.length) {
                const d = earlyTetraQueue.shift();
                try { upsertInsightTetra(d); } catch (e) { console.warn('Early tetra flush failed', e); }
            }
        }

        function enqueueInsights(list) {
            for (const item of list) insightsQueue.push(item);
            pumpInsights();
        }

        function pumpInsights() {
            if (insightsIdleHandle) return;

            const consume = (deadline) => {
                let count = 0;
                const MAX_PER_SLICE = 8;

                while (insightsQueue.length && count < MAX_PER_SLICE && (!deadline || deadline.timeRemaining() > 5)) {
                    upsertInsightTetra(insightsQueue.shift());
                    count++;
                }

                insightsIdleHandle = null;

                if (insightsQueue.length) {
                    if ('requestIdleCallback' in window) {
                        insightsIdleHandle = requestIdleCallback(consume, {
                            timeout: 33
                        });
                    } else {
                        insightsIdleHandle = setTimeout(() => consume(), 0);
                    }
                }
            };

            if ('requestIdleCallback' in window) {
                insightsIdleHandle = requestIdleCallback(consume, {
                    timeout: 33
                });
            } else {
                insightsIdleHandle = setTimeout(() => consume(), 0);
            }
        }

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Delaunay } from 'd3-delaunay';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';

        // Global variables initialization
        let __sseAttempts = 0;
        let __frameCounter = 0;
        const TETRA_LOCAL_SIZE = 0.8;

        // Global declarations for fluid visualizer and tetra rotation state
        let fluidVisualizer = null;
        let tetraRotationState = { current: new Map() };

        // Connection management globals
        let currentWebSocket = null;
        let currentEventSource = null;
        let currentPollInterval = null;
        let currentSyncInterval = null;
        let isConnecting = false; // Prevent multiple concurrent connection attempts
        let animationFrameId = null;

        // Connection cleanup function
        function cleanupExistingConnections() {
            console.log('[cleanup] Cleaning up existing connections and intervals');

            // Close WebSocket
            if (currentWebSocket) {
                try {
                    currentWebSocket.close();
                    console.log('[cleanup] Closed existing WebSocket');
                } catch (e) {
                    console.warn('[cleanup] Error closing WebSocket:', e);
                }
                currentWebSocket = null;
            }

            // Close EventSource
            if (currentEventSource) {
                try {
                    currentEventSource.close();
                    console.log('[cleanup] Closed existing EventSource');
                } catch (e) {
                    console.warn('[cleanup] Error closing EventSource:', e);
                }
                currentEventSource = null;
            }

            // Clear polling interval
            if (currentPollInterval) {
                clearInterval(currentPollInterval);
                currentPollInterval = null;
                console.log('[cleanup] Cleared polling interval');
            }

            // Clear sync interval
            if (currentSyncInterval) {
                clearInterval(currentSyncInterval);
                currentSyncInterval = null;
                console.log('[cleanup] Cleared sync interval');
            }

            // Clear any window-stored intervals
            if (window.currentPollInterval) {
                clearInterval(window.currentPollInterval);
                window.currentPollInterval = null;
            }
        }

        // Helper function to check TWEEN availability
        function createTween(object) {
            if (typeof TWEEN !== 'undefined' && TWEEN.Tween) {
                return new TWEEN.Tween(object);
            }
            console.warn('TWEEN library not available, animation will be skipped');
            // Return a mock TWEEN object that supports chaining
            const mockTween = {
                to: () => mockTween,
                easing: () => mockTween,
                onUpdate: () => mockTween,
                onComplete: () => mockTween,
                start: () => mockTween,
                stop: () => mockTween
            };
            return mockTween;
        }

        const API_BASE_URL = new URLSearchParams(location.search).get('api') || (location.origin && location.origin.startsWith('http') ? location.origin : 'http://localhost:7870');
        const resolveApi = (relativePath) => {
            const normalizedPath = String(relativePath || '').replace(/^\/+/, '');
            try {
                const base = API_BASE_URL.endsWith('/') ? API_BASE_URL : `${API_BASE_URL}/`;
                return new URL(normalizedPath, base).toString();
            } catch (error) {
                const base = API_BASE_URL.replace(/\/+$/, '');
                return `${base}/${normalizedPath}`;
            }
        };
        const buildWsUrl = (relativePath) => {
            const url = new URL(resolveApi(relativePath));
            url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
            return url.toString();
        };
        const API = {
            telemetryStream: resolveApi('api/telemetry/stream'),
            telemetrySnapshot: resolveApi('api/telemetry'),
        };
        const TELEMETRY_CANDIDATES = Array.from(new Set([
            API.telemetryStream,
            API.telemetrySnapshot,
            resolveApi('telemetry/stream'),
            resolveApi('telemetry'),
        ]));
        let telemetryTry = 0;

        const TEACHER_CYCLE_LENGTH = 25;

        const state = {
            rotors: {
                '3': { angle: 0, target: 0, vel: 0 },
                '5': { angle: 0, target: 0, vel: 0 },
                '8': { angle: 0, target: 0, vel: 0 }
            },
            shellSparklines: new Map(),
            noveltySeries: [],
            compressionSeries: [],
            disagreementSeries: [],
            smooth: {
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                moodPositivity: 0.5,
                moodFluidity: 0.5,
                moodIntelligibility: 0.5,
                wxPressure: 0,
                globalTension: 0,
                psi: 0,
                lam: 0,
                novelty: 0,
                compression: 0,
                disagreement: 0
            },
            targets: {
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                moodPositivity: 0.5,
                moodFluidity: 0.5,
                moodIntelligibility: 0.5,
                wxPressure: 0,
                globalTension: 0,
                psi: 0,
                lam: 0,
                novelty: 0,
                compression: 0,
                disagreement: 0
            },
            proximity: {
                events: [],
                stats: null,
                lastTier: null,
                lastEvent: null,
                activeTiers: new Set(['lock', 'strong', 'moderate', 'weak']),
                distanceSeries: [],
                lockCountWindow: 0,
                maxSeries: 180,
                tierCounts: { lock: 0, strong: 0, moderate: 0, weak: 0 }
            },
            tetraUpdateIndex: 0,
            tetraMaxPerFrame: 200
        };
        // Initialize rotors with immediate base spin for visual feedback
        Object.values(state.rotors).forEach((r, i) => {
            r.hadTarget = false;
            r.baseSpin = [0.008, 0.012, 0.018][i]; // Immediate base spin
        });
        console.log('[rotor] Initialized rotors with base spin:', state.rotors);

        let clock = new THREE.Clock();
        const DOM = {
            moodIntensity: document.getElementById('mood-intensity'),
            moodEntropy: document.getElementById('mood-entropy'),
            moodCoherence: document.getElementById('mood-coherence'),
            moodPositivity: document.getElementById('mood-positivity'),
            moodFluidity: document.getElementById('mood-fluidity'),
            moodIntelligibility: document.getElementById('mood-intelligibility'),
            encoderStatus: document.getElementById('encoder-status'),
            globalTension: document.getElementById('global-tension'),
            m20FluidSteps: document.getElementById('m20-fluid-steps'),
            m20ValenceUpdates: document.getElementById('m20-valence-updates'),
            m20EnergyExplorations: document.getElementById('m20-energy-explorations'),
            m20TopologyAdaptations: document.getElementById('m20-topology-adaptations'),
            m20RecursiveImplementations: document.getElementById('m20-recursive-implementations'),
            m20FlowRate: document.getElementById('m20-flow-rate'),
            m20Curvature: document.getElementById('m20-curvature'),
            ringReward: document.getElementById('ringReward'),
            runTag: document.getElementById('runTag'),
            status: document.getElementById('status'),
            themeToggle: document.getElementById('themeToggle'),
            tetraCanvas: document.getElementById('tetraCanvas'),
            wxMood: document.getElementById('wx-mood'),
            wxRegion: document.getElementById('wx-region'),
            wxPressure: document.getElementById('wx-pressure'),
            ringPressure: document.getElementById('ringPressure'),
            ringTeacher: document.getElementById('ringTeacher'),
            ringExplorer: document.getElementById('ringExplorer'),
            goalsList: document.getElementById('goalsList'),
            teacherQuestion: document.getElementById('teacher-question'),
            explorerAnswer: document.getElementById('explorer-answer'),
            ingestionFeed: document.getElementById('ingestionFeed'),
            validationLab: document.getElementById('validationLab'),
            insightHolocron: document.getElementById('insightHolocron'),
            ringPsi: document.getElementById('ringPsi'),
            ringLambda: document.getElementById('ringLambda'),
            valPsi: document.getElementById('val-psi'),
            valLam: document.getElementById('val-lam'),
            valQADisagreement: document.getElementById('val-disagreement'),
            valDisagreement: document.getElementById('val-discovery-disagreement'),
            valNovelty: document.getElementById('val-novelty'),
            valCompression: document.getElementById('val-compression'),
            sparkNovelty: document.getElementById('spark-novelty'),
            sparkCompression: document.getElementById('spark-compression'),
            sparkDisagreement: document.getElementById('spark-disagreement'),
            shellDynamicsGrid: document.getElementById('shellDynamicsGrid'), // New unified container
            valKDTree: document.getElementById('val-kdtree'),
            valQDt: document.getElementById('val-q-dt'),
            valQGamma: document.getElementById('val-q-gamma'),
            valQDephase: document.getElementById('val-q-dephase'),
            proximityPanel: document.getElementById('proximityPanel'),
            proximitySummary: document.getElementById('proximitySummary'),
            proximityEventsList: document.getElementById('proximityEventsList'),
            proximityBadge: document.getElementById('proximityBadge'),
            proximityBadgeCount: document.getElementById('proximityBadgeCount'),
            proximityFilters: document.getElementById('proximityFilters'),
            proximitySparkline: document.getElementById('proximitySparkline'),
            proximityThresholdChips: document.getElementById('proximityThresholdChips'),
            proxCountLock: document.getElementById('proxCountLock'),
            proxCountStrong: document.getElementById('proxCountStrong'),
            proxCountModerate: document.getElementById('proxCountModerate'),
            proxResetFilters: document.getElementById('proxResetFilters'),
            proxExportCsv: document.getElementById('proxExportCsv'),
            proximitySparklineTooltip: document.getElementById('proximitySparklineTooltip'),
            mantleFlux: document.getElementById('mantle-flux'),
            mantleCurvature: document.getElementById('mantle-curvature'),
            mantleFlow: document.getElementById('mantle-flow'),
            mantleTension: document.getElementById('mantle-tension'),
        };

        class FluidLatticeVisualizer {
            constructor(scene, camera, renderer) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.root = new THREE.Group();
                this.root.name = 'FluidLatticeVisualizer';
                this.scene.add(this.root);
                this.pointGroup = new THREE.Group();
                this.edgeGroup = new THREE.Group();
                this.streamlineGroup = new THREE.Group();
                this.root.add(this.pointGroup);
                this.root.add(this.edgeGroup);
                this.root.add(this.streamlineGroup);
                this.latticePoints = [];
                this.baseLatticePoints = [];
                this.pointTargets = [];
                this.pointDisplacements = [];
                this.pointVelocities = [];
                this.edgeSegments = [];
                this.neighborCache = [];
                this.blueprintIndexById = new Map();
                this.blueprintMeta = [];
                this.pointGeometry = null;
                this.pointPositionsAttr = null;
                this.pointColorsAttr = null;
                this.edgeGeometry = null;
                this.edgePositionsAttr = null;
                this.deformationNeedsUpdate = false;
                this.pendingFlowRefreshAt = null;
                this.maxDisplacement = 4.0;
                this.deformationSettings = {
                    stiffness: 6.5,
                    damping: 2.5,
                    targetFade: 0.6
                };
                this.tmpVec = new THREE.Vector3();
                this.tmpVec2 = new THREE.Vector3();
                this.flowParticles = [];
                this.projectionMatrix = this.createProjectionMatrix();
                this.flowSpeed = 1.4;
                this.flowSpeedTarget = this.flowSpeed;
                this.rotationSpeed = 0.6;
                this.rotationSpeedTarget = this.rotationSpeed;
                this.streamlineColor = 0x7aa2ff;
                this.latticeColor = 0x4a90e2;
                this.time = 0;
                this.lastMetrics = {};
                this.refreshTheme();
            }

            refreshTheme() {
                try {
                    const styles = getComputedStyle(document.documentElement);
                    const glow = styles.getPropertyValue('--glow').trim();
                    const accent = styles.getPropertyValue('--accent').trim();
                    if (glow) {
                        this.streamlineColor = new THREE.Color(glow).getHex();
                    }
                    if (accent) {
                        const lattice = new THREE.Color(accent);
                        this.latticeColor = lattice.offsetHSL(0, -0.08, 0).getHex();
                    }
                    this.recolorMaterials();
                } catch (err) {
                    console.debug('FluidVisualizer theme refresh failed', err);
                }
            }

            createProjectionMatrix() {
                const matrix = [];
                for (let i = 0; i < 8; i++) {
                    const row = [];
                    for (let j = 0; j < 3; j++) {
                        const u1 = Math.random() || 1e-6;
                        const u2 = Math.random();
                        row.push(Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.35);
                    }
                    matrix.push(row);
                }
                return matrix;
            }

            projectTo3D(vec) {
                const out = [0, 0, 0];
                for (let i = 0; i < Math.min(vec.length, this.projectionMatrix.length); i++) {
                    out[0] += vec[i] * this.projectionMatrix[i][0];
                    out[1] += vec[i] * this.projectionMatrix[i][1];
                    out[2] += vec[i] * this.projectionMatrix[i][2];
                }
                return out;
            }

            generateFallbackRoots() {
                const roots = [];
                for (let i = 0; i < 8; i++) {
                    for (let j = i + 1; j < 8; j++) {
                        for (const [a, b] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                            const vec = new Array(8).fill(0);
                            vec[i] = a;
                            vec[j] = b;
                            roots.push(vec);
                        }
                    }
                }
                return roots;
            }

            normalizePoints(points) {
                if (!points.length) return;
                const center = new THREE.Vector3();
                points.forEach(p => center.add(p));
                center.divideScalar(points.length || 1);
                let radius = 0;
                points.forEach(p => { radius = Math.max(radius, p.distanceTo(center)); });
                const scale = radius > 0 ? 8 / radius : 1;
                points.forEach(p => p.sub(center).multiplyScalar(scale));
            }

            setBlueprintLattice(points) {
                if (!Array.isArray(points) || !points.length) return;

                // Normalize input into vector list while capturing optional metadata
                const vectorList = [];
                this.blueprintIndexById.clear();
                this.blueprintMeta = [];

                const makeVector = (p) => {
                    if (!p) return new THREE.Vector3();
                    if (p.isVector3 || p.clone) return p.clone();
                    if (p.position && (p.position.isVector3 || p.position.clone)) return p.position.clone();
                    if (p.render && (p.render.isVector3 || p.render.clone)) return p.render.clone();
                    if (Array.isArray(p)) {
                        return new THREE.Vector3(Number(p[0]) || 0, Number(p[1]) || 0, Number(p[2]) || 0);
                    }
                    const x = Number(p.render_x ?? p.x ?? p[0] ?? 0) || 0;
                    const y = Number(p.render_y ?? p.y ?? p[1] ?? 0) || 0;
                    const z = Number(p.render_z ?? p.z ?? p[2] ?? 0) || 0;
                    return new THREE.Vector3(x, y, z);
                };

                points.forEach((entry, idx) => {
                    const vec = makeVector(entry);
                    vectorList.push(vec);
                    const blueprintId = entry && Object.prototype.hasOwnProperty.call(entry, 'id') ? entry.id : idx;
                    this.blueprintIndexById.set(Number.isFinite(blueprintId) ? Number(blueprintId) : String(blueprintId), idx);
                    this.blueprintMeta.push({ id: blueprintId, vector: vec.clone() });
                });

                // Normalize and initialize deformation state
                this.latticePoints = vectorList.map(v => v.clone());
                this.normalizePoints(this.latticePoints);
                this.baseLatticePoints = this.latticePoints.map(v => v.clone());
                this.pointTargets = this.latticePoints.map(() => new THREE.Vector3());
                this.pointDisplacements = this.latticePoints.map(() => new THREE.Vector3());
                this.pointVelocities = this.latticePoints.map(() => new THREE.Vector3());

                this.edgeSegments = this.computeEdgeSegments();
                this.neighborCache = this.buildNeighborCache(this.edgeSegments);
                this.deformationNeedsUpdate = false;

                this.buildLatticeGeometry();
                this.initializeFlowField(true);
            }

            initializeFluidVisualization() {
                if (!this.latticePoints.length) {
                    try {
                        const roots = typeof generateE8Roots === 'function' ? generateE8Roots() : this.generateFallbackRoots();
                        this.latticePoints = roots.map(root => {
                            const projected = this.projectTo3D(root);
                            return new THREE.Vector3(projected[0], projected[1], projected[2]);
                        });
                    } catch (err) {
                        console.warn('FluidVisualizer: E8 lattice generation failed', err);
                        this.latticePoints = [];
                    }
                }
                if (!this.latticePoints.length) return;
                const clones = this.latticePoints.map(p => p.clone ? p.clone() : new THREE.Vector3(p[0] || 0, p[1] || 0, p[2] || 0));
                this.setBlueprintLattice(clones);
            }

            buildLatticeGeometry() {
                this.clearGroup(this.pointGroup);
                this.clearGroup(this.edgeGroup);
                this.pointGeometry = null;
                this.pointPositionsAttr = null;
                this.pointColorsAttr = null;
                this.edgeGeometry = null;
                this.edgePositionsAttr = null;
                if (!this.latticePoints.length) return;

                // Create colorful lattice points based on metrics
                const colors = new Float32Array(this.latticePoints.length * 3);
                const positions = new Float32Array(this.latticePoints.length * 3);

                this.latticePoints.forEach((p, i) => {
                    p.toArray(positions, i * 3);

                    // Generate bright colors based on lattice point position and metrics
                    const color = this.getLatticeNodeColor(p, i);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                });

                const pointGeo = new THREE.BufferGeometry();
                const positionAttr = new THREE.BufferAttribute(positions, 3);
                const colorAttr = new THREE.BufferAttribute(colors, 3);
                pointGeo.setAttribute('position', positionAttr);
                pointGeo.setAttribute('color', colorAttr);

                const pointMat = new THREE.PointsMaterial({
                    size: 0.08,  // Slightly larger for better visibility
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.9,  // More opaque for brighter appearance
                    vertexColors: true  // Enable per-vertex colors
                });
                this.pointGroup.add(new THREE.Points(pointGeo, pointMat));
                this.pointGeometry = pointGeo;
                this.pointPositionsAttr = positionAttr;
                this.pointColorsAttr = colorAttr;

                if (!Array.isArray(this.edgeSegments) || !this.edgeSegments.length) {
                    this.edgeSegments = this.computeEdgeSegments();
                    this.neighborCache = this.buildNeighborCache(this.edgeSegments);
                }

                if (this.edgeSegments.length) {
                    const edgePositions = new Float32Array(this.edgeSegments.length * 6);
                    this.edgeSegments.forEach(([aIndex, bIndex], segmentIdx) => {
                        const a = this.latticePoints[aIndex];
                        const b = this.latticePoints[bIndex];
                        const offset = segmentIdx * 6;
                        edgePositions[offset] = a.x;
                        edgePositions[offset + 1] = a.y;
                        edgePositions[offset + 2] = a.z;
                        edgePositions[offset + 3] = b.x;
                        edgePositions[offset + 4] = b.y;
                        edgePositions[offset + 5] = b.z;
                    });

                    const edgeGeo = new THREE.BufferGeometry();
                    const edgeAttr = new THREE.BufferAttribute(edgePositions, 3);
                    edgeGeo.setAttribute('position', edgeAttr);
                    const edgeMat = new THREE.LineBasicMaterial({
                        color: this.latticeColor,
                        transparent: true,
                        opacity: 0.15
                    });
                    this.edgeGroup.add(new THREE.LineSegments(edgeGeo, edgeMat));
                    this.edgeGeometry = edgeGeo;
                    this.edgePositionsAttr = edgeAttr;
                }
            }

            getLatticeNodeColor(position, index) {
                // Use metrics to determine color scheme
                const metrics = this.lastMetrics || {};

                // Extract key metrics
                const flowRate = metrics.consciousness_flow_rate || 0;
                const curvature = metrics.spacetime_curvature || 0;
                const fluidSteps = metrics.fluid_steps || 0;
                const valenceUpdates = metrics.valence_updates || 0;
                const energyExplorations = metrics.energy_explorations || 0;

                // Normalize position coordinates for color calculation
                const normalizedPos = {
                    x: (position.x + 10) / 20,  // Assume lattice is roughly -10 to +10
                    y: (position.y + 10) / 20,
                    z: (position.z + 10) / 20
                };

                // Create bright color palette based on different metrics
                let r, g, b;

                // Cycle through different color schemes based on index
                const colorScheme = index % 6;

                switch (colorScheme) {
                    case 0: // Flow-based (Cyan to Magenta)
                        r = 0.2 + Math.abs(Math.sin(normalizedPos.x * Math.PI + flowRate * 0.1)) * 0.8;
                        g = 0.4 + Math.abs(Math.cos(normalizedPos.y * Math.PI + this.time * 0.5)) * 0.6;
                        b = 0.8 + Math.abs(Math.sin(normalizedPos.z * Math.PI + curvature * 0.05)) * 0.2;
                        break;

                    case 1: // Energy-based (Orange to Yellow)
                        r = 0.9 + Math.abs(Math.sin(normalizedPos.x * Math.PI * 2 + energyExplorations * 0.01)) * 0.1;
                        g = 0.5 + Math.abs(Math.cos(normalizedPos.y * Math.PI + this.time * 0.3)) * 0.5;
                        b = 0.1 + Math.abs(Math.sin(normalizedPos.z * Math.PI + flowRate * 0.1)) * 0.3;
                        break;

                    case 2: // Valence-based (Green to Lime)
                        r = 0.1 + Math.abs(Math.sin(normalizedPos.x * Math.PI + valenceUpdates * 0.01)) * 0.4;
                        g = 0.6 + Math.abs(Math.cos(normalizedPos.y * Math.PI * 1.5 + this.time * 0.4)) * 0.4;
                        b = 0.2 + Math.abs(Math.sin(normalizedPos.z * Math.PI + curvature * 0.1)) * 0.3;
                        break;

                    case 3: // Curvature-based (Purple to Pink)
                        r = 0.6 + Math.abs(Math.sin(normalizedPos.x * Math.PI + curvature * 0.1)) * 0.4;
                        g = 0.2 + Math.abs(Math.cos(normalizedPos.y * Math.PI + this.time * 0.6)) * 0.3;
                        b = 0.7 + Math.abs(Math.sin(normalizedPos.z * Math.PI * 2 + fluidSteps * 0.01)) * 0.3;
                        break;

                    case 4: // Fluid-based (Blue to Turquoise)
                        r = 0.1 + Math.abs(Math.sin(normalizedPos.x * Math.PI + this.time * 0.2)) * 0.4;
                        g = 0.5 + Math.abs(Math.cos(normalizedPos.y * Math.PI + fluidSteps * 0.01)) * 0.5;
                        b = 0.8 + Math.abs(Math.sin(normalizedPos.z * Math.PI + flowRate * 0.1)) * 0.2;
                        break;

                    default: // Mixed metrics (Rainbow effect)
                        const mixedMetric = (flowRate + curvature + fluidSteps * 0.01 + valenceUpdates * 0.01) * 0.1;
                        r = 0.5 + Math.abs(Math.sin(normalizedPos.x * Math.PI * 3 + mixedMetric)) * 0.5;
                        g = 0.5 + Math.abs(Math.cos(normalizedPos.y * Math.PI * 2 + this.time * 0.5)) * 0.5;
                        b = 0.5 + Math.abs(Math.sin(normalizedPos.z * Math.PI * 4 + mixedMetric)) * 0.5;
                        break;
                }

                // Ensure minimum brightness for visibility
                r = Math.max(0.3, Math.min(1.0, r));
                g = Math.max(0.3, Math.min(1.0, g));
                b = Math.max(0.3, Math.min(1.0, b));

                return { r, g, b };
            }

            computeEdgePositions() {
                if (!this.latticePoints.length) return [];
                const segments = Array.isArray(this.edgeSegments) && this.edgeSegments.length ? this.edgeSegments : this.computeEdgeSegments();
                const data = new Float32Array(segments.length * 6);
                segments.forEach(([aIndex, bIndex], idx) => {
                    const a = this.latticePoints[aIndex];
                    const b = this.latticePoints[bIndex];
                    const offset = idx * 6;
                    data[offset] = a.x;
                    data[offset + 1] = a.y;
                    data[offset + 2] = a.z;
                    data[offset + 3] = b.x;
                    data[offset + 4] = b.y;
                    data[offset + 5] = b.z;
                });
                return data;
            }

            computeEdgeSegments() {
                if (!this.latticePoints.length) return [];
                const seen = new Set();
                const segments = [];
                const maxNeighbors = Math.min(6, this.latticePoints.length - 1);
                for (let i = 0; i < this.latticePoints.length; i++) {
                    const neighbors = this.findNearestIndices(i, maxNeighbors);
                    for (const j of neighbors) {
                        const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                        if (seen.has(key)) continue;
                        seen.add(key);
                        segments.push([i, j]);
                    }
                }
                return segments;
            }

            buildNeighborCache(segments) {
                const length = this.latticePoints.length;
                const cache = Array.from({ length }, () => []);
                if (!Array.isArray(segments) || !segments.length) return cache;
                segments.forEach(([a, b]) => {
                    if (typeof a !== 'number' || typeof b !== 'number') return;
                    const baseA = this.baseLatticePoints[a] || this.latticePoints[a];
                    const baseB = this.baseLatticePoints[b] || this.latticePoints[b];
                    const dist = baseA && baseB ? baseA.distanceTo(baseB) : this.latticePoints[a].distanceTo(this.latticePoints[b]);
                    cache[a].push({ index: b, dist });
                    cache[b].push({ index: a, dist });
                });
                return cache;
            }

            updateGeometryBuffers() {
                if (this.pointPositionsAttr) {
                    const posArray = this.pointPositionsAttr.array;
                    this.latticePoints.forEach((p, i) => p.toArray(posArray, i * 3));
                    this.pointPositionsAttr.needsUpdate = true;
                }
                if (this.edgePositionsAttr && Array.isArray(this.edgeSegments) && this.edgeSegments.length) {
                    const edgeArray = this.edgePositionsAttr.array;
                    this.edgeSegments.forEach(([aIndex, bIndex], idx) => {
                        const a = this.latticePoints[aIndex];
                        const b = this.latticePoints[bIndex];
                        const offset = idx * 6;
                        edgeArray[offset] = a.x;
                        edgeArray[offset + 1] = a.y;
                        edgeArray[offset + 2] = a.z;
                        edgeArray[offset + 3] = b.x;
                        edgeArray[offset + 4] = b.y;
                        edgeArray[offset + 5] = b.z;
                    });
                    this.edgePositionsAttr.needsUpdate = true;
                }
            }

            injectNeighborRipple(index, offset, weight = 1.0) {
                if (!Array.isArray(this.neighborCache) || !this.neighborCache.length) return;
                const neighbors = this.neighborCache[index];
                if (!neighbors || !neighbors.length) return;
                const base = this.baseLatticePoints[index] || this.latticePoints[index];
                neighbors.forEach(neighbor => {
                    const neighborIndex = neighbor.index ?? neighbor;
                    if (typeof neighborIndex !== 'number') return;
                    const target = this.pointTargets[neighborIndex];
                    if (!target) return;
                    const neighborBase = this.baseLatticePoints[neighborIndex] || this.latticePoints[neighborIndex];
                    const dist = neighbor.dist ?? (base && neighborBase ? base.distanceTo(neighborBase) : 1.0);
                    const falloff = Math.exp(-Math.max(dist, 0.05) * 0.7) * (0.5 + 0.5 * weight);
                    target.addScaledVector(offset, falloff);
                    if (target.lengthSq() > this.maxDisplacement * this.maxDisplacement) {
                        target.setLength(this.maxDisplacement);
                    }
                });
            }

            applyMemoryField(memoryNodes = [], context = {}) {
                if (!Array.isArray(memoryNodes) || !memoryNodes.length) return;
                if (!this.latticePoints.length) return;

                let applied = false;
                const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

                memoryNodes.forEach(node => {
                    if (!node) return;
                    const blueprintIdRaw = node.blueprint_location_id ?? node.blueprint_location ?? node.blueprint_index ?? node.blueprint_slot;
                    if (blueprintIdRaw === undefined || blueprintIdRaw === null) return;
                    const numericId = Number(blueprintIdRaw);
                    const mapKey = this.blueprintIndexById.has(numericId) ? numericId : String(blueprintIdRaw);
                    const latticeIndex = this.blueprintIndexById.get(mapKey);
                    if (latticeIndex === undefined) return;

                    const coords = safeCoords3D(node);
                    this.tmpVec.set(
                        Number(coords?.[0] ?? 0),
                        Number(coords?.[1] ?? 0),
                        Number(coords?.[2] ?? 0)
                    );
                    if (this.tmpVec.lengthSq() < 1e-5) {
                        const seed = Math.sin((latticeIndex + 1) * 12.9898);
                        this.tmpVec.set(
                            Math.sin(seed * 43758.5453),
                            Math.cos(seed * 9631.517),
                            Math.sin(seed * 27437.27 + 1.3)
                        );
                    }
                    this.tmpVec.normalize();

                    const rating = clamp01(typeof node.rating === 'number' ? node.rating :
                        (typeof node.quantum_potential === 'number' ? node.quantum_potential :
                            (typeof node.reward === 'number' ? node.reward : 0.5)));
                    const magnitude = Math.min(this.maxDisplacement, 0.9 + rating * 2.0);
                    const offset = this.tmpVec2.copy(this.tmpVec).multiplyScalar(magnitude);

                    const target = this.pointTargets[latticeIndex];
                    if (target) {
                        target.add(offset);
                        if (target.lengthSq() > this.maxDisplacement * this.maxDisplacement) {
                            target.setLength(this.maxDisplacement);
                        }
                    }
                    this.injectNeighborRipple(latticeIndex, offset, rating);
                    applied = true;
                });

                if (applied) {
                    this.deformationNeedsUpdate = true;
                    this.pendingFlowRefreshAt = now + 220;
                }
            }

            animateLatticeDeformation(delta) {
                if (!this.latticePoints.length) return;
                const dt = Math.min(Math.max(delta, 0.001), 0.06);
                const { stiffness, damping, targetFade } = this.deformationSettings;
                let moved = false;

                for (let i = 0; i < this.latticePoints.length; i++) {
                    const displacement = this.pointDisplacements[i];
                    const target = this.pointTargets[i];
                    const velocity = this.pointVelocities[i];
                    if (!displacement || !target || !velocity) continue;

                    this.tmpVec.copy(target).sub(displacement);
                    if (this.tmpVec.lengthSq() < 1e-6 && velocity.lengthSq() < 1e-6) {
                        if (target.lengthSq() > 1e-6) {
                            target.multiplyScalar(Math.max(0, 1 - targetFade * dt));
                        }
                        continue;
                    }

                    velocity.addScaledVector(this.tmpVec, stiffness * dt);
                    const drag = Math.exp(-damping * dt);
                    velocity.multiplyScalar(drag);
                    displacement.addScaledVector(velocity, dt);

                    const dispLenSq = displacement.lengthSq();
                    if (dispLenSq > this.maxDisplacement * this.maxDisplacement) {
                        displacement.setLength(this.maxDisplacement);
                    }
                    if (dispLenSq > 1e-8) moved = true;

                    target.multiplyScalar(Math.max(0, 1 - targetFade * dt));
                    this.latticePoints[i].copy(this.baseLatticePoints[i]).add(displacement);
                }

                if (moved) {
                    this.updateGeometryBuffers();
                }
            }

            findNearestIndices(index, count) {
                const base = this.latticePoints[index];
                const entries = [];
                for (let i = 0; i < this.latticePoints.length; i++) {
                    if (i === index) continue;
                    entries.push({ i, d: base.distanceToSquared(this.latticePoints[i]) });
                }
                entries.sort((a, b) => a.d - b.d);
                return entries.slice(0, count).map(e => e.i);
            }

            initializeFlowField(force = false) {
                this.clearGroup(this.streamlineGroup);
                this.flowParticles = [];
                if (!this.latticePoints.length) return;
                const streamlineCount = Math.min(24, Math.max(6, Math.floor(this.latticePoints.length / 6)));
                const particleGeometry = new THREE.SphereGeometry(0.05, 10, 10);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: this.streamlineColor, transparent: true, opacity: 0.6 });
                const lineMaterial = new THREE.LineBasicMaterial({ color: this.streamlineColor, transparent: true, opacity: 0.12 });
                for (let i = 0; i < streamlineCount; i++) {
                    const path = this.sampleStreamlinePath();
                    if (path.length < 2) continue;
                    const curve = new THREE.CatmullRomCurve3(path, false, 'centripetal');
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(path), lineMaterial.clone());
                    this.streamlineGroup.add(line);
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                    this.streamlineGroup.add(particle);
                    this.flowParticles.push({
                        mesh: particle,
                        curve,
                        t: Math.random(),
                        speed: 0.6 + Math.random() * 0.8,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            sampleStreamlinePath() {
                if (!this.latticePoints.length) return [];
                const path = [];
                let index = Math.floor(Math.random() * this.latticePoints.length);
                path.push(this.latticePoints[index].clone());
                const visited = new Set([index]);
                const steps = 4;
                for (let i = 0; i < steps; i++) {
                    const neighbors = this.findNearestIndices(index, 6).filter(idx => !visited.has(idx));
                    if (!neighbors.length) break;
                    index = neighbors[Math.floor(Math.random() * neighbors.length)];
                    visited.add(index);
                    path.push(this.latticePoints[index].clone());
                }
                return path;
            }

            updateWithMetrics(metrics = {}) {
                // Store metrics for color calculation
                const prevMetrics = this.lastMetrics || {};
                this.lastMetrics = { ...metrics };

                // Use mantle flow metric to modulate flow speed (overrides m20 flow_rate if available)
                const mantleFlow = state.mantle ? (state.mantle.flow || 1.5) : 1.5;
                const hasFlow = metrics && Object.prototype.hasOwnProperty.call(metrics, 'consciousness_flow_rate');
                if (hasFlow && Number.isFinite(metrics.consciousness_flow_rate)) {
                    this.flowSpeedTarget = 0.6 + Math.max(0, metrics.consciousness_flow_rate) * (mantleFlow / 1.5);
                } else {
                    this.flowSpeedTarget = 1.4 * (mantleFlow / 1.5);
                }

                // Use mantle curvature metric to modulate rotation speed (overrides m20 curvature if available)
                const mantleCurvature = state.mantle ? (state.mantle.curvature || 6.0) : 6.0;
                const hasCurvature = metrics && Object.prototype.hasOwnProperty.call(metrics, 'spacetime_curvature');
                if (hasCurvature && Number.isFinite(metrics.spacetime_curvature)) {
                    this.rotationSpeedTarget = 0.3 + Math.min(Math.max(metrics.spacetime_curvature, 0), 40) * 0.04 * (mantleCurvature / 6.0);
                } else {
                    this.rotationSpeedTarget = 0.6 * (mantleCurvature / 6.0);
                }

                const activity = (metrics.fluid_steps || 0) + (metrics.valence_updates || 0) + (metrics.energy_explorations || 0);
                const opacity = 0.12 + Math.min(activity, 400) * 0.0003;
                this.streamlineGroup.children.forEach(child => {
                    if (child.material && typeof child.material.opacity === 'number') {
                        child.material.opacity = Math.min(0.4, opacity);
                    }
                });

                // Check if significant metric changes warrant a lattice color update
                const significantChange = this.hasSignificantMetricChange(prevMetrics, metrics);
                if (significantChange && this.latticePoints.length > 0) {
                    // Rebuild lattice geometry with new colors every few updates to avoid too frequent rebuilds
                    if (!this.lastColorUpdate || (Date.now() - this.lastColorUpdate) > 2000) {
                        this.buildLatticeGeometry();
                        this.lastColorUpdate = Date.now();
                    }
                }
            }

            hasSignificantMetricChange(prev, curr) {
                const threshold = 0.1; // 10% change threshold
                const keys = ['consciousness_flow_rate', 'spacetime_curvature', 'fluid_steps', 'valence_updates', 'energy_explorations'];

                for (const key of keys) {
                    const prevVal = prev[key] || 0;
                    const currVal = curr[key] || 0;
                    const maxVal = Math.max(Math.abs(prevVal), Math.abs(currVal), 1); // Avoid division by zero
                    const change = Math.abs(prevVal - currVal) / maxVal;
                    if (change > threshold) {
                        return true;
                    }
                }
                return false;
            }

            update(delta) {
                if (!this.root) return;
                this.animateLatticeDeformation(delta);
                if (this.pendingFlowRefreshAt) {
                    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                    if (now >= this.pendingFlowRefreshAt) {
                        this.initializeFlowField(true);
                        this.pendingFlowRefreshAt = null;
                    }
                }
                this.time = (this.time || 0) + delta;
                const lerp = Math.min(1, delta * 2.4);
                this.flowSpeed += (this.flowSpeedTarget - this.flowSpeed) * lerp;
                this.rotationSpeed += (this.rotationSpeedTarget - this.rotationSpeed) * lerp;

                // Initialize gyroscopic state if not present
                if (!this.gyroState) {
                    this.gyroState = {
                        spinAxis: new THREE.Vector3(0, 1, 0),  // Primary spin axis
                        precessionAxis: new THREE.Vector3(0, 0, 1),  // Precession axis
                        spinRate: 0.2,  // Current spin rate (around spin axis)
                        precessionRate: 0.0,  // Precession rate (spin axis drifts around precession axis)
                        nutationPhase: 0.0,  // Nutation wobble phase
                        nutationAmplitude: 0.0,  // How much wobble
                        angularMomentum: new THREE.Vector3(0, 1, 0),  // Angular momentum vector
                        torque: new THREE.Vector3(0, 0, 0),  // Applied torque
                        inertia: 1.0  // Moment of inertia
                    };
                }

                // Get rotor metrics from state
                const metrics = this.lastMetrics || {};
                const rotorActivity = metrics.rotor_activity || 0.0;
                const rotorPressure = metrics.rotor_pressure || 0.0;
                const spacetimeCurvature = metrics.spacetime_curvature || 0.0;

                // Apply gyroscopic physics based on rotor metrics
                this.updateGyroscopicMotion(delta, rotorActivity, rotorPressure, spacetimeCurvature);

                for (const particle of this.flowParticles) {
                    particle.t = (particle.t + delta * this.flowSpeed * particle.speed * 0.08) % 1;
                    const position = particle.curve.getPointAt(particle.t);
                    const look = particle.curve.getPointAt((particle.t + 0.015) % 1);
                    particle.mesh.position.copy(position);
                    particle.mesh.lookAt(look);
                    const pulse = 0.45 + 0.45 * Math.sin(this.time * 2.0 + particle.phase);
                    particle.mesh.material.opacity = 0.3 + pulse * 0.4;
                }
            }

            updateGyroscopicMotion(delta, rotorActivity, rotorPressure, spacetimeCurvature) {
                const gyro = this.gyroState;

                // Map rotor metrics to gyroscopic parameters
                // rotor_activity affects spin rate variation and nutation
                const activityScale = Math.max(0.1, Math.min(rotorActivity, 10.0)); // Clamp to reasonable range
                const spinModulation = 1.0 + 0.3 * Math.sin(this.time * activityScale * 0.5);
                gyro.spinRate = this.rotationSpeed * 0.4 * spinModulation;

                // rotor_pressure affects precession rate and torque
                const pressureScale = Math.max(0.0, Math.min(rotorPressure, 5.0));
                gyro.precessionRate = pressureScale * 0.08; // Slow precession

                // spacetime_curvature affects the direction of the torque and axis drift
                const curvatureForce = Math.max(-2.0, Math.min(spacetimeCurvature, 2.0));

                // Apply torque based on curvature (causes precession)
                gyro.torque.set(
                    curvatureForce * 0.1 * Math.sin(this.time * 0.3),
                    0,
                    curvatureForce * 0.1 * Math.cos(this.time * 0.3)
                );

                // Nutation (wobble) driven by rotor activity
                gyro.nutationPhase += delta * activityScale * 2.0;
                gyro.nutationAmplitude = Math.min(0.3, activityScale * 0.1);

                // Update angular momentum based on torque (L = L + τ * dt)
                const torqueDelta = gyro.torque.clone().multiplyScalar(delta);
                gyro.angularMomentum.add(torqueDelta);

                // Normalize angular momentum to prevent runaway
                if (gyro.angularMomentum.length() > 5.0) {
                    gyro.angularMomentum.normalize().multiplyScalar(5.0);
                }

                // Update spin axis based on precession
                if (gyro.precessionRate > 0.001) {
                    const precessionAngle = gyro.precessionRate * delta;
                    const precessionMatrix = new THREE.Matrix4();
                    precessionMatrix.makeRotationAxis(gyro.precessionAxis, precessionAngle);
                    gyro.spinAxis.applyMatrix4(precessionMatrix);
                    gyro.spinAxis.normalize();
                }

                // Apply nutation (wobble around spin axis)
                const nutationOffset = new THREE.Vector3(
                    Math.sin(gyro.nutationPhase) * gyro.nutationAmplitude,
                    0,
                    Math.cos(gyro.nutationPhase) * gyro.nutationAmplitude
                );

                const currentSpinAxis = gyro.spinAxis.clone().add(nutationOffset).normalize();

                // Apply the rotation to the lattice root
                const rotationAngle = gyro.spinRate * delta;
                if (rotationAngle > 0.001) {
                    const rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationAxis(currentSpinAxis, rotationAngle);

                    // Apply rotation to the root object
                    this.root.applyMatrix4(rotationMatrix);
                }

                // Gradual axis drift based on angular momentum direction
                const momentumInfluence = 0.02 * delta;
                const targetAxis = gyro.angularMomentum.clone().normalize();
                gyro.spinAxis.lerp(targetAxis, momentumInfluence);
                gyro.spinAxis.normalize();

                // Slowly change precession axis based on system state
                if (Math.random() < 0.001) { // Very occasional axis shifts
                    gyro.precessionAxis.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    ).normalize();
                }
            }

            recolorMaterials() {
                this.pointGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.latticeColor);
                });
                this.edgeGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.latticeColor);
                });
                this.streamlineGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.streamlineColor);
                });
            }

            clearGroup(group) {
                while (group.children.length) {
                    const child = group.children.pop();
                    if (child.geometry && child.geometry.dispose) child.geometry.dispose();
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat && mat.dispose && mat.dispose());
                    } else if (child.material && child.material.dispose) {
                        child.material.dispose();
                    }
                }
                if (group === this.pointGroup) {
                    this.pointGeometry = null;
                    this.pointPositionsAttr = null;
                    this.pointColorsAttr = null;
                } else if (group === this.edgeGroup) {
                    this.edgeGeometry = null;
                    this.edgePositionsAttr = null;
                }
            }
        }
        // --- START: Tetra Mode 3D Scene ---

        // Three.js scene setup for tetra mode - lazy initialization
        let tetraRenderer = null;
        let tetraScene = null;
        let tetraCamera = null;
        let composer, outlinePass;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        // Global tetra system state
        let tetraInitialized = false;
        let tetraMeshesReady = false;

        // Instanced tetra system for performance
        let tetraMeshes = [];
        let tetraInstanceData = [];
        const tetraIndexById = new Map();
        const MAX_INSTANCES = 1000;
        const MAX_TWEEN_DURATION = 1500;

        // ==== Kaleidoscope Tunables (Ring Layout / Rotors) ====
        const LAYOUT_MODE = 'projected';
        const RING_RADIUS = 20; // Increased from 14 for better separation
        const DEPTH_SCALE = 3.0; // Increased from 2.0 for more depth separation
        const MIN_SCALE = 0.08; // Reduced from 0.12 to make tetrahedra smaller
        const MAX_SCALE = 0.18; // Reduced from 0.25 to make tetrahedra smaller

        // Global rotation speed multiplier for easy tuning (reduced to prevent bugs)
        const GLOBAL_ROTATION_SPEED_MULTIPLIER = 1.2;

        // Reusable temps
        const VEC_Z = new THREE.Vector3(0, 0, 1);
        const TMP_Q = new THREE.Quaternion();
        const TMP_M = new THREE.Matrix4();
        const TMP_V = new THREE.Vector3();

        // Throttled TWEEN update
        const throttledTweenUpdate = (() => {
            let lastTime = 0;
            return (time) => {
                if (time - lastTime > 16) { // roughly 60fps
                    if (typeof TWEEN !== 'undefined' && TWEEN.update) {
                        TWEEN.update(time);
                    }
                    lastTime = time;
                }
            }
        })();

        // Smooth transition system for tetrahedra
        const tetraTransitions = new Map(); // Track active transitions by globalIndex

        function smoothUpdateTetraPosition(inst, newCenter, newQuaternion, newScale, duration = 800) {
            if (!inst || !inst.mesh) return;

            const globalIndex = inst.globalIndex;

            // Cancel any existing transition for this instance
            const existingTween = tetraTransitions.get(globalIndex);
            if (existingTween) {
                existingTween.stop();
                tetraTransitions.delete(globalIndex);
            }

            // Get current transform
            const currentMatrix = new THREE.Matrix4();
            inst.mesh.getMatrixAt(inst.index, currentMatrix);

            const currentPos = new THREE.Vector3();
            const currentQuat = new THREE.Quaternion();
            const currentScale = new THREE.Vector3();
            currentMatrix.decompose(currentPos, currentQuat, currentScale);

            // Create interpolation object
            const interpolation = {
                // Position
                x: currentPos.x,
                y: currentPos.y,
                z: currentPos.z,
                // Quaternion (using euler angles for smoother interpolation)
                rotX: currentQuat.x,
                rotY: currentQuat.y,
                rotZ: currentQuat.z,
                rotW: currentQuat.w,
                // Scale
                scaleX: currentScale.x,
                scaleY: currentScale.y,
                scaleZ: currentScale.z
            };

            // Target values
            const targetPos = newCenter || currentPos;
            const targetQuat = newQuaternion || currentQuat;
            const targetScale = newScale ? new THREE.Vector3(newScale, newScale, newScale) : currentScale;

            // Create smooth transition
            const tween = createTween(interpolation)
                .to({
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    rotX: targetQuat.x,
                    rotY: targetQuat.y,
                    rotZ: targetQuat.z,
                    rotW: targetQuat.w,
                    scaleX: targetScale.x,
                    scaleY: targetScale.y,
                    scaleZ: targetScale.z
                }, duration)
                .easing(TWEEN.Easing.Cubic.Out)
                .onUpdate(() => {
                    try {
                        // Apply interpolated transform
                        const pos = new THREE.Vector3(interpolation.x, interpolation.y, interpolation.z);
                        const quat = new THREE.Quaternion(interpolation.rotX, interpolation.rotY, interpolation.rotZ, interpolation.rotW);
                        quat.normalize(); // Ensure quaternion is normalized
                        const scale = new THREE.Vector3(interpolation.scaleX, interpolation.scaleY, interpolation.scaleZ);

                        const matrix = new THREE.Matrix4().compose(pos, quat, scale);
                        inst.mesh.setMatrixAt(inst.index, matrix);
                        inst.mesh.instanceMatrix.needsUpdate = true;

                        // Update stored position for collision avoidance
                        if (inst.fullData) {
                            inst.fullData.__centroid = pos.clone();
                        }
                    } catch (e) {
                        console.warn('[smoothUpdate] Matrix update failed:', e);
                    }
                })
                .onComplete(() => {
                    tetraTransitions.delete(globalIndex);
                    console.log(`[smoothUpdate] Transition completed for tetra ${globalIndex}`);
                })
                .start();

            tetraTransitions.set(globalIndex, tween);
            console.log(`[smoothUpdate] Started smooth transition for tetra ${globalIndex} over ${duration}ms`);

            return tween;
        }

        function smoothRemoveTetrahedron(inst, duration = 600, callback = null) {
            if (!inst || !inst.mesh) {
                if (callback) callback();
                return;
            }

            const globalIndex = inst.globalIndex;
            console.log(`[smoothRemove] Starting exit animation for tetra ${globalIndex}`);

            // Cancel any existing transition
            const existingTween = tetraTransitions.get(globalIndex);
            if (existingTween) {
                existingTween.stop();
                tetraTransitions.delete(globalIndex);
            }

            // Get current transform
            const currentMatrix = new THREE.Matrix4();
            inst.mesh.getMatrixAt(inst.index, currentMatrix);

            const currentPos = new THREE.Vector3();
            const currentQuat = new THREE.Quaternion();
            const currentScale = new THREE.Vector3();
            currentMatrix.decompose(currentPos, currentQuat, currentScale);

            // Animate to zero scale and slight upward movement
            const exitPos = currentPos.clone();
            exitPos.y += 1.0; // Slight upward drift

            const interpolation = {
                x: currentPos.x,
                y: currentPos.y,
                z: currentPos.z,
                rotX: currentQuat.x,
                rotY: currentQuat.y,
                rotZ: currentQuat.z,
                rotW: currentQuat.w,
                scaleX: currentScale.x,
                scaleY: currentScale.y,
                scaleZ: currentScale.z,
                opacity: 1.0
            };

            const tween = createTween(interpolation)
                .to({
                    x: exitPos.x,
                    y: exitPos.y,
                    z: exitPos.z,
                    rotX: currentQuat.x,
                    rotY: currentQuat.y + Math.PI, // Add rotation during exit
                    rotZ: currentQuat.z,
                    rotW: currentQuat.w,
                    scaleX: 0.01,
                    scaleY: 0.01,
                    scaleZ: 0.01,
                    opacity: 0.0
                }, duration)
                .easing(TWEEN.Easing.Cubic.In)
                .onUpdate(() => {
                    try {
                        const pos = new THREE.Vector3(interpolation.x, interpolation.y, interpolation.z);
                        const quat = new THREE.Quaternion(interpolation.rotX, interpolation.rotY, interpolation.rotZ, interpolation.rotW);
                        quat.normalize();
                        const scale = new THREE.Vector3(interpolation.scaleX, interpolation.scaleY, interpolation.scaleZ);

                        const matrix = new THREE.Matrix4().compose(pos, quat, scale);
                        inst.mesh.setMatrixAt(inst.index, matrix);
                        inst.mesh.instanceMatrix.needsUpdate = true;
                    } catch (e) {
                        console.warn('[smoothRemove] Matrix update failed:', e);
                    }
                })
                .onComplete(() => {
                    tetraTransitions.delete(globalIndex);
                    console.log(`[smoothRemove] Exit animation completed for tetra ${globalIndex}`);
                    if (callback) callback();
                })
                .start();

            tetraTransitions.set(globalIndex, tween);
            return tween;
        }

        function smoothUpdateTetraColor(inst, newColor, duration = 400) {
            if (!inst || !inst.mesh || !inst.mesh.instanceColor) return;

            const globalIndex = inst.globalIndex;

            // Get current color - ensure it's always a THREE.Color object
            let currentColor = inst.color;
            if (!currentColor || typeof currentColor.distanceTo !== 'function') {
                currentColor = new THREE.Color(0xffffff);
            }

            // Skip if colors are too similar
            const colorDistance = currentColor.distanceTo(newColor);
            if (colorDistance < 0.1) return; // Colors are very similar

            console.log(`[smoothColor] Transitioning tetra ${globalIndex} from #${currentColor.getHexString()} to #${newColor.getHexString()}`);

            const colorInterpolation = {
                r: currentColor.r,
                g: currentColor.g,
                b: currentColor.b
            };

            const colorTween = createTween(colorInterpolation)
                .to({
                    r: newColor.r,
                    g: newColor.g,
                    b: newColor.b
                }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    try {
                        const interpolatedColor = new THREE.Color(
                            colorInterpolation.r,
                            colorInterpolation.g,
                            colorInterpolation.b
                        );
                        inst.mesh.setColorAt(inst.index, interpolatedColor);
                        inst.mesh.instanceColor.needsUpdate = true;
                        inst.color = interpolatedColor.clone();
                    } catch (e) {
                        console.warn('[smoothColor] Color update failed:', e);
                    }
                })
                .start();

            return colorTween;
        }

        // Subtle breathing/pulsing effect for active tetrahedra
        function addBreathingEffect(inst, intensity = 0.1, period = 3000) {
            if (!inst || !inst.mesh) return;

            const globalIndex = inst.globalIndex;
            const baseScale = inst.fullData?.__scale || 1.0;

            // Create oscillating scale effect
            const breathingEffect = {
                scale: baseScale,
                time: 0
            };

            const breathTween = createTween(breathingEffect)
                .to({ time: Math.PI * 2 }, period)
                .repeat(Infinity)
                .easing(TWEEN.Easing.Linear.None)
                .onUpdate(() => {
                    try {
                        // Subtle sine wave scaling
                        const pulseScale = baseScale + Math.sin(breathingEffect.time) * intensity * baseScale;

                        // Get current matrix and update only the scale component
                        const currentMatrix = new THREE.Matrix4();
                        inst.mesh.getMatrixAt(inst.index, currentMatrix);

                        const pos = new THREE.Vector3();
                        const quat = new THREE.Quaternion();
                        const scale = new THREE.Vector3();
                        currentMatrix.decompose(pos, quat, scale);

                        // Apply pulsing to the scale
                        scale.setScalar(pulseScale);

                        const newMatrix = new THREE.Matrix4().compose(pos, quat, scale);
                        inst.mesh.setMatrixAt(inst.index, newMatrix);
                        inst.mesh.instanceMatrix.needsUpdate = true;

                    } catch (e) {
                        // Silently handle errors to avoid spam
                    }
                })
                .start();

            return breathTween;
        }

        async function initializeTetraMode() {
            if (tetraInitialized) return;

            tetraRenderer = new THREE.WebGLRenderer({
                canvas: DOM.tetraCanvas,
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance',
                stencil: false
            });
            tetraRenderer.outputColorSpace = THREE.SRGBColorSpace;
            tetraRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            tetraRenderer.toneMappingExposure = 1.15;

            let dpr = Math.min(window.devicePixelRatio, 2.0);
            tetraRenderer.setPixelRatio(dpr);

            tetraScene = new THREE.Scene();
            tetraScene.fog = new THREE.FogExp2(0x0b1321, 0.012);

            function applyThemeBackground() {
                const cssBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0b0f17';
                const bg = new THREE.Color(cssBg);
                tetraScene.background = bg;
                tetraRenderer.setClearColor(bg, 1);
                tetraRenderer.setClearAlpha(1);
                const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                if (tetraScene.fog) {
                    tetraScene.fog.color.set(bg);
                    tetraScene.fog.density = isLight ? 0.007 : 0.012;
                }
            }
            window.applyThemeBackground = applyThemeBackground;
            applyThemeBackground();

            const rect = DOM.tetraCanvas.parentElement.getBoundingClientRect();
            tetraCamera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.2, 120);
            tetraCamera.position.set(0, 0, 14);
            tetraCamera.updateProjectionMatrix();

            fluidVisualizer = new FluidLatticeVisualizer(tetraScene, tetraCamera, tetraRenderer);
            fluidVisualizer.initializeFluidVisualization();
            window.fluidVisualizer = fluidVisualizer;

            const pmrem = new THREE.PMREMGenerator(tetraRenderer);
            const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
            envTex.generateMipmaps = false;
            envTex.minFilter = THREE.LinearFilter;
            envTex.magFilter = THREE.LinearFilter;
            envTex.needsUpdate = true;
            tetraScene.environment = envTex;

            tetraScene.add(new THREE.HemisphereLight(0xa0d8ef, 0x0b1321, 0.6));
            const key = new THREE.DirectionalLight(0xffffff, 1.2);
            key.position.set(2.5, 4.0, 3.0);
            key.castShadow = true;
            tetraScene.add(key);
            const fill = new THREE.DirectionalLight(0xffffff, 0.6);
            fill.position.set(-3.0, 1.0, 2.5);
            tetraScene.add(fill);
            const rim = new THREE.DirectionalLight(0xffffff, 0.6);
            rim.position.set(-2.0, 0.5, -3.0);
            tetraScene.add(rim);

            const tetraControls = new OrbitControls(tetraCamera, tetraRenderer.domElement);
            tetraControls.enableDamping = true;
            tetraControls.dampingFactor = 0.06;
            tetraControls.minDistance = 0.1;
            tetraControls.maxDistance = 40;
            window.__tetraControls = tetraControls;

            composer = new EffectComposer(tetraRenderer);
            const renderPass = new RenderPass(tetraScene, tetraCamera);
            composer.addPass(renderPass);

            outlinePass = new OutlinePass(new THREE.Vector2(rect.width, rect.height), tetraScene, tetraCamera);
            outlinePass.edgeStrength = 5.0;
            outlinePass.edgeGlow = 0.5;
            outlinePass.edgeThickness = 1.0;
            outlinePass.pulsePeriod = 2;
            outlinePass.visibleEdgeColor.set('#8ef1ff');
            outlinePass.hiddenEdgeColor.set('#192a46');
            composer.addPass(outlinePass);
            try {
                if (composer?.renderTarget1?.texture) {
                    composer.renderTarget1.texture.generateMipmaps = false;
                    composer.renderTarget1.texture.minFilter = THREE.LinearFilter;
                }
                if (composer?.renderTarget2?.texture) {
                    composer.renderTarget2.texture.generateMipmaps = false;
                    composer.renderTarget2.texture.minFilter = THREE.LinearFilter;
                }
            } catch (e) {
                console.warn('Failed to adjust composer render targets', e);
            }

            await createInstancedTetraMesh();

            new ResizeObserver(() => {
                const p = DOM.tetraCanvas.parentElement;
                if (!p) return;
                const w = p.clientWidth; const h = p.clientHeight;
                if (w === 0 || h === 0) return;

                tetraCamera.aspect = w / h;
                tetraCamera.updateProjectionMatrix();

                tetraRenderer.setSize(w, h, false);
                composer.setSize(w, h);
                outlinePass.resolution.set(w, h);
            }).observe(DOM.tetraCanvas.parentElement);

            await ensureLatticeLoaded();
            tetraInitialized = true;
        }

        function generateE8Roots() {
            const roots = new Set();
            for (let i = 0; i < 8; i++) {
                for (let j = i + 1; j < 8; j++) {
                    for (const [s1, s2] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                        const vec = new Array(8).fill(0); vec[i] = s1; vec[j] = s2; roots.add(vec.join(','));
                    }
                }
            }
            for (let signs = 0; signs < 256; signs++) {
                const vec = [];
                let negCount = 0;
                for (let i = 0; i < 8; i++) {
                    if ((signs >> i) & 1) { vec.push(-0.5); negCount++; } else { vec.push(0.5); }
                }
                if (negCount % 2 === 0) { roots.add(vec.join(',')); }
            }
            return Array.from(roots).map(s => s.split(',').map(Number));
        }

        function createE8ProjectionMatrix() {
            const matrix = [];
            for (let i = 0; i < 8; i++) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const u1 = Math.random(); const u2 = Math.random();
                    row.push(Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.3);
                }
                matrix.push(row);
            }
            return matrix;
        }

        async function generateLatticeTetrahedra() {
            if (latticePoints.length) {
                const selectedPoints = latticePoints.slice(0, Math.min(12, latticePoints.length));
                return selectedPoints.map(p => p.clone().multiplyScalar(TETRA_LOCAL_SIZE * 0.5));
            }
            const e8Roots = generateE8Roots();
            const projMatrix = createE8ProjectionMatrix();
            const points3D = e8Roots.map(root => {
                const x = root.reduce((s, v, i) => s + v * projMatrix[i][0], 0);
                const y = root.reduce((s, v, i) => s + v * projMatrix[i][1], 0);
                const z = root.reduce((s, v, i) => s + v * projMatrix[i][2], 0);
                return new THREE.Vector3(x, y, z);
            });
            const center = new THREE.Vector3();
            points3D.forEach(p => center.add(p));
            center.divideScalar(points3D.length);
            points3D.forEach(p => p.sub(center));
            const maxCoord = Math.max(...points3D.flatMap(p => [Math.abs(p.x), Math.abs(p.y), Math.abs(p.z)]));
            if (maxCoord > 0) points3D.forEach(p => p.multiplyScalar(TETRA_LOCAL_SIZE / maxCoord));
            return points3D.slice(0, 12);
        }

        async function createInstancedTetraMesh() {
            const latticeTetraPoints = await generateLatticeTetrahedra();
            const geometries = [];
            if (latticeTetraPoints.length >= 8) {
                try {
                    const createHullFromIndices = (indices) => {
                        const points = indices.map(i => latticeTetraPoints[i]).filter(Boolean);
                        if (points.length < 4 || tetraVolume(...points.slice(0, 4)) < 0.001) return null;
                        try { return new ConvexGeometry(points); } catch (e) { return null; }
                    };
                    let geo1 = createHullFromIndices([0, 1, 2, 3]); if (geo1) geometries.push(geo1);
                    let geo2 = createHullFromIndices([0, 4, 7, 11]); if (geo2) geometries.push(geo2);
                    let geo3 = createHullFromIndices([1, 5, 8, 10]); if (geo3) geometries.push(geo3);
                    let geo4 = createHullFromIndices([0, 2, 5, 9, 11]); if (geo4) geometries.push(geo4);
                    if (geometries.length === 0) throw new Error("All geometry variants failed.");
                } catch (e) { geometries.length = 0; }
            }
            if (geometries.length === 0) geometries.push(createFallbackTetraGeometry());
            const material = createTetraMaterial();
            const instancesPerGeometry = Math.ceil(MAX_INSTANCES / geometries.length);
            geometries.forEach((geo, idx) => {
                if (!geo?.attributes?.position) return;
                try {
                    geo.computeVertexNormals();
                    geo.computeBoundingSphere();

                    // Since we're using instance colors instead of vertex colors,
                    // we don't need to create per-vertex color attributes
                    geo.computeVertexNormals();
                    geo.computeBoundingSphere();

                    const mesh = new THREE.InstancedMesh(geo, material.clone(), instancesPerGeometry);
                    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    // Initialize instance colors with default tetrahedra color (blue-ish)
                    const colors = new Float32Array(instancesPerGeometry * 3);
                    const defaultColor = new THREE.Color(0x4a90e2); // Nice blue color
                    for (let i = 0; i < instancesPerGeometry; i++) {
                        colors[i * 3] = defaultColor.r;
                        colors[i * 3 + 1] = defaultColor.g;
                        colors[i * 3 + 2] = defaultColor.b;
                    }
                    mesh.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);
                    mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                    mesh.count = 0;
                    mesh.userData.geometryType = idx;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    tetraMeshes.push(mesh);
                    tetraScene.add(mesh);
                } catch (e) { }
            });
            if (tetraMeshes.length === 0) { console.error('CRITICAL: No instanced meshes could be created.'); return; }
            window.tetraMeshes = tetraMeshes;
            tetraMeshesReady = true;
        }

        function createFallbackTetraGeometry() {
            const h = Math.sqrt(2 / 3) * TETRA_LOCAL_SIZE, r = Math.sqrt(3) / 3 * TETRA_LOCAL_SIZE;
            const points = [
                new THREE.Vector3(0, h, 0),
                new THREE.Vector3(r, -h / 3, r * Math.sqrt(3) / 3),
                new THREE.Vector3(r, -h / 3, -r * Math.sqrt(3) / 3),
                new THREE.Vector3(-r, -h / 3, 0)
            ];
            const geo = new ConvexGeometry(points);

            // Since we're using instance colors now, no need for vertex colors
            // Just return the geometry with computed normals
            geo.computeVertexNormals();
            return geo;
        }
        let latticeGroup = null, latticePoints = [], BASE_TETRA_VERTS = null;
        function ensureBaseTetraVerts() {
            if (BASE_TETRA_VERTS) return BASE_TETRA_VERTS;
            return BASE_TETRA_VERTS = [
                new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, -1, -1)
            ].map(p => p.multiplyScalar(TETRA_LOCAL_SIZE));
        }
        async function ensureLatticeLoaded() {
            if (latticePoints.length) return latticePoints;
            try {
                console.log('[api] Loading lattice blueprint from:', `${API_BASE_URL}/api/blueprint`);
                const controller = new AbortController();
                const t = setTimeout(() => controller.abort(), 10000); // Increased timeout

                const res = await fetch(`${API_BASE_URL}/api/blueprint`, {
                    cache: 'no-store',
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });

                clearTimeout(t);

                if (!res.ok) {
                    throw new Error(`Blueprint fetch failed: HTTP ${res.status} ${res.statusText}`);
                }

                const arr = await res.json();
                console.log('[api] Blueprint loaded successfully, processing lattice points');

                const blueprintMeta = (arr || []).map((p, idx) => {
                    const renderVec = new THREE.Vector3(
                        Number(p.render_x ?? p.x ?? 0) || 0,
                        Number(p.render_y ?? p.y ?? 0) || 0,
                        Number(p.render_z ?? p.z ?? 0) || 0
                    );
                    const baseVec = new THREE.Vector3(
                        Number(p.x ?? p.render_x ?? 0) || 0,
                        Number(p.y ?? p.render_y ?? 0) || 0,
                        Number(p.z ?? p.render_z ?? 0) || 0
                    );
                    return {
                        id: Object.prototype.hasOwnProperty.call(p, 'id') ? p.id : idx,
                        position: renderVec,
                        base: baseVec
                    };
                });

                latticePoints = blueprintMeta.map(meta => meta.position.clone());

                console.log(`[api] Processed ${latticePoints.length} lattice points`);
            } catch (e) {
                console.warn('[api] Failed to load lattice blueprint:', e.message);
                latticePoints = [];
                return latticePoints;
            }
            try {
                if (fluidVisualizer) {
                    fluidVisualizer.setBlueprintLattice(blueprintMeta);
                    return latticePoints;
                }
                if (!latticeGroup) {
                    latticeGroup = new THREE.Group();
                    latticeGroup.name = "E8_Lattice_3D_projection";
                    tetraScene.add(latticeGroup);
                } else {
                    while (latticeGroup.children.length) {
                        latticeGroup.remove(latticeGroup.children[0]);
                    }
                }

                // Render lattice points
                const pos = new Float32Array(latticePoints.length * 3);
                for (let i = 0; i < latticePoints.length; i++) {
                    latticePoints[i].toArray(pos, i * 3);
                }
                const pointsGeo = new THREE.BufferGeometry();
                pointsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const pointsMat = new THREE.PointsMaterial({
                    size: 0.02,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.6,
                    color: 0x7aa2ff
                });
                latticeGroup.add(new THREE.Points(pointsGeo, pointsMat));

                // ADD LATTICE EDGES - Connect nearby points
                const edges = [];
                const maxDistance = 2.0; // Adjust this to control connection density

                for (let i = 0; i < latticePoints.length; i++) {
                    for (let j = i + 1; j < latticePoints.length; j++) {
                        const dist = latticePoints[i].distanceTo(latticePoints[j]);
                        if (dist < maxDistance) {
                            edges.push(latticePoints[i], latticePoints[j]);
                        }
                    }
                }

                // Create edge geometry
                const edgeGeometry = new THREE.BufferGeometry();
                const edgePositions = new Float32Array(edges.length * 3);
                for (let i = 0; i < edges.length; i++) {
                    edges[i].toArray(edgePositions, i * 3);
                }
                edgeGeometry.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));

                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0x7aa2ff,
                    transparent: true,
                    opacity: 0.15,
                    linewidth: 1
                });

                const latticeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                latticeGroup.add(latticeLines);

            } catch (e) {
                console.warn("Lattice visualization error:", e);
            }
            return latticePoints;
        }
        function closestKPoints(targetVec3, k = 4) {
            if (!latticePoints.length) return [];
            const arr = latticePoints.map((p, i) => ({ i, d2: p.distanceToSquared(targetVec3) }));
            arr.sort((a, b) => a.d2 - b.d2);
            return arr.slice(0, k).map(o => latticePoints[o.i].clone());
        }
        function affineFromTetraMap(B, T) {
            const Bb = new THREE.Matrix3().set(
                B[1].x - B[0].x, B[2].x - B[0].x, B[3].x - B[0].x,
                B[1].y - B[0].y, B[2].y - B[0].y, B[3].y - B[0].y,
                B[1].z - B[0].z, B[2].z - B[0].z, B[3].z - B[0].z
            );
            if (Math.abs(Bb.determinant()) < 1e-8) return null;
            const Tb = new THREE.Matrix3().set(
                T[1].x - T[0].x, T[2].x - T[0].x, T[3].x - T[0].x,
                T[1].y - T[0].y, T[2].y - T[0].y, T[3].y - T[0].y,
                T[1].z - T[0].z, T[2].z - T[0].z, T[3].z - T[0].z
            );
            const L = new THREE.Matrix3().multiplyMatrices(Tb, Bb.invert());
            const L4 = new THREE.Matrix4().setFromMatrix3(L);
            const t = new THREE.Vector3().subVectors(T[0], B[0].clone().applyMatrix4(L4));
            const T4 = new THREE.Matrix4().makeTranslation(t.x, t.y, t.z);
            return new THREE.Matrix4().multiplyMatrices(T4, L4);
        }
        function chooseNearestLatticeTetra(centerVec3) {
            const pts = closestKPoints(centerVec3, 4);
            return (pts.length < 4) ? null : pts;
        }
        function createTetraMaterial() {
            const material = new THREE.MeshStandardMaterial({
                vertexColors: false,  // Disable vertex colors to use instance colors instead
                color: 0xffffff,      // Base white color to multiply with instance colors
                roughness: 0.4,
                metalness: 0.0,
                transparent: true,
                opacity: 0.85,        // Slightly more opaque for better visibility
                flatShading: false,
                side: THREE.DoubleSide,
                depthWrite: true,     // Enable depth writing for proper sorting
                blending: THREE.NormalBlending,
                alphaTest: 0.01       // Add alpha test for better transparency
            });

            // Add minimal glow animation data - we'll add emissive properties dynamically
            material.userData = {
                glowPhase: Math.random() * Math.PI * 2,
                glowSpeed: 0.3 + Math.random() * 0.3,  // Vary glow speed per material
                originalOpacity: 0.85
            };

            // Ensure the material uses instance colors by modifying the shader
            material.onBeforeCompile = (shader) => {
                console.log('[material] Compiling shader with instance color support');

                // Add instance color attribute to vertex shader
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <common>',
                    `#include <common>
                    attribute vec3 instanceColor;
                    varying vec3 vInstanceColor;`
                );

                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `#include <begin_vertex>
                    vInstanceColor = instanceColor;`
                );

                // Use instance color in fragment shader
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <common>',
                    `#include <common>
                    varying vec3 vInstanceColor;`
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            return material;
        }
        function animateOrganicCrystalGlow(material, time) {
            if (!material.userData) return;
            const { glowPhase, glowSpeed, originalOpacity } = material.userData;

            // Simple, subtle glow pulse
            const pulse = Math.sin(time * glowSpeed + glowPhase) * 0.5 + 0.5;

            // Very subtle emissive glow - start with dark blue and pulse slightly
            const baseEmissive = new THREE.Color(0x000510); // Very dark blue
            const glowIntensity = 0.02 + pulse * 0.05; // Very subtle intensity

            material.emissive.copy(baseEmissive).multiplyScalar(glowIntensity);

            // Very subtle opacity variation
            material.opacity = originalOpacity + Math.sin(time * glowSpeed * 0.5 + glowPhase) * 0.05;
        }
        function addOrganicCrystalFloating(instance, time) {
            if (!instance.userData) instance.userData = {};
            if (!instance.userData.organicMotion) {
                instance.userData.organicMotion = {
                    floatPhase: Math.random() * Math.PI * 2,
                    floatSpeed: 0.4 + Math.random() * 0.5,
                    floatAmplitude: 0.08 + Math.random() * 0.12,
                    rotPhase: Math.random() * Math.PI * 2,
                    rotSpeed: 0.2 + Math.random() * 0.3
                };
            }
            const { floatPhase, floatSpeed, floatAmplitude, rotPhase, rotSpeed } = instance.userData.organicMotion;
            instance.userData.organicOffset = {
                x: Math.cos(time * floatSpeed + floatPhase) * floatAmplitude * 0.7,
                y: Math.sin(time * floatSpeed + floatPhase) * floatAmplitude,
                z: Math.sin(time * floatSpeed * 0.8 + floatPhase + 1) * floatAmplitude * 0.5,
                rotationOffset: Math.sin(time * rotSpeed + rotPhase) * 0.1
            };
        }
        function addTetraInstance(id, matrix, color, omega, axis3, base) {
            if (!window.tetraMeshes || window.tetraMeshes.length === 0) return -1;
            const validMeshes = window.tetraMeshes.filter(m => m?.instanceMatrix && m.count < m.instanceMatrix.count);
            if (validMeshes.length === 0) return -1;
            let targetMesh = validMeshes[Math.abs(id) % validMeshes.length];
            if (!targetMesh || targetMesh.count >= targetMesh.instanceMatrix.count) targetMesh = validMeshes[0];
            if (!targetMesh) return -1;
            const perMeshIndex = targetMesh.count++;
            const globalIndex = tetraInstanceData.length;
            if (!color) color = new THREE.Color(0xffffff); // Default to white if no color provided
            console.log(`[addTetraInstance] Setting instance ${globalIndex} (id: ${id}) color to: #${color.getHexString()}, RGB: ${color.r.toFixed(3)}, ${color.g.toFixed(3)}, ${color.b.toFixed(3)}`); // Debug instance color
            try {
                targetMesh.setMatrixAt(perMeshIndex, matrix);
                if (targetMesh.instanceColor) targetMesh.setColorAt(perMeshIndex, color);
                targetMesh.instanceMatrix.needsUpdate = true;
                if (targetMesh.instanceColor) targetMesh.instanceColor.needsUpdate = true;
                const instanceRecord = { id, matrix, color, omega, axis3, base, index: perMeshIndex, mesh: targetMesh, fullData: null, globalIndex, rotAxis: null };
                tetraInstanceData.push(instanceRecord);
                tetraIndexById.set(id, globalIndex);
                return globalIndex;
            } catch (e) { targetMesh.count--; return -1; }
        }
        function updateTetraInstance(globalIndex, matrix, color) {
            if (typeof globalIndex !== 'number' || isNaN(globalIndex) || globalIndex < 0 || globalIndex >= tetraInstanceData.length) return;
            const instanceData = tetraInstanceData[globalIndex];
            if (!instanceData || !instanceData.mesh) return;
            const { mesh, index: perMeshIndex } = instanceData;
            if (typeof perMeshIndex !== 'number' || perMeshIndex < 0 || perMeshIndex >= mesh.count) return;
            try {
                mesh.setMatrixAt(perMeshIndex, matrix);
                if (color) { mesh.setColorAt(perMeshIndex, color); instanceData.color = color; }
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
            } catch (e) { }
        }
        function extractVec8D(o) {
            return o?.vec8D || o?.vec8d || o?.vec8 || o?.coords_8d || o?.e8_coords || (Array.isArray(o?.vec) && o.vec.length >= 8 ? o.vec.slice(0, 8) : null);
        }
        function seededScatter3(id) {
            let h = 2166136261 >>> 0; const s = String(id ?? '');
            for (let i = 0; i < s.length; i++) h = Math.imul(h ^ s.charCodeAt(i), 16777619);
            const a = ((h) & 1023) / 512 - 1, b = ((h >> 10) & 1023) / 512 - 1, c = ((h >> 20) & 1023) / 512 - 1;
            // Increase the scatter range to ensure proper spread without overlapping
            const scatterRange = 35; // Increased significantly to prevent overlapping
            return [a * scatterRange, b * scatterRange, c * scatterRange];
        }
        function safeCoords3D(d) {
            console.log(`safeCoords3D input data keys:`, Object.keys(d || {}));
            if (Array.isArray(d.final_coords_3d) && d.final_coords_3d.length >= 3) {
                console.log(`Using final_coords_3d:`, d.final_coords_3d);
                return d.final_coords_3d;
            }
            if (Array.isArray(d.coords_3d) && d.coords_3d.length >= 3) {
                console.log(`Using coords_3d:`, d.coords_3d);
                return d.coords_3d;
            }
            const v8 = extractVec8D(d);
            if (Array.isArray(v8) && v8.length >= 8) {
                const coords = [v8[0], v8[1], v8[2]];
                console.log(`Using first 3 of vec8D:`, coords, 'from', v8);
                return coords;
            }

            // Use shell-based positioning: different shells at different radii
            const shellDim = d.shell_dim || 8;
            const shellRadius = {
                8: 2.0,   // Inner shell - increased spacing
                16: 4.5,  // Second shell - increased spacing
                32: 7.5,  // Third shell - increased spacing
                64: 12.0  // Outer shell - increased spacing
            }[shellDim] || 2.0;

            const scattered = seededScatter3(d.node_id);
            // Normalize to unit sphere, then scale by shell radius
            const magnitude = Math.sqrt(scattered[0] * scattered[0] + scattered[1] * scattered[1] + scattered[2] * scattered[2]);
            const normalized = magnitude > 0 ? scattered.map(x => x / magnitude) : [1, 0, 0];
            const shellCoords = normalized.map(x => x * shellRadius * 4); // Reduced scaling factor from 8 to 4

            console.log(`Using shell-based positioning for ${d.node_id} (shell ${shellDim}): radius=${shellRadius}, coords=`, shellCoords);
            return shellCoords;
        }
        function baseCenter3(d) {
            const p = safeCoords3D(d);
            const coords = [Number(p[0]) || 0, Number(p[1]) || 0, Number(p[2]) || 0];
            console.log(`baseCenter3 for ${d?.node_id || 'unknown'}: raw coords=`, p, 'final coords=', coords);
            return coords;
        }
        function extractLabel(d) { return d?.label || d?.id || d?.node_id || 'unknown'; }
        function ratingScale(d) { return MIN_SCALE + (MAX_SCALE - MIN_SCALE) * Math.max(0, Math.min(1, Number(d.rating) || 0.5)); }
        function seededAxisSpeed(id) {
            let h = 2166136261 >>> 0;
            const s = String(id);
            for (let i = 0; i < s.length; i++) h = Math.imul(h ^ s.charCodeAt(i), 16777619);
            const x = ((h) & 1023) / 512 - 1, y = ((h >> 10) & 1023) / 512 - 1, z = ((h >> 20) & 1023) / 512 - 1;
            return { axis: new THREE.Vector3(x, y, z).normalize(), speed: ((h >> 20) & 255) / 256 * 0.5 + 0.1 };
        }
        function axisAngleQuat(axis, angle) { return new THREE.Quaternion().setFromAxisAngle(axis, angle); }

        // Collision avoidance to prevent overlapping tetrahedra
        function avoidCollisions(position, minDistance = 2.0) {
            const existingPositions = tetraInstanceData
                .filter(inst => inst && inst.fullData && inst.fullData.__centroid)
                .map(inst => inst.fullData.__centroid);

            let attempts = 0;
            const maxAttempts = 50;
            let finalPosition = position.clone();

            while (attempts < maxAttempts) {
                let collision = false;

                for (const existing of existingPositions) {
                    const distance = finalPosition.distanceTo(existing);
                    if (distance < minDistance) {
                        collision = true;
                        // Move away from collision by pushing in a random direction
                        const pushDirection = finalPosition.clone().sub(existing).normalize();
                        if (pushDirection.length() === 0) {
                            // If positions are identical, push in random direction
                            pushDirection.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                        }
                        finalPosition.add(pushDirection.multiplyScalar(minDistance - distance + 0.5));
                        break;
                    }
                }

                if (!collision) break;
                attempts++;
            }

            console.log(`Collision avoidance: ${attempts} attempts, final position:`, finalPosition.toArray());
            return finalPosition;
        }

        function createTetraInstanceFromE8Data(d) {
            const validMeshes = window.tetraMeshes?.filter(m => m?.instanceMatrix && typeof m.count === 'number') || [];
            if (validMeshes.length === 0) return;
            const base3 = baseCenter3(d);
            const color = pastelFromMetrics(d);
            console.log(`Creating tetra for ${extractLabel(d)} at position:`, base3, 'with color:', color.getHexString(), 'HSL:', color.getHSL({})); // Debug position and color
            const scale = ratingScale(d);
            const { axis, speed } = seededAxisSpeed(extractLabel(d));
            const initQ = axisAngleQuat(axis, speed * 30.0 * GLOBAL_ROTATION_SPEED_MULTIPLIER);

            // Use actual coordinates directly instead of lattice points
            let center = new THREE.Vector3(...base3);

            // Apply appropriate scaling based on coordinate magnitude to prevent overlapping
            const magnitude = center.length();
            if (magnitude < 1.0) {
                // If coordinates are very small, scale them up significantly
                center.multiplyScalar(15);
            } else if (magnitude < 5.0) {
                // If coordinates are small, scale them up moderately  
                center.multiplyScalar(3);
            }
            // If magnitude >= 5.0, use coordinates as-is for good separation

            // Apply collision avoidance to ensure no overlapping
            center = avoidCollisions(center, scale * 4); // Minimum distance based on tetrahedron scale

            // Create tetrahedron starting at very small scale for smooth entry animation
            const tinyScale = new THREE.Vector3(0.01, 0.01, 0.01); // Start tiny
            const initialMatrix = new THREE.Matrix4().compose(center, initQ.clone(), tinyScale);

            d.__initQ = initQ.clone(); d.__axis = axis.clone(); d.__speed = speed; d.__scale = scale;
            d.__affine = new THREE.Matrix4().compose(center, initQ.clone(), new THREE.Vector3(scale, scale, scale));
            d.__centroid = center.clone();

            const globalIndex = addTetraInstance(d.node_id, initialMatrix, color, 0, VEC_Z, center.clone());
            if (globalIndex >= 0) {
                const inst = tetraInstanceData[globalIndex];
                if (inst) {
                    inst.fullData = d;
                    inst.rotAxis = axis.clone();

                    // Start smooth entry animation - grow from tiny to full scale
                    console.log(`[createTetra] Starting entry animation for ${extractLabel(d)}`);
                    smoothUpdateTetraPosition(inst, center, initQ.clone(), scale, 1000); // 1 second growth
                }
            }
        }
        function updateTetraInstanceFromE8Data(inst, d) {
            if (!inst) return;
            inst.omega = calculateRotorSpeed(d);
            inst.axis3 = new THREE.Vector3(...(d.rotor_axis || [0, 1, 0])).normalize();
            inst.fullData = d;
            const base3 = baseCenter3(d);

            // Recalculate color based on current data (important for type-based coloring)
            const color = pastelFromMetrics(d);
            console.log(`Updating tetra ${extractLabel(d)} with color:`, color.getHexString(), 'type:', d.type || d.fullData?.type || 'unknown');

            // Use actual coordinates directly instead of lattice points
            let center = new THREE.Vector3(...base3);

            // Apply appropriate scaling based on coordinate magnitude to prevent overlapping
            const magnitude = center.length();
            if (magnitude < 1.0) {
                // If coordinates are very small, scale them up significantly
                center.multiplyScalar(15);
            } else if (magnitude < 5.0) {
                // If coordinates are small, scale them up moderately  
                center.multiplyScalar(3);
            }
            // If magnitude >= 5.0, use coordinates as-is for good separation

            // Apply collision avoidance to ensure no overlapping during updates
            const currentScale = d.__scale || 1;
            center = avoidCollisions(center, currentScale * 4);

            const existingQuat = d.__initQ || new THREE.Quaternion();
            const scl = new THREE.Vector3(d.__scale || 1, d.__scale || 1, d.__scale || 1);

            d.__centroid = center.clone();
            d.__scale = currentScale;

            // Check if position has changed significantly to warrant a smooth transition
            const currentMatrix = new THREE.Matrix4();
            inst.mesh.getMatrixAt(inst.index, currentMatrix);
            const currentPos = new THREE.Vector3();
            currentMatrix.decompose(currentPos, new THREE.Quaternion(), new THREE.Vector3());

            const distanceMoved = currentPos.distanceTo(center);
            const MOVEMENT_THRESHOLD = 0.5; // Minimum distance to trigger smooth transition

            // Don't start position transitions if there's already an active transition
            const hasActiveTransition = tetraTransitions.has(inst.globalIndex);

            if (distanceMoved > MOVEMENT_THRESHOLD && !hasActiveTransition) {
                // Use smooth transition for significant position changes
                console.log(`[smoothUpdate] Tetra ${extractLabel(d)} moved ${distanceMoved.toFixed(2)} units - using smooth transition`);

                // Apply rotation state if available (preserve gyroscopic motion)
                const currentRotQuat = tetraRotationState.current.get(inst.globalIndex) || existingQuat;

                // Start smooth transition to new position
                smoothUpdateTetraPosition(inst, center, currentRotQuat, currentScale, 600);

                // Use smooth color transition as well
                smoothUpdateTetraColor(inst, color, 400);

            } else {
                // For small changes, update immediately (no transition needed)
                try {
                    const currentQuat = tetraRotationState.current.get(inst.globalIndex) || existingQuat;
                    const c = d.__centroid;
                    const Tto = new THREE.Matrix4().makeTranslation(c.x, c.y, c.z);
                    const Tfrom = new THREE.Matrix4().makeTranslation(-c.x, -c.y, -c.z);
                    const R = new THREE.Matrix4().makeRotationFromQuaternion(currentQuat);
                    TMP_M.identity().multiply(Tto).multiply(R).multiply(Tfrom).multiply(new THREE.Matrix4().compose(center, existingQuat, scl));
                    inst.mesh.setMatrixAt(inst.index, TMP_M);

                    // Update the color as well
                    if (inst.mesh.instanceColor) {
                        inst.mesh.setColorAt(inst.index, color);
                        inst.mesh.instanceColor.needsUpdate = true;
                    }
                    inst.color = color;

                    inst.mesh.instanceMatrix.needsUpdate = true;
                } catch (e) { }
            }
        }
        function pastelFromMetrics(d) {
            const r = (typeof d.rating === 'number') ? Math.max(0, Math.min(1, d.rating)) : 0.5;
            const sdim = d.shell_dim || 8;
            const id = extractLabel(d);
            let idHashNum = 0;
            for (let i = 0; i < id.length; i++) idHashNum = ((idHashNum << 5) - idHashNum + id.charCodeAt(i)) & 0xffffffff;
            const idHash = Math.abs(idHashNum) / 0xffffffff;

            // Type-based color scheme for different memory/concept types
            const conceptType = d.type || d.fullData?.type || 'unknown';
            console.log(`pastelFromMetrics - Node: ${extractLabel(d)}, Type: ${conceptType}, Full data keys:`, Object.keys(d || {}));
            const typeColors = {
                // Cognitive types - blues and teals
                'monologue_thought': { r: 0.3, g: 0.6, b: 1.0 },      // Bright blue
                'phase_summary': { r: 0.2, g: 0.8, b: 0.9 },          // Cyan
                'reflection': { r: 0.4, g: 0.7, b: 0.8 },             // Light blue

                // Knowledge types - greens 
                'concept': { r: 0.2, g: 0.9, b: 0.3 },                // Bright green
                'insight': { r: 0.3, g: 0.8, b: 0.2 },                // Forest green
                'hypothesis': { r: 0.5, g: 0.9, b: 0.4 },             // Light green

                // Memory types - purples and magentas
                'memory': { r: 0.8, g: 0.3, b: 0.9 },                 // Magenta
                'consolidation': { r: 0.6, g: 0.2, b: 0.8 },          // Purple
                'remnant': { r: 0.7, g: 0.4, b: 0.9 },                // Light purple

                // External/API types - oranges and yellows
                'arxiv_api': { r: 1.0, g: 0.6, b: 0.2 },              // Orange
                'pubmed_api': { r: 1.0, g: 0.8, b: 0.3 },             // Yellow-orange
                'json_api': { r: 0.9, g: 0.9, b: 0.2 },               // Yellow

                // Analysis types - reds and pinks
                'emergence': { r: 1.0, g: 0.3, b: 0.3 },              // Red
                'validation': { r: 1.0, g: 0.5, b: 0.6 },             // Pink
                'meta': { r: 0.9, g: 0.4, b: 0.5 },                   // Rose

                // Default/unknown - gray-white
                'unknown': { r: 0.7, g: 0.7, b: 0.7 }                 // Gray
            };

            // Get base color from type, fallback to shell-based if type unknown
            let baseColor = typeColors[conceptType];
            if (!baseColor) {
                // Fallback to shell-based RGBY colors if type not recognized
                const rgbyColors = [
                    { r: 1.0, g: 0.2, b: 0.2 }, // Red
                    { r: 0.2, g: 1.0, b: 0.2 }, // Green  
                    { r: 0.2, g: 0.2, b: 1.0 }, // Blue
                    { r: 1.0, g: 1.0, b: 0.2 }  // Yellow
                ];
                const colorIndex = Math.floor((sdim - 8) / 8) % 4;
                baseColor = rgbyColors[colorIndex] || rgbyColors[0];
            }

            // Apply rating-based brightness modulation - enhanced for better glow
            const brightness = 0.7 + (r * 0.3); // Rating affects brightness from 0.7 to 1.0

            // Use mantle tension for dynamic effects
            const tensionMod = state.mantle ? (state.mantle.tension || 0.7) : 0.7;
            const tensionFactor = Math.max(0.7, Math.min(1.3, tensionMod / 0.7)); // Normalize around 0.7

            // Add slight color variation based on ID hash for uniqueness
            const variation = (idHash - 0.5) * 0.12; // ±6% variation

            // Enhanced color saturation for better glow effects
            const saturationBoost = 1.2; // 20% more saturated colors
            const finalR = Math.max(0.15, Math.min(1.0, (baseColor.r * brightness * saturationBoost + variation) * tensionFactor));
            const finalG = Math.max(0.15, Math.min(1.0, (baseColor.g * brightness * saturationBoost + variation) * tensionFactor));
            const finalB = Math.max(0.15, Math.min(1.0, (baseColor.b * brightness * saturationBoost + variation) * tensionFactor));

            return new THREE.Color(finalR, finalG, finalB);
        }
        function centroid(points) {
            const sum = new THREE.Vector3();
            points.forEach(p => sum.add(p));
            return sum.divideScalar(points.length);
        }
        function tetraVolume(a, b, c, d) {
            if (!a || !b || !c || !d) return 0;
            const ba = b.clone().sub(a), ca = c.clone().sub(a), da = d.clone().sub(a);
            return Math.abs(ba.dot(ca.clone().cross(da))) / 6;
        }
        function upsertInsightTetra(tetraData) {
            if (!tetraInitialized || !tetraMeshesReady || !window.tetraMeshes?.length) return;
            const validMeshes = window.tetraMeshes.filter(m => m?.instanceMatrix && typeof m.count === 'number');
            if (validMeshes.length === 0) return;
            const nodeId = tetraData.node_id;
            const globalIndex = tetraIndexById.get(nodeId);
            if (globalIndex !== undefined && tetraInstanceData[globalIndex]) {
                updateTetraInstanceFromE8Data(tetraInstanceData[globalIndex], tetraData);
                updateTetrahedronTargets();
            } else {
                createTetraInstanceFromE8Data(tetraData);
                setTimeout(() => updateTetrahedronTargets(), 100);
            }
        }
        function calculateRotorSpeed(d) {
            const r = d.rating || 0, sdim = d.shell_dim || 8, axis = d.rotor_axis || [0, 1, 0];
            let speed = Math.min(Math.max(r, 0), 1) * 0.3 + 0.1;
            speed *= (sdim / 8.0);
            speed *= Math.max(Math.sqrt(axis[0] ** 2 + axis[1] ** 2 + axis[2] ** 2), 0.5);
            return speed * GLOBAL_ROTATION_SPEED_MULTIPLIER;
        }

        // Function to update tetrahedron targets based on current rotor state
        function updateTetrahedronTargets() {
            // Update rotation state for all tetra instances based on current rotor state
            tetraInstanceData.forEach(inst => {
                if (inst.rotAxis) {
                    const currentQuat = tetraRotationState.current.get(inst.globalIndex) || new THREE.Quaternion();
                    tetraRotationState.current.set(inst.globalIndex, currentQuat);
                }
            });
        }
        async function fetchCognitiveState() {
            try {
                console.log('[api] Fetching cognitive state from:', `${API_BASE_URL}/api/state`);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                const res = await fetch(`${API_BASE_URL}/api/state`, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });

                clearTimeout(timeoutId);

                if (!res.ok) {
                    console.warn(`[api] State fetch failed: HTTP ${res.status} ${res.statusText}`);
                    return null;
                }

                const state = await res.json();
                console.log('[api] Cognitive state fetched successfully');
                window.latestCognitiveState = state;

                if (state.telemetry?.shells) {
                    const shells = Object.values(state.telemetry.shells);
                    if (shells.length > 0) {
                        const ps = shells[0];
                        if (ps.orientation) {
                            const yaw = ps.orientation.yaw || 0, omega = ps.omega || 0.5;
                            const axis = new THREE.Vector3(Math.cos(yaw), Math.sin(yaw), 0.3 * Math.sin(window.__frameCounter * 0.01)).normalize();
                            const angle = omega * (window.__frameCounter || 0) * 0.05 * GLOBAL_ROTATION_SPEED_MULTIPLIER;
                            state.rotor = { axis: axis, angle, omega, shells_data: shells };
                        }
                    }
                }
                if (state.telemetry) {
                    const tel = state.telemetry;
                    if (!state.rotor) state.rotor = {};
                    state.rotor.learningMetrics = {
                        novelty: tel.novelty || 0,
                        compression: tel.compression || 0,
                        disagreement: tel.disagreement || 0,
                        timestamp: Date.now()
                    };
                }
                return state;
            } catch (e) { return null; }
        }
        let lastRotorState = null;
        setInterval(() => {
            fetchCognitiveState().then(newState => {
                if (newState?.rotor) {
                    const currentRotorHash = JSON.stringify(newState.rotor);
                    if (currentRotorHash !== lastRotorState) {
                        lastRotorState = currentRotorHash;
                        updateTetrahedronTargets();
                        if (newState.rotor.shells_data) updateRotorState(newState.rotor.shells_data);
                    }
                } else updateRotorState(null);
            });
        }, 1000);
        function animateTetras(now) {
            if (!tetraInitialized || !tetraScene || !tetraRenderer || !tetraCamera) return;
            animateOrganicCrystalEffects(now * 0.001);
            animateTetrahedronRotations();
            if (window.__tetraControls) window.__tetraControls.update();
            throttledTweenUpdate(now);
            if (composer?.render) try { composer.render(); } catch (e) { }
        }
        function animateOrganicCrystalEffects(time) {
            // Animate glow effects on all tetrahedron materials
            if (window.tetraMeshes) {
                window.tetraMeshes.forEach(mesh => {
                    if (mesh && mesh.material && mesh.material.userData) {
                        animateOrganicCrystalGlow(mesh.material, time);
                    }
                });
            }
        }
        function createGearRotationProfile(index) {
            const types = ['clockwork', 'industrial', 'precision', 'chaotic', 'synchronized'];
            const type = types[index % types.length];
            switch (type) {
                case 'clockwork': return { speedPattern: 'steady', directionChanges: 'periodic', acceleration: 'smooth', stepSize: 0.05, baseSpeed: 0.6, speedVariation: 0.3 };
                case 'industrial': return { speedPattern: 'heavy', directionChanges: 'abrupt', acceleration: 'jerky', stepSize: 0.15, baseSpeed: 0.4, speedVariation: 0.8 };
                case 'precision': return { speedPattern: 'precise', directionChanges: 'calculated', acceleration: 'linear', stepSize: 0.02, baseSpeed: 0.8, speedVariation: 0.2 };
                case 'chaotic': return { speedPattern: 'erratic', directionChanges: 'random', acceleration: 'explosive', stepSize: 0.25, baseSpeed: 0.3, speedVariation: 1.2 };
                case 'synchronized': return { speedPattern: 'harmonic', directionChanges: 'synchronized', acceleration: 'wave', stepSize: 0.08, baseSpeed: 0.7, speedVariation: 0.5 };
            }
        }
        // Simplified tetrahedron rotation - replaced complex gear system
        function animateTetrahedronRotations() {
            if (!tetraInitialized || !window.tetraMeshes) return;

            const deltaTime = clock.getDelta();
            const time = performance.now() * 0.001;
            const total = tetraInstanceData.length;
            if (total === 0) return;

            // Batch updates to avoid long-running loops in a single frame
            const maxPerFrame = Math.max(8, Math.min(2000, Number(state.tetraMaxPerFrame) || 200));
            const start = state.tetraUpdateIndex % total;
            const end = Math.min(total, start + maxPerFrame);
            const touchedMeshes = new Set();

            for (let i = start; i < end; i++) {
                const inst = tetraInstanceData[i];
                if (!inst || !inst.fullData || !inst.mesh) continue;

                const rating = inst.fullData.rating || 0.5;
                const baseRotSpeed = (rating * 2.0 + 0.5) * GLOBAL_ROTATION_SPEED_MULTIPLIER;
                const curvatureMod = state.mantle ? (state.mantle.curvature || 6.0) : 6.0;
                const curvatureFactor = Math.max(0.3, Math.min(3.0, curvatureMod / 6.0));
                const rotSpeed = baseRotSpeed * curvatureFactor;

                const rotX = Math.sin(time * rotSpeed * 0.7) * 0.5 * curvatureFactor;
                const rotY = time * rotSpeed;
                const rotZ = Math.cos(time * rotSpeed * 0.3) * 0.3 * curvatureFactor;

                const quat = new THREE.Quaternion();
                quat.setFromEuler(new THREE.Euler(rotX, rotY, rotZ));

                try {
                    if (inst.fullData.__centroid && inst.fullData.__affine) {
                        const pos = inst.fullData.__centroid;
                        const scale = inst.fullData.__scale || inst.fullData.scale || 1.0;
                        // Reuse TMP_M if available for temporary matrix operations
                        const matrix = (typeof TMP_M !== 'undefined' && TMP_M) ? TMP_M.identity() : new THREE.Matrix4();
                        const scl = new THREE.Vector3(scale, scale, scale);

                        // Debug: log position info
                        if (i % 50 === 0) { // Log every 50th tetra to avoid spam
                            console.log(`Animating tetra ${i}: pos=`, pos, 'scale=', scale);
                        }

                        matrix.compose(pos, quat, scl);
                        inst.mesh.setMatrixAt(inst.index, matrix);
                        touchedMeshes.add(inst.mesh);
                    }
                } catch (e) { }
            }

            // Advance index for next frame
            state.tetraUpdateIndex = (end >= total) ? 0 : end;

            // Mark only touched meshes as needing update
            touchedMeshes.forEach(mesh => {
                try {
                    if (mesh.instanceMatrix) mesh.instanceMatrix.needsUpdate = true;
                    if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
                } catch (e) { }
            });
        }
        let hoveredInstance = null, selectedInstance = null, graphCache = null;
        {
            const st = document.createElement('style');
            st.textContent = `
        #insightPopup { position: fixed; z-index: 1000; display: none; min-width: 260px; max-width: 360px; padding: 12px 14px; border-radius: 14px; border: 1px solid var(--border-color); background: var(--glass); backdrop-filter: blur(8px); box-shadow: 0 12px 40px rgba(0,0,0,0.35); color: var(--fg); font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        #insightPopup .title { font-weight: 600; margin-bottom: 6px; }
        #insightPopup .row { display:flex; justify-content:space-between; gap:8px; margin:2px 0; }
            #insightPopup .row .k { opacity: .7 }
            #insightPopup .chips { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px }
            #insightPopup .chip { padding:4px 8px; border-radius:999px; border:1px solid var(--border-color); opacity:.9; background: var(--glass-2); }
          `;
            document.head.appendChild(st);
        }
        const popup = document.createElement('div');
        popup.id = 'insightPopup';
        document.body.appendChild(popup);
        const hoverScaleTransitions = new Map(); // Track hover scale transitions

        function setInstanceScale(inst, targetScale, duration = 200) {
            if (!inst || !inst.fullData?.__centroid) return;

            const globalIndex = inst.globalIndex;

            // Cancel existing hover transition
            const existingTween = hoverScaleTransitions.get(globalIndex);
            if (existingTween) {
                existingTween.stop();
                hoverScaleTransitions.delete(globalIndex);
            }

            // Get current scale
            const currentMatrix = new THREE.Matrix4();
            inst.mesh.getMatrixAt(inst.index, currentMatrix);

            const currentPos = new THREE.Vector3();
            const currentQuat = new THREE.Quaternion();
            const currentScale = new THREE.Vector3();
            currentMatrix.decompose(currentPos, currentQuat, currentScale);

            // Use the magnitude as the current scale (assuming uniform scaling)
            const currentScaleValue = currentScale.x;

            // Create smooth scale transition
            const scaleInterpolation = { scale: currentScaleValue };

            const scaleTween = createTween(scaleInterpolation)
                .to({ scale: targetScale }, duration)
                .easing(TWEEN.Easing.Cubic.Out)
                .onUpdate(() => {
                    try {
                        const s = scaleInterpolation.scale;
                        const baseScale = inst.fullData.__scale || 1.0;

                        // Apply scaling relative to base scale
                        const finalScale = new THREE.Vector3(baseScale * s, baseScale * s, baseScale * s);
                        const matrix = new THREE.Matrix4().compose(currentPos, currentQuat, finalScale);

                        inst.mesh.setMatrixAt(inst.index, matrix);
                        inst.mesh.instanceMatrix.needsUpdate = true;
                    } catch (e) {
                        console.warn('[setInstanceScale] Scale update failed:', e);
                    }
                })
                .onComplete(() => {
                    hoverScaleTransitions.delete(globalIndex);
                })
                .start();

            hoverScaleTransitions.set(globalIndex, scaleTween);
            return scaleTween;
        }
        function setInstanceColor(inst, hex) {
            if (!inst) return;
            inst.mesh.setColorAt(inst.index, new THREE.Color(hex));
            if (inst.mesh.instanceColor) inst.mesh.instanceColor.needsUpdate = true;
        }
        function restoreInstanceColor(inst) {
            if (!inst) return;
            inst.mesh.setColorAt(inst.index, inst.color);
            if (inst.mesh.instanceColor) inst.mesh.instanceColor.needsUpdate = true;
        }
        async function loadGraph() {
            if (graphCache) return graphCache;
            try {
                const res = await fetch(`${API_BASE_URL}/api/graph`, { cache: 'no-store' });
                if (!res.ok) throw new Error(String(res.status));
                graphCache = await res.json();
            } catch (e) { graphCache = { nodes: [], links: [] }; }
            return graphCache;
        }
        async function nodeDetails(nodeId) {
            // Try to get detailed node info first
            let node = null;
            try {
                const nodeRes = await fetch(`${API_BASE_URL}/api/node/${nodeId}`, { cache: 'no-store' });
                if (nodeRes.ok) {
                    const nodeData = await nodeRes.json();
                    if (nodeData && nodeData.node) {
                        node = nodeData.node;
                    }
                }
            } catch (e) {
                console.log('Node-specific endpoint not available, falling back to graph');
            }

            // Fallback to graph data if node endpoint doesn't exist
            if (!node) {
                const g = await loadGraph();
                node = (g.nodes || []).find(n => n.id === nodeId || n.node_id === nodeId) || {};
            }

            // Get neighbors from graph
            const g = await loadGraph();
            const links = (g.links || []).filter(l => (l.source === nodeId || l.target === nodeId));
            const neighborIds = links.map(l => l.source === nodeId ? l.target : l.source);
            const neighbors = neighborIds.map(id => (g.nodes || []).find(n => n.id === id || n.node_id === id)).filter(Boolean).slice(0, 8);
            return { node, links, neighbors };
        }
        function showPopupAt(x, y, html) {
            popup.innerHTML = html;
            popup.style.left = `${x + 12}px`;
            popup.style.top = `${y + 12}px`;
            popup.style.display = 'block';
        }
        function hidePopup() { popup.style.display = 'none'; }
        function getHoveredInstance() {
            if (!window.tetraMeshes) return null;
            raycaster.setFromCamera(mouse, tetraCamera);
            const hits = raycaster.intersectObjects(window.tetraMeshes, false);
            if (hits.length > 0 && hits[0].instanceId !== undefined) {
                const hit = hits[0];
                return tetraInstanceData.find(d => d.mesh === hit.object && d.index === hit.instanceId);
            }
            return null;
        }
        function onPointerMove(ev) {
            const rect = DOM.tetraCanvas.getBoundingClientRect();
            mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            const inst = getHoveredInstance();
            if (inst !== hoveredInstance) {
                if (hoveredInstance && hoveredInstance !== selectedInstance) { setInstanceScale(hoveredInstance, 1.0); restoreInstanceColor(hoveredInstance); }
                hoveredInstance = inst;
                if (hoveredInstance && hoveredInstance !== selectedInstance) { setInstanceScale(hoveredInstance, 1.10); setInstanceColor(hoveredInstance, 0xffffff); }
            }
        }
        async function onClick(ev) {
            const rect = DOM.tetraCanvas.getBoundingClientRect();
            mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            const inst = getHoveredInstance();
            if (!inst) { hidePopup(); return; }
            if (selectedInstance) { setInstanceScale(selectedInstance, 1.0); restoreInstanceColor(selectedInstance); }
            selectedInstance = inst;
            setInstanceScale(selectedInstance, 1.20);
            setInstanceColor(selectedInstance, 0x9ad5ff);
            const { node, neighbors } = await nodeDetails(inst?.id || inst?.fullData?.node_id || inst?.fullData?.id);
            // --- Build friendly popup content with smart fallbacks ---
            const resolveString = (...cands) => {
                for (const s of cands) {
                    if (typeof s === 'string') {
                        const t = s.trim();
                        if (t.length) return t;
                    }
                }
                return null;
            };
            const rawId = node?.node_id || node?.id || inst?.id;
            const shortId = (id) => {
                if (!id) return '-';
                const str = String(id);
                const m = str.match(/(?:insight|node|id|n)[-_]?(\d+)/i);
                if (m) return `#${m[1]}`;
                return str.length > 12 ? `…${str.slice(-8)}` : str;
            };
            // Type: prefer node.type else instance fullData.type; title-case it
            const typRaw = resolveString(node?.type, inst?.fullData?.type);
            const typ = typRaw ? (typRaw.charAt(0).toUpperCase() + typRaw.slice(1)) : null;
            // Title: label/title/name, else snippet from text/content, else fallback to "<Type> <shortId>"
            const titlePrimary = resolveString(node?.label, node?.title, node?.name, inst?.fullData?.label);
            let title = titlePrimary;
            if (!title) {
                const content = resolveString(node?.text, node?.content, node?.summary);
                if (content) {
                    title = content.slice(0, 64);
                    if (content.length > 64) title += '…';
                } else {
                    title = `${typ || 'Concept'} ${shortId(rawId)}`;
                }
            }
            // Rating: show only if numeric
            const ratingVal = Number(node?.rating);
            const rating = Number.isFinite(ratingVal) ? ratingVal.toFixed(2) : null;
            // Neighbor chips (limit for readability)
            const chipList = Array.isArray(neighbors) ? neighbors.slice(0, 12) : [];
            const chips = chipList.map(n => `<span class="chip">${escapeHTML(n.label || n.name || n.id || shortId(n?.node_id || n?.id))}</span>`).join('');
            // Assemble rows conditionally (hide empty entries)
            const rows = [];
            if (typ) rows.push(`<div class="row"><span class="k">Type</span><span>${escapeHTML(typ)}</span></div>`);
            if (rating !== null) rows.push(`<div class="row"><span class="k">Rating</span><span>${escapeHTML(rating)}</span></div>`);

            // Show shell dimension if available
            const shellDim = node?.shell_dim || inst?.fullData?.shell_dim;
            if (shellDim) rows.push(`<div class="row"><span class="k">Shell</span><span>${shellDim}D</span></div>`);

            // Show step number if available
            const stepNum = node?.step || node?.last_step;
            if (stepNum !== undefined) rows.push(`<div class="row"><span class="k">Step</span><span>#${stepNum}</span></div>`);

            // Show metaphor/content preview if available
            const metaphor = resolveString(node?.metaphor, node?.content, node?.text);
            if (metaphor && metaphor !== title) {
                const preview = metaphor.length > 100 ? metaphor.slice(0, 97) + '…' : metaphor;
                rows.push(`<div class="row"><span class="k">Content</span><span title="${escapeHTML(metaphor)}">${escapeHTML(preview)}</span></div>`);
            }

            if (rawId) rows.push(`<div class="row"><span class="k">Node</span><span title="${escapeHTML(String(rawId))}"><code>${escapeHTML(shortId(rawId))}</code></span></div>`);
            if (Array.isArray(neighbors) && neighbors.length > 0) rows.push(`<div class="row"><span class="k">Connections</span><span>${neighbors.length}</span></div>`);

            const html = `
                <div class="title">${escapeHTML(title)}</div>
                ${rows.join('')}
                ${chips ? `<div class="chips">${chips}</div>` : ''}
            `;
            showPopupAt(ev.clientX, ev.clientY, html);
            if (inst.fullData?.__centroid && window.__tetraControls) {
                const target = inst.fullData.__centroid.clone();
                const cam = tetraCamera, ctrl = window.__tetraControls;
                const startPos = cam.position.clone();
                const endPos = target.clone().add(new THREE.Vector3(0, 0, 9));
                createTween({ t: 0 }).to({ t: 1 }, 650).easing(typeof TWEEN !== 'undefined' && TWEEN.Easing ? TWEEN.Easing.Cubic.InOut : t => t).onUpdate(o => {
                    cam.position.lerpVectors(startPos, endPos, o.t);
                    ctrl.target.lerpVectors(ctrl.target, target, o.t);
                    ctrl.update();
                }).start();
            }
        }
        DOM.tetraCanvas.addEventListener('pointermove', onPointerMove);
        DOM.tetraCanvas.addEventListener('click', onClick);
        window.addEventListener('scroll', hidePopup, { passive: true });
        window.addEventListener('resize', hidePopup, { passive: true });

        function escapeHTML(str) { return String(str ?? '').replace(/[&<>"']/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[s]); }
        function num(v, fallback = 0) { const n = Number(v); return Number.isFinite(n) ? n : fallback; }
        function clamp01(v) { return Math.max(0, Math.min(1, num(v, 0))); }

        // Safe DOM update helper functions
        function safeUpdateElement(element, property, value, errorContext = '') {
            try {
                if (element && element[property] !== undefined) {
                    element[property] = value;
                    return true;
                }
            } catch (e) {
                console.warn(`[dom] Failed to update ${errorContext}:`, e);
            }
            return false;
        }

        function safeSetText(element, text, errorContext = '') {
            return safeUpdateElement(element, 'textContent', String(text || ''), errorContext);
        }

        function safeSetStyle(element, property, value, errorContext = '') {
            try {
                if (element && element.style) {
                    element.style[property] = value;
                    return true;
                }
            } catch (e) {
                console.warn(`[dom] Failed to update style ${errorContext}:`, e);
            }
            return false;
        }
        function asArray(x) {
            if (x == null) return []; if (Array.isArray(x)) return x;
            if (typeof x === 'string') return x.trim() ? [x] : [];
            if (typeof x === 'object') return Object.entries(x).map(([k, v]) => `${k}: ${typeof v === 'object' ? JSON.stringify(v) : v}`);
            return [String(x)];
        }
        function renderList(elem, data, { boxed = true } = {}) {
            if (!elem) return;

            try {
                const rows = asArray(data).slice(-200);
                if (!rows.length) {
                    safeUpdateElement(elem, 'innerHTML', '<div class="weather-box" style="opacity: 0.5;"><div class="row"><span class="value">Awaiting data...</span></div></div>', 'list empty state');
                    return;
                }
                const content = rows.map(line => boxed ?
                    `<div class="weather-box" style="margin-bottom:6px;"><div class="row" style="align-items:flex-start;"><span class="label" style="opacity:0.6;">*</span><span class="value" style="white-space:pre-wrap;text-align:left">${escapeHTML(line)}</span></div></div>` :
                    `<div style="white-space:pre-wrap">${escapeHTML(line)}</div>`
                ).join('');
                safeUpdateElement(elem, 'innerHTML', content, 'list content');
            } catch (error) {
                console.warn('[ui] renderList failed:', error);
                safeSetText(elem, 'Error loading list data', 'list error');
            }
        }
        function lerp(a, b, t) { return a + (b - a) * t; }
        const __ringColorCache = new Map();
        function _resolveRingColor(colorVar) {
            if (!colorVar || typeof colorVar !== 'string') return String(colorVar || '#ffffff');
            if (!colorVar.startsWith('--')) return colorVar;
            if (__ringColorCache.has(colorVar)) return __ringColorCache.get(colorVar);
            try {
                const v = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim() || '#ffffff';
                __ringColorCache.set(colorVar, v);
                return v;
            } catch (e) {
                return '#ffffff';
            }
        }
        function drawRing(canvas, val, colorVar = '--accent') {
            try {
                if (!canvas) return;
                const ctx = (typeof canvas.getContext === 'function') ? canvas.getContext('2d') : null;
                if (!ctx) return;
                const w = canvas.width || canvas.clientWidth || 0;
                const h = canvas.height || canvas.clientHeight || 0;
                if (!w || !h) return;
                const v = clamp01(val);
                const color = _resolveRingColor(colorVar);

                ctx.clearRect(0, 0, w, h);
                ctx.lineWidth = 6;
                ctx.strokeStyle = "rgba(255,255,255,0.08)";
                ctx.beginPath(); ctx.arc(w / 2, h / 2, Math.max(0, (Math.min(w, h) / 2) - 4), 0, 2 * Math.PI); ctx.stroke();
                if (v > 0) {
                    ctx.strokeStyle = color;
                    ctx.beginPath(); ctx.arc(w / 2, h / 2, Math.max(0, (Math.min(w, h) / 2) - 4), -0.5 * Math.PI, -0.5 * Math.PI + v * 2 * Math.PI); ctx.stroke();
                }
            } catch (e) {
                // Swallow exceptions to avoid uncaught errors causing script termination
                console.warn('drawRing error', e);
            }
        }
        function sparkline(elem, values, maxPoints = 64) {
            const canvas = elem.querySelector('canvas') || (() => { const c = document.createElement('canvas'); c.width = 140; c.height = 40; elem.innerHTML = ''; elem.appendChild(c); return c; })();
            const ctx = canvas.getContext('2d'), w = canvas.width, h = canvas.height;
            if (values.length > maxPoints) values.splice(0, values.length - maxPoints);
            ctx.clearRect(0, 0, w, h);
            if (!Array.isArray(values) || values.length < 2) return;
            const safeVals = values.map(v => num(v, 0));
            const minVal = Math.min(...safeVals), maxVal = Math.max(...safeVals), range = (maxVal - minVal) || 1;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            ctx.lineWidth = 1.5; ctx.beginPath();
            for (let i = 0; i < safeVals.length; i++) {
                const x = (i / (safeVals.length - 1)) * w;
                const y = h - ((safeVals[i] - minVal) / range) * (h - 6) - 3;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        function __clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function unwrapAngle(curr, prev) {
            if (prev == null) return curr;
            let a = curr;
            while (a - prev > Math.PI) a -= Math.PI * 2;
            while (a - prev < -Math.PI) a += Math.PI * 2;
            return a;
        }
        function parseOrientationToYaw(o) {
            if (!o) return null; if (typeof o === 'number') return o; if (typeof o.yaw === 'number') return o.yaw;
            if (typeof o.x === 'number') { const { x, y, z, w } = o; return Math.atan2(2 * (w * y + z * x), 1 - 2 * (y * y + x * x)); }
            return null;
        }
        function updateRotorState(shellsData) {
            if (!shellsData) { Object.values(state.rotors).forEach(r => { if (!r.baseSpin) r.baseSpin = 0.005; }); return; }
            const tensions = state.currentTelemetry?.shell_tensions || {};
            const now = performance.now() * 0.001;
            for (const dim in shellsData) {
                const sd = shellsData[dim];
                const rotor = state.rotors[dim] || (state.rotors[dim] = { angle: Math.random() * Math.PI * 2, angleTarget: null, angleVelocity: 0, speed: 0, speedTarget: 0, speedVelocity: 0, lastAngleFromOri: null, lastUpdate: null, interpolationStart: null, interpolationDuration: 0.55 });
                const yaw = parseOrientationToYaw(sd.orientation), omega = sd.omega;
                if (yaw != null) {
                    if (rotor.lastAngleFromOri == null) {
                        rotor.lastAngleFromOri = yaw; rotor.lastUpdate = now; rotor.angle = rotor.angleTarget = yaw; rotor.interpolationStart = now;
                    } else {
                        const dtObs = Math.max(1e-3, now - rotor.lastUpdate);
                        const unwrapped = unwrapAngle(yaw, rotor.lastAngleFromOri);
                        const observedOmega = (unwrapped - rotor.lastAngleFromOri) / dtObs;
                        rotor.lastAngleFromOri = unwrapped; rotor.lastUpdate = now;
                        const rawOmega = (omega != null) ? 0.6 * observedOmega + 0.4 * __clamp(omega, -8, 8) : observedOmega;
                        const tensionGain = 1.0 + __clamp(Number(tensions[dim] ?? 0), 0, 10) * 0.05;
                        rotor.speedTarget = __clamp(rawOmega * tensionGain, -6, 6);
                        if (rotor.angleTarget == null || Math.abs(unwrapAngle(unwrapped, rotor.angleTarget)) > 0.12) {
                            rotor.angleTarget = unwrapAngle(unwrapped, rotor.angleTarget);
                            rotor.interpolationStart = now;
                        }
                    }
                } else if (omega != null) {
                    const tensionGain = 1.0 + __clamp(Number(tensions[dim] ?? 0), 0, 10) * 0.05;
                    rotor.speedTarget = __clamp(omega * tensionGain, -6, 6);
                    if (rotor.angleTarget == null) { rotor.angleTarget = rotor.angle; rotor.interpolationStart = now; }
                }
            }
        }

        function drawRotors(dt) { /* Stub - visualization removed */ }

        document.querySelectorAll('.tab-btn').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(`tab-${tabName}`).classList.add('active');
            });
        });

        // BH Panel helpers
        function renderBhPanel(p) {
            if (!p) return;
            const fmt = (x) => (typeof x === 'number' ? x.toFixed(6) : (x || '—'));
            const bhPanelEl = document.getElementById('bhPanel');
            if (bhPanelEl) {
                bhPanelEl.textContent =
                    `Q(t)      : ${fmt(p.q_t)}
sQ_global : ${fmt(p.sq)}
t′        : ${fmt(p.t_prime)}
Phase     : ${fmt(p.phase)}
Scale     : ${fmt(p.scale)}
Target    : ${fmt(p.target_compression)}
VAE β     : ${fmt(p.beta)}`;
            }
        }

        // BH Panel fallback poller
        async function pollBhPanel() {
            try {
                const r = await fetch(`${API_BASE_URL}/api/bh/panel`);
                if (r.ok) {
                    const data = await r.json();
                    renderBhPanel(data);
                }
            } catch (e) {
                console.debug('BH panel poll failed:', e);
            }
            setTimeout(pollBhPanel, 3000);
        }

        function updateUI(telemetry) {
            if (!telemetry) return;

            try {
                // Update basic telemetry fields with safe DOM operations
                safeSetText(DOM.wxMood, telemetry.symbolic_weather || '-', 'weather mood');
                safeSetText(DOM.wxRegion, telemetry.environment_theme || '-', 'weather region');

                // Update state targets
                state.targets.wxPressure = num(telemetry.black_hole_pressure, 0);
                const m = telemetry.mood || {};
                state.targets.moodIntensity = clamp01(m.intensity);
                state.targets.moodEntropy = clamp01(m.entropy);
                state.targets.moodCoherence = clamp01(m.coherence);
                state.targets.moodPositivity = clamp01(m.positivity);
                state.targets.moodFluidity = clamp01(m.fluidity);
                state.targets.moodIntelligibility = clamp01(m.intelligibility);
                state.targets.pressure = clamp01(telemetry.black_hole_pressure);
                state.targets.teacher = 1 - clamp01(num(telemetry.teacher_in, 0) / TEACHER_CYCLE_LENGTH);
                state.targets.explorer = 1 - clamp01(num(telemetry.explorer_in, 0) / TEACHER_CYCLE_LENGTH);
                state.targets.reward = clamp01(num(telemetry.insight_agent_avg_reward, 0));

                // Update goals list with error protection
                try {
                    const goals = telemetry.goals && typeof telemetry.goals === 'object' ? telemetry.goals : {};
                    const goalRows = Object.entries(goals).map(([k, v]) => `<div class="row"><span class="label">${escapeHTML(k)}</span><span class="value">${num(v, null) !== null ? num(v).toFixed(3) : escapeHTML(String(v))}</span></div>`).join('');
                    safeUpdateElement(DOM.goalsList, 'innerHTML', goalRows || '<div class="row"><span class="label">No goals</span><span class="value">-</span></div>', 'goals list');
                } catch (goalsError) {
                    console.warn('[ui] Goals update failed:', goalsError);
                    safeSetText(DOM.goalsList, 'Error loading goals', 'goals list error');
                }

                // Update teacher/explorer information
                safeSetText(DOM.teacherQuestion, telemetry.teacher_question || '-', 'teacher question');
                safeSetText(DOM.explorerAnswer, telemetry.explorer_answer || '-', 'explorer answer');
                safeSetText(DOM.encoderStatus, telemetry.autoencoder_trained ? 'Trained' : 'Untrained', 'encoder status');

                state.targets.globalTension = num(telemetry.global_tension, 0);

                // ***** MODIFICATION START: Logic for combined shell panel with error handling *****
                try {
                    const st = telemetry.shell_tensions || {};
                    const sp = telemetry.shell_population || {};
                    const allDims = new Set([...Object.keys(st), ...Object.keys(sp)]);

                    // Clear previous state safely
                    if (DOM.shellDynamicsGrid) {
                        safeUpdateElement(DOM.shellDynamicsGrid, 'innerHTML', '', 'shell dynamics grid clear');
                    }

                    [...allDims].sort((a, b) => num(a) - num(b)).forEach(dim => {
                        try {
                            let card = document.getElementById(`shell-card-${dim}`);
                            if (!card) {
                                card = document.createElement('div');
                                card.id = `shell-card-${dim}`;
                                card.className = 'shell-card';
                                if (DOM.shellDynamicsGrid) {
                                    DOM.shellDynamicsGrid.appendChild(card);
                                }
                            }
                            const tension = num(st[dim], 0);
                            const pop = num(sp[dim], 0);
                            const series = state.shellSparklines.get(dim) || [];
                            series.push(tension);
                            state.shellSparklines.set(dim, series);

                            safeUpdateElement(card, 'innerHTML', `
                                <div class="row"><span class="label">Shell ${escapeHTML(dim)}D</span><span class="value">Pop: ${pop}</span></div>
                                <div class="row"><span class="label">Tension</span><span class="value">${tension.toFixed(3)}</span></div>
                                <canvas></canvas>
                            `, `shell card ${dim}`);

                            try {
                                sparkline(card, series);
                            } catch (sparklineError) {
                                console.warn(`[ui] Sparkline for shell ${dim} failed:`, sparklineError);
                            }
                        } catch (shellError) {
                            console.warn(`[ui] Shell ${dim} update failed:`, shellError);
                        }
                    });
                } catch (shellsError) {
                    console.warn('[ui] Shells panel update failed:', shellsError);
                }
                // ***** MODIFICATION END *****
            } catch (error) {
                console.error('[ui] Critical error in updateUI:', error);
            }
        }

        function processTelemetry(telemetry) {
            if (!telemetry || typeof telemetry !== 'object') {
                console.warn('[telemetry] Invalid telemetry data received:', typeof telemetry);
                return;
            }

            // Initialize telemetry processing with error boundary
            try {
                state.currentTelemetry = telemetry;
                updateUI(telemetry);

                // Handle BH panel updates from SSE telemetry with safe DOM updates
                if (telemetry?.events?.['bh.panel']) {
                    renderBhPanel(telemetry.events['bh.panel']);
                } else if (telemetry?.bh_panel) {
                    renderBhPanel(telemetry.bh_panel);
                }

                // Slice 1: Adaptive Proximity integration
                if (typeof handleProximityTelemetry === 'function') {
                    handleProximityTelemetry(telemetry);
                }
            } catch (error) {
                console.error('[telemetry] Error in initial telemetry processing:', error);
                // Continue with partial state update
                state.currentTelemetry = telemetry || {};
            }

            // Process quantum telemetry data with comprehensive error handling
            try {
                if (telemetry.quantum_telemetry) {
                    const q = telemetry.quantum_telemetry;
                    const lamVal = num(q.lam, NaN);
                    state.targets.lam = clamp01(lamVal);
                    safeSetText(DOM.valLam, Number.isFinite(lamVal) ? lamVal.toFixed(3) : 'N/A', 'quantum lam value');

                    const psiH = num(q.psi_entropy, NaN);
                    const totalPop = Object.values(telemetry.shell_population || {}).reduce((a, b) => a + num(b, 0), 0);
                    const maxH = totalPop > 1 ? Math.log(totalPop) : 1;
                    const psiNorm = clamp01(psiH / (maxH || 1));
                    state.targets.psi = psiNorm;
                    safeSetText(DOM.valPsi, Number.isFinite(psiH) ? `${psiH.toFixed(3)} (norm ${psiNorm.toFixed(3)})` : 'N/A', 'quantum psi value');
                    safeSetText(DOM.valQDt, num(q.dt, NaN).toFixed(4), 'quantum dt value');
                    safeSetText(DOM.valQGamma, num(q.gamma, NaN).toFixed(3), 'quantum gamma value');
                    safeSetText(DOM.valQDephase, num(q.dephase, NaN).toFixed(3), 'quantum dephase value');
                }

                // Process core telemetry metrics
                const nov = num(telemetry.novelty, NaN);
                state.targets.novelty = clamp01(nov);
                safeSetText(DOM.valNovelty, nov.toFixed(3), 'novelty value');
                state.noveltySeries.push(nov);

                // M20 server exports 'compression_gain'. Older drafts used 'compression'. Support both.
                const cgRaw = ("compression_gain" in telemetry) ? telemetry.compression_gain : telemetry.compression;
                const cg = num(cgRaw, NaN);
                state.targets.compression = clamp01(cg + 0.5);
                if (Number.isFinite(cg)) {
                    safeSetText(DOM.valCompression, cg.toFixed(4), 'compression value');
                    state.compressionSeries.push(cg);
                }

                const dis = num(telemetry.disagreement, NaN);
                state.targets.disagreement = clamp01(0.5 + 0.5 * Math.tanh(dis));
                safeSetText(DOM.valDisagreement, dis.toFixed(4), 'disagreement value');
                safeSetText(DOM.valQADisagreement, dis.toFixed(4), 'QA disagreement value');
                state.disagreementSeries.push(dis);

                // Trim data series to prevent memory bloat
                const trimSeries = (arr, max = 512) => { if (arr.length > max) arr.splice(0, arr.length - max); };
                trimSeries(state.noveltySeries); trimSeries(state.compressionSeries); trimSeries(state.disagreementSeries);

                // Update sparklines with error protection
                try {
                    sparkline(DOM.sparkNovelty, state.noveltySeries, 96);
                    sparkline(DOM.sparkCompression, state.compressionSeries, 96);
                    sparkline(DOM.sparkDisagreement, state.disagreementSeries, 96);
                } catch (sparklineError) {
                    console.warn('[telemetry] Sparkline update failed:', sparklineError);
                }

                // Handle KD-tree failures display
                const failures = num(telemetry.kdtree_failures, -1);
                if (failures >= 0) {
                    safeSetText(DOM.valKDTree, String(failures), 'kdtree failures');
                    safeSetStyle(DOM.valKDTree, 'color', failures > 0 ? 'var(--warn)' : 'var(--ok)', 'kdtree failures color');
                }

                // Update UI components with error boundaries
                try {
                    updateRotorState(telemetry.shells); // M20 uses 'shells'
                } catch (rotorError) {
                    console.warn('[telemetry] Rotor state update failed:', rotorError);
                }

                try {
                    renderList(DOM.ingestionFeed, telemetry.ingestion_feed);
                    renderList(DOM.validationLab, telemetry.validation_lab);
                    renderList(DOM.insightHolocron, telemetry.insight_holocron);
                } catch (listError) {
                    console.warn('[telemetry] List rendering failed:', listError);
                }

                // Process M20 metrics
                const metrics20 = telemetry.m20_metrics || null;
                if (metrics20) {
                    safeSetText(DOM.m20FluidSteps, String(Math.max(0, Math.floor(num(metrics20.field_steps, 0)))), 'M20 fluid steps');
                    safeSetText(DOM.m20ValenceUpdates, String(Math.max(0, Math.floor(num(metrics20.valence_updates, 0)))), 'M20 valence updates');
                    safeSetText(DOM.m20EnergyExplorations, String(Math.max(0, Math.floor(num(metrics20.energy_explorations, 0)))), 'M20 energy explorations');
                    safeSetText(DOM.m20TopologyAdaptations, String(Math.max(0, Math.floor(num(metrics20.topology_adaptations, 0)))), 'M20 topology adaptations');
                    safeSetText(DOM.m20RecursiveImplementations, String(Math.max(0, Math.floor(num(metrics20.recursive_implementations, 0)))), 'M20 recursive implementations');
                    safeSetText(DOM.m20FlowRate, num(metrics20.consciousness_flow_rate, 0).toFixed(3), 'M20 flow rate');
                    safeSetText(DOM.m20Curvature, num(metrics20.spacetime_curvature, 0).toFixed(3), 'M20 curvature');
                } else {
                    safeSetText(DOM.m20FluidSteps, '-', 'M20 fluid steps default');
                    safeSetText(DOM.m20ValenceUpdates, '-', 'M20 valence updates default');
                    safeSetText(DOM.m20EnergyExplorations, '-', 'M20 energy explorations default');
                    safeSetText(DOM.m20TopologyAdaptations, '-', 'M20 topology adaptations default');
                    safeSetText(DOM.m20RecursiveImplementations, '-', 'M20 recursive implementations default');
                    safeSetText(DOM.m20FlowRate, '0.000', 'M20 flow rate default');
                    safeSetText(DOM.m20Curvature, '0.000', 'M20 curvature default');
                }

                // Process mantle metrics for visual effects
                if (telemetry.mantle) {
                    state.mantle = state.mantle || {};
                    state.mantle.flux = num(telemetry.mantle.flux, 1.0);
                    state.mantle.curvature = num(telemetry.mantle.curvature, 6.0);
                    state.mantle.flow = num(telemetry.mantle.flow, 1.5);
                    state.mantle.tension = num(telemetry.mantle.tension, 0.7);
                } else {
                    // Default mantle values when not provided
                    state.mantle = state.mantle || {};
                    state.mantle.flux = state.mantle.flux || 1.0;
                    state.mantle.curvature = state.mantle.curvature || 6.0;
                    state.mantle.flow = state.mantle.flow || 1.5;
                    state.mantle.tension = state.mantle.tension || 0.7;
                }

                // Update fluid visualizer and run tag
                try {
                    if (fluidVisualizer) fluidVisualizer.updateWithMetrics(metrics20 || {});
                    if (telemetry.run_id) safeSetText(DOM.runTag, `LIVE #${telemetry.run_id}`, 'run tag');
                } catch (visualError) {
                    console.warn('[telemetry] Visualization update failed:', visualError);
                }
            } catch (error) {
                console.error('[telemetry] Error processing quantum/metrics data:', error);
            }

            // Process insights data with error handling
            try {
                // M20 primary stream: 'new_memory_nodes' (fresh nodes with placement)
                // Supplemental: 'insights' list (already vectorized recent salient nodes)
                let insights = [];
                if (Array.isArray(telemetry.new_memory_nodes) && telemetry.new_memory_nodes.length) {
                    insights = telemetry.new_memory_nodes;
                } else if (Array.isArray(telemetry.insights) && telemetry.insights.length) {
                    // Normalize 'insights' structure to minimally required tetra fields
                    insights = telemetry.insights.map((it, idx) => ({
                        node_id: it.id || it.node_id || `insight_${idx}`,
                        rating: it.reward ?? it.rating ?? 0.5,
                        shell_dim: 8,
                        vec8D: it.vec8D || it.vector || it.vec || null,
                        coords_3d: it.vec8D || it.vector || it.vec || null,
                        label: it.label || (it.meta_label || 'Insight')
                    }));
                }
                if (Array.isArray(insights) && insights.length) {
                    try {
                        enqueueInsights(insights);
                    } catch (insightError) {
                        console.warn('[telemetry] Insight enqueue failed:', insightError);
                    }
                }
                if (fluidVisualizer && Array.isArray(telemetry.new_memory_nodes) && telemetry.new_memory_nodes.length) {
                    try {
                        fluidVisualizer.applyMemoryField(telemetry.new_memory_nodes, telemetry);
                    } catch (warpError) {
                        console.warn('[telemetry] Lattice warp update failed:', warpError);
                    }
                }
            } catch (error) {
                console.error('[telemetry] Error processing insights data:', error);
            }
        }

        // --- Slice 1: Adaptive Proximity Helpers (inserted) ---
        function handleProximityTelemetry(tel) {
            if (!tel) return;
            const candidates = [];
            if (tel.proximity_event) candidates.push(tel.proximity_event);
            if (tel.proximity) candidates.push(tel.proximity);
            if (tel.last_proximity) candidates.push(tel.last_proximity);
            if (Array.isArray(tel.proximity_events)) candidates.push(...tel.proximity_events);
            if (!candidates.length) return;
            for (const raw of candidates) {
                if (!raw || typeof raw !== 'object') continue;
                const evt = normalizeProximityEvent(raw);
                if (!evt) continue;
                state.proximity.events.push(evt);
                if (state.proximity.events.length > 140) state.proximity.events.splice(0, state.proximity.events.length - 140);
                state.proximity.lastEvent = evt;
                state.proximity.lastTier = evt.tier;
                if (evt.stats) state.proximity.stats = evt.stats; else if (raw.stats) state.proximity.stats = raw.stats;
                // Slice 2: track distance series and lock count window
                if (isFinite(evt.distance)) {
                    state.proximity.distanceSeries.push(evt.distance);
                    if (state.proximity.distanceSeries.length > state.proximity.maxSeries) state.proximity.distanceSeries.splice(0, state.proximity.distanceSeries.length - state.proximity.maxSeries);
                }
                if (evt.tier === 'lock') state.proximity.lockCountWindow++;
                // Slice 3: maintain per-tier counts
                const t = (evt.tier || 'unknown').toLowerCase();
                if (t in state.proximity.tierCounts) state.proximity.tierCounts[t]++;
            }
            renderProximity();
        }
        function normalizeProximityEvent(raw) {
            try {
                const tier = (raw.tier || raw.classification || raw.level || '').toLowerCase() || 'unknown';
                const distance = Number(raw.distance ?? raw.dist ?? raw.d);
                const score = Number(raw.score ?? raw.proximity_score ?? raw.s);
                const percentile = Number(raw.percentile ?? raw.pct ?? raw.perc);
                const shells = raw.shell_pair || raw.shells || [raw.shell_a, raw.shell_b].filter(v => v != null);
                const a = Number(raw.a_dim ?? raw.dim_a ?? (Array.isArray(shells) ? shells[0] : undefined));
                const b = Number(raw.b_dim ?? raw.dim_b ?? (Array.isArray(shells) ? shells[1] : undefined));
                const stats = extractProximityStats(raw.stats || raw);
                return { ts: Date.now(), tier, distance, score, percentile, a_dim: isFinite(a) ? a : null, b_dim: isFinite(b) ? b : null, stats };
            } catch (e) { return null; }
        }
        function extractProximityStats(obj) {
            if (!obj || typeof obj !== 'object') return null;
            const keys = ['mean', 'std', 'p_lock', 'p_strong', 'p_moderate', 'lock_threshold', 'strong_threshold', 'moderate_threshold'];
            let found = false; const out = {};
            for (const k of keys) if (Object.prototype.hasOwnProperty.call(obj, k)) { out[k] = Number(obj[k]); found = true; }
            return found ? out : null;
        }
        function renderProximity() {
            if (!DOM.proximityPanel) return;
            ensureProximityFilters();
            const { events, stats, lastEvent, activeTiers, distanceSeries } = state.proximity;
            renderThresholdChips(stats);
            if (stats || lastEvent) {
                const s = stats || {}; const le = lastEvent || {};
                DOM.proximitySummary.innerHTML = `
                    ${statCell('Last Tier', le.tier || '-')}
                    ${statCell('Distance', isFinite(le.distance) ? le.distance.toFixed(3) : '-')}
                    ${statCell('Score', isFinite(le.score) ? le.score.toFixed(3) : '-')}
                    ${statCell('Percentile', isFinite(le.percentile) ? (le.percentile * 100).toFixed(1) + '%' : '-')}
                    ${statCell('Mean', isFinite(s.mean) ? s.mean.toFixed(3) : '-')}
                    ${statCell('p_lock', isFinite(s.p_lock) ? s.p_lock.toFixed(3) : '-')}
                    ${statCell('p_strong', isFinite(s.p_strong) ? s.p_strong.toFixed(3) : '-')}
                `;
            } else {
                DOM.proximitySummary.innerHTML = '<div class="prox-stat" style="grid-column:1/-1;"><span class="k">Adaptive Proximity</span><span class="v">Awaiting events...</span></div>';
            }
            if (!events.length) { DOM.proximityEventsList.innerHTML = '<div class="proximity-empty">No proximity events yet.</div>'; updateProximityBadge(); drawProximitySparkline(); return; }
            const filtered = events.filter(ev => activeTiers.has(ev.tier || 'unknown'));
            const rows = filtered.slice(-60).map(ev => proximityEventRow(ev)).reverse().join('');
            DOM.proximityEventsList.innerHTML = rows || '<div class="proximity-empty">No events (filters).</div>';
            updateProximityCounts();
            updateProximityBadge();
            drawProximitySparkline(distanceSeries, stats);
        }
        function updateProximityCounts() {
            if (!DOM.proxCountLock || !DOM.proxCountStrong || !DOM.proxCountModerate) return;
            const c = state.proximity.tierCounts || {};
            DOM.proxCountLock.textContent = `LOCK ${c.lock || 0}`;
            DOM.proxCountStrong.textContent = `STRONG ${c.strong || 0}`;
            DOM.proxCountModerate.textContent = `MODERATE ${c.moderate || 0}`;
        }
        function renderThresholdChips(stats) {
            if (!DOM.proximityThresholdChips) return;
            if (!stats) { DOM.proximityThresholdChips.innerHTML = ''; return; }
            const parts = [];
            if (isFinite(stats.lock_threshold)) parts.push(`<span class="chip chip-lock">lock≤${Number(stats.lock_threshold).toFixed(3)}</span>`);
            if (isFinite(stats.strong_threshold)) parts.push(`<span class="chip chip-strong">strong≤${Number(stats.strong_threshold).toFixed(3)}</span>`);
            if (isFinite(stats.moderate_threshold)) parts.push(`<span class="chip chip-moderate">moderate≤${Number(stats.moderate_threshold).toFixed(3)}</span>`);
            DOM.proximityThresholdChips.innerHTML = parts.join('');
        }
        function ensureProximityFilters() {
            if (!DOM.proximityFilters || DOM.proximityFilters.childElementCount) return;
            const tiers = ['lock', 'strong', 'moderate', 'weak', 'noise', 'unknown'];
            // Load saved tiers from localStorage if available
            try {
                const saved = JSON.parse(localStorage.getItem('e8_proximity_active_tiers') || 'null');
                if (Array.isArray(saved) && saved.length) {
                    state.proximity.activeTiers = new Set(saved.filter(t => tiers.includes(t)));
                    if (!state.proximity.activeTiers.size) state.proximity.activeTiers = new Set(['lock', 'strong', 'moderate', 'weak']);
                }
            } catch (e) { /* ignore */ }
            tiers.forEach(t => {
                const btn = document.createElement('button');
                btn.textContent = t.toUpperCase();
                btn.dataset.tier = t;
                if (state.proximity.activeTiers.has(t)) btn.classList.add('active');
                btn.addEventListener('click', () => {
                    if (state.proximity.activeTiers.has(t)) state.proximity.activeTiers.delete(t); else state.proximity.activeTiers.add(t);
                    if (state.proximity.activeTiers.size === 0) { // ensure not empty
                        state.proximity.activeTiers.add(t);
                    }
                    // Persist selection
                    try { localStorage.setItem('e8_proximity_active_tiers', JSON.stringify(Array.from(state.proximity.activeTiers))); } catch (e) { /* ignore */ }
                    Array.from(DOM.proximityFilters.children).forEach(c => c.classList.toggle('active', state.proximity.activeTiers.has(c.dataset.tier)));
                    renderProximity();
                });
                DOM.proximityFilters.appendChild(btn);
            });
        }
        function updateProximityBadge() {
            if (!DOM.proximityBadge || !DOM.proximityBadgeCount) return;
            // Display count of lock events in the last 120s
            const now = Date.now();
            const recentLocks = state.proximity.events.filter(e => e.tier === 'lock' && (now - e.ts) < 120000);
            if (recentLocks.length) {
                DOM.proximityBadge.style.display = 'inline-flex';
                DOM.proximityBadgeCount.textContent = String(recentLocks.length);
            } else {
                DOM.proximityBadge.style.display = 'none';
            }
        }
        function drawProximitySparkline(series = state.proximity.distanceSeries, stats) {
            if (!DOM.proximitySparkline) return;
            const canvas = DOM.proximitySparkline; const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);
            const h = canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);
            ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
            ctx.clearRect(0, 0, w, h);
            if (!series.length) return;
            const maxPoints = 160; const data = series.slice(-maxPoints);
            const minV = Math.min(...data); const maxV = Math.max(...data); const range = (maxV - minV) || 1;
            ctx.lineWidth = 1.2; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            ctx.beginPath();
            data.forEach((v, i) => {
                const x = (i / (data.length - 1)) * (w - 4) + 2;
                const y = h - ((v - minV) / range) * (h - 6) - 3;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
            // Threshold overlays
            if (stats && isFinite(stats.lock_threshold)) drawThresholdLine(ctx, stats.lock_threshold, minV, range, h, '#c792ea');
            if (stats && isFinite(stats.strong_threshold)) drawThresholdLine(ctx, stats.strong_threshold, minV, range, h, getComputedStyle(document.documentElement).getPropertyValue('--accent').trim());
            if (stats && isFinite(stats.moderate_threshold)) drawThresholdLine(ctx, stats.moderate_threshold, minV, range, h, getComputedStyle(document.documentElement).getPropertyValue('--warn').trim());
            // Hover tooltip
            canvas.onmousemove = (e) => {
                if (!DOM.proximitySparklineTooltip) return;
                const rect = canvas.getBoundingClientRect();
                const ratio = (e.clientX - rect.left) / rect.width;
                const idx = Math.max(0, Math.min(data.length - 1, Math.round(ratio * (data.length - 1))));
                const val = data[idx];
                DOM.proximitySparklineTooltip.style.display = 'block';
                DOM.proximitySparklineTooltip.style.left = `${e.clientX + 8}px`;
                DOM.proximitySparklineTooltip.style.top = `${e.clientY + 8}px`;
                DOM.proximitySparklineTooltip.textContent = `d=${val.toFixed(4)}`;
            };
            canvas.onmouseleave = () => { if (DOM.proximitySparklineTooltip) DOM.proximitySparklineTooltip.style.display = 'none'; };
        }
        function drawThresholdLine(ctx, threshold, minV, range, h, color) {
            const y = h - ((threshold - minV) / range) * (h - 6) - 3;
            ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 0.8; ctx.setLineDash([4, 3]);
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y); ctx.stroke(); ctx.restore();
        }
        // Slice 3: controls wiring (export and reset)
        (function initProximityControls() {
            if (DOM.proxExportCsv) {
                DOM.proxExportCsv.addEventListener('click', () => {
                    const rows = [['ts', 'tier', 'distance', 'score', 'percentile']];
                    for (const e of state.proximity.events) {
                        rows.push([
                            e.ts || '',
                            e.tier || '',
                            isFinite(e.distance) ? e.distance : '',
                            isFinite(e.score) ? e.score : '',
                            isFinite(e.percentile) ? e.percentile : ''
                        ]);
                    }
                    const csv = rows.map(r => r.map(x => String(x).includes(',') ? `"${String(x).replace(/"/g, '""')}"` : String(x)).join(',')).join('\n');
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'proximity_events.csv'; a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                });
            }
            if (DOM.proxResetFilters) {
                DOM.proxResetFilters.addEventListener('click', () => {
                    state.proximity.activeTiers = new Set(['lock', 'strong', 'moderate', 'weak']);
                    try { localStorage.setItem('e8_proximity_active_tiers', JSON.stringify(Array.from(state.proximity.activeTiers))); } catch (e) { }
                    if (DOM.proximityFilters) Array.from(DOM.proximityFilters.children).forEach(c => c.classList.toggle('active', state.proximity.activeTiers.has(c.dataset.tier)));
                    renderProximity();
                });
            }
        })();
        function statCell(label, value) { return `<div class=\"prox-stat\"><span class=\"k\">${escapeHTML(label)}</span><span class=\"v\">${escapeHTML(String(value))}</span></div>`; }
        function proximityEventRow(ev) {
            const agoMs = Date.now() - ev.ts; const ago = agoMs < 1000 ? `${agoMs}ms` : `${(agoMs / 1000).toFixed(1)}s`;
            const dims = [ev.a_dim, ev.b_dim].filter(v => v != null).join('↔') || '—';
            const tierCls = `proximity-tier-${(ev.tier || 'unknown').replace(/[^a-z0-9_-]/g, '')}`;
            return `<div class=\"proximity-event ${tierCls}\">\n` +
                `  <div class=\"meta\"><strong>${escapeHTML((ev.tier || '?').toUpperCase())}</strong><span style=\"opacity:.6;\">${ago}</span></div>\n` +
                `  <div style=\"font-size:11px;\">Dims: ${escapeHTML(dims)} | d=${isFinite(ev.distance) ? ev.distance.toFixed(3) : '–'} | p=${isFinite(ev.percentile) ? (ev.percentile * 100).toFixed(1) + '%' : '–'}</div>\n` +
                `  <div style=\"font-size:10px; opacity:.7;\">score=${isFinite(ev.score) ? ev.score.toFixed(3) : '–'}</div>\n` +
                `</div>`;
        }
        // --- End Slice 1 Helpers ---

        let lastAnimationTime = 0;
        const TARGET_FPS = 60;
        const FRAME_INTERVAL = 1000 / TARGET_FPS;

        function animate() {
            const now = performance.now();

            // Throttle animation to target FPS
            if (now - lastAnimationTime < FRAME_INTERVAL) {
                animationFrameId = requestAnimationFrame(animate);
                return;
            }

            lastAnimationTime = now;
            animationFrameId = requestAnimationFrame(animate);
            __frameCounter++;
            const dt = Math.min(0.05, clock.getDelta());
            const s = 0.12;
            for (const key in state.smooth) state.smooth[key] = lerp(state.smooth[key], state.targets[key], s);
            DOM.moodIntensity.value = state.smooth.moodIntensity;
            DOM.moodEntropy.value = state.smooth.moodEntropy;
            DOM.moodCoherence.value = state.smooth.moodCoherence;
            if (DOM.moodPositivity) DOM.moodPositivity.value = state.smooth.moodPositivity;
            if (DOM.moodFluidity) DOM.moodFluidity.value = state.smooth.moodFluidity;
            if (DOM.moodIntelligibility) DOM.moodIntelligibility.value = state.smooth.moodIntelligibility;
            drawRing(DOM.ringPressure, state.smooth.pressure, '--bad');
            drawRing(DOM.ringTeacher, state.smooth.teacher);
            drawRing(DOM.ringExplorer, state.smooth.explorer);
            if (DOM.ringPsi) drawRing(DOM.ringPsi, state.smooth.psi, '--accent-2');
            if (DOM.ringLambda) drawRing(DOM.ringLambda, state.smooth.lam, '--glow');
            drawRing(DOM.ringReward, state.smooth.reward, '--ok');
            const p = state.smooth.wxPressure;
            DOM.wxPressure.textContent = p.toFixed(2);
            DOM.wxPressure.style.color = p > 0.85 ? 'var(--bad)' : p > 0.6 ? 'var(--warn)' : 'var(--ok)';
            const g = state.smooth.globalTension;
            DOM.globalTension.textContent = g.toFixed(3);
            DOM.globalTension.style.color = g > 0.85 ? 'var(--bad)' : g > 0.6 ? 'var(--warn)' : 'var(--ok)';

            // Update mantle metrics display
            if (state.mantle) {
                if (DOM.mantleFlux) DOM.mantleFlux.textContent = state.mantle.flux.toFixed(3);
                if (DOM.mantleCurvature) DOM.mantleCurvature.textContent = state.mantle.curvature.toFixed(3);
                if (DOM.mantleFlow) DOM.mantleFlow.textContent = state.mantle.flow.toFixed(3);
                if (DOM.mantleTension) DOM.mantleTension.textContent = state.mantle.tension.toFixed(3);
            }

            if (fluidVisualizer) fluidVisualizer.update(dt);
            drawRotors(dt);
            animateTetras(performance.now());
        }

        function handleResize() {
            try {
                if (tetraRenderer && tetraCamera && DOM.tetraCanvas) {
                    const rect = DOM.tetraCanvas.parentElement.getBoundingClientRect();
                    if (rect.width && rect.height) {
                        tetraRenderer.setSize(rect.width, rect.height, false);
                        tetraCamera.aspect = rect.width / rect.height;
                        tetraCamera.updateProjectionMatrix();
                    }
                }
            } catch (e) { console.warn('Resize handling issue', e); }
        }
        window.addEventListener('resize', handleResize);

        async function fetchTelemetrySnapshot(endpoint = API.telemetrySnapshot, timeoutMs = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const response = await fetch(endpoint, {
                    signal: controller.signal,
                    cache: 'no-store',
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                processTelemetry(data);
                return { ok: true };
            } catch (error) {
                return { ok: false, error };
            } finally {
                clearTimeout(timeoutId);
            }
        }

        function startPolling(url, intervalMs) {
            console.log(`[polling] Starting polling at ${url} every ${intervalMs}ms`);

            let consecutiveFailures = 0;
            const maxFailures = 10;

            const poll = async () => {
                const { ok, error } = await fetchTelemetrySnapshot(url);

                if (ok) {
                    consecutiveFailures = 0; // Reset failure counter on success
                    DOM.status.textContent = `Polling connection active (${new Date().toLocaleTimeString()})`;
                    DOM.runTag.style.color = 'var(--warn)';
                    DOM.runTag.textContent = 'POLLING';

                    console.log('[polling] Successfully fetched telemetry data');
                } else {
                    consecutiveFailures++;
                    const message = error && error.message ? error.message : error;
                    console.warn(`[polling] Request failed (${consecutiveFailures}/${maxFailures}):`, message);

                    DOM.status.textContent = `Polling failed (${consecutiveFailures}/${maxFailures}). Retrying...`;
                    DOM.runTag.style.color = 'var(--bad)';
                    DOM.runTag.textContent = 'OFFLINE';

                    // If too many consecutive failures, try to reconnect via WebSocket/SSE
                    if (consecutiveFailures >= maxFailures) {
                        console.log('[polling] Too many failures, attempting to reconnect via WebSocket/SSE');

                        // Clean up current polling first
                        if (currentPollInterval) {
                            clearInterval(currentPollInterval);
                            currentPollInterval = null;
                        }

                        setTimeout(() => {
                            if (!isConnecting) { // Only reconnect if not already connecting
                                connectTelemetryStream();
                            }
                        }, 5000);
                        return; // Stop polling
                    }
                }
            };

            poll(); // Initial poll
            const pollInterval = setInterval(poll, intervalMs);

            // Store interval reference for cleanup
            currentPollInterval = pollInterval;
            window.currentPollInterval = pollInterval;
        }

        async function connectTelemetryStream() {
            // Prevent multiple concurrent connection attempts
            if (isConnecting) {
                console.log('[connection] Connection attempt already in progress, skipping duplicate');
                return;
            }
            isConnecting = true;

            // Add a minimum delay between connection attempts
            const now = Date.now();
            const lastAttempt = connectTelemetryStream.lastAttempt || 0;
            if (now - lastAttempt < 1000) {
                console.log('[connection] Connection attempt too soon, throttling');
                isConnecting = false;
                return;
            }
            connectTelemetryStream.lastAttempt = now;

            try {
                // Clean up any existing connections first
                cleanupExistingConnections();

                // Try WebSocket endpoints first for lower-latency bi-directional updates.
                const wsCandidates = [
                    buildWsUrl('api/telemetry/ws'),
                    buildWsUrl('ws/telemetry'),
                    buildWsUrl('ws'),
                ];

                DOM.status.textContent = `Connecting to telemetry...`;
                console.log(`[connection] Attempting WebSocket connection to backend at ${API_BASE_URL}`);

                // Attempt WebSocket connection with improved timeout and error handling
                for (let i = 0; i < wsCandidates.length; i++) {
                    const wsUrl = wsCandidates[i];
                    console.log(`[connection] Trying WebSocket endpoint: ${wsUrl}`);

                    try {
                        const ws = new WebSocket(wsUrl);
                        let opened = false;

                        const openPromise = new Promise((resolve, reject) => {
                            const to = setTimeout(() => {
                                console.log(`[connection] WebSocket timeout for ${wsUrl}`);
                                reject(new Error('WS open timeout'));
                            }, 5000); // Increased timeout to 5 seconds

                            ws.onopen = () => {
                                clearTimeout(to);
                                opened = true;
                                console.log(`[connection] WebSocket connected successfully to ${wsUrl}`);
                                resolve();
                            };

                            ws.onerror = (err) => {
                                clearTimeout(to);
                                console.log(`[connection] WebSocket error for ${wsUrl}:`, err);
                                reject(err);
                            };
                        });

                        await openPromise;

                        // Setup message handlers with better error handling
                        ws.onmessage = (ev) => {
                            if (!ev.data) return;
                            try {
                                const payload = JSON.parse(ev.data);
                                console.log('[ws] Received telemetry data:', Object.keys(payload));

                                if (payload && payload.type === 'tetra_update') {
                                    const d = payload.data || payload;
                                    if (Array.isArray(d)) {
                                        d.forEach(item => {
                                            if (!tetraInitialized) enqueueEarlyTetra(item);
                                            else upsertInsightTetra(item);
                                        });
                                    } else if (d) {
                                        if (!tetraInitialized) enqueueEarlyTetra(d);
                                        else upsertInsightTetra(d);
                                    }
                                    return;
                                }
                                // Generic telemetry object - process all data
                                processTelemetry(payload);
                            } catch (err) {
                                console.warn('[ws] Telemetry parse error:', err, 'Raw data:', ev.data?.substring(0, 200));
                            }
                        };

                        ws.onclose = (event) => {
                            console.log(`[ws] Connection closed. Code: ${event.code}, Reason: ${event.reason}`);

                            // Only reconnect if this was the active connection
                            if (currentWebSocket === ws) {
                                DOM.status.textContent = 'WebSocket closed. Reconnecting...';
                                DOM.runTag.style.color = 'var(--warn)';
                                DOM.runTag.textContent = 'RECONNECTING';

                                currentWebSocket = null;
                                telemetryTry++;

                                // Exponential backoff for reconnection with cap
                                const delay = Math.min(2000 * Math.pow(1.5, Math.min(telemetryTry, 8)), 15000) + Math.random() * 1000;
                                console.log(`[connection] Scheduling reconnection in ${Math.round(delay)}ms (attempt ${telemetryTry})`);

                                setTimeout(() => {
                                    isConnecting = false; // Reset flag before attempting reconnection
                                    connectTelemetryStream();
                                }, delay);
                            } else {
                                console.log('[ws] Ignoring close event from inactive WebSocket');
                            }
                        };

                        ws.onerror = (e) => {
                            console.error('[ws] WebSocket error:', e);
                            try { ws.close(); } catch (closeErr) { console.warn('[ws] Error closing WebSocket:', closeErr); }
                        };

                        DOM.status.textContent = `Live WS connected (${wsUrl})`;
                        DOM.runTag.style.color = 'var(--ok)';
                        DOM.runTag.textContent = 'LIVE';
                        __sseAttempts = 0;
                        telemetryTry = 0;

                        // Store websocket reference for cleanup
                        currentWebSocket = ws;
                        window.currentWebSocket = ws;

                        console.log(`[connection] WebSocket connection established successfully`);
                        isConnecting = false; // Reset flag on successful connection
                        return; // connected via WS successfully
                    } catch (err) {
                        console.warn(`[connection] WS candidate failed: ${wsUrl}`, err?.message || err);
                        // Clean up failed connection
                        try { ws.close(); } catch (closeErr) { /* ignore */ }
                        // try next candidate
                    }
                }

                console.log('[connection] All WebSocket candidates failed, falling back to SSE');

                // No working WS found: fallback to SSE
                const url = TELEMETRY_CANDIDATES[telemetryTry % TELEMETRY_CANDIDATES.length];
                console.log(`[connection] Attempting SSE connection to: ${url}`);
                DOM.status.textContent = `Connecting to ${url} (SSE fallback)...`;

                // If we've tried SSE too many times or URL doesn't support streaming, use polling
                if (__sseAttempts >= 6 || !url.includes('/stream')) {
                    const pollUrl = url.replace(/\/stream$/, '');
                    console.log(`[connection] SSE attempts exhausted, falling back to polling: ${pollUrl}`);
                    startPolling(pollUrl, 1500);
                    return;
                }

                const sse = new EventSource(url, { withCredentials: false });

                sse.onopen = () => {
                    console.log('[connection] SSE connection established');
                    DOM.status.textContent = 'Live SSE connection established.';
                    DOM.runTag.style.color = 'var(--ok)';
                    DOM.runTag.textContent = 'SSE';
                    __sseAttempts = 0;
                    telemetryTry = 0;

                    // Store EventSource reference for cleanup
                    currentEventSource = sse;
                    isConnecting = false; // Reset flag on successful SSE connection
                };
                const onData = (e) => {
                    if (!e.data || !e.data.trim() || e.data === 'ping') return;
                    try {
                        const obj = JSON.parse(e.data);
                        console.log('[sse] Received telemetry data:', Object.keys(obj));
                        processTelemetry(obj); // ensure full UI update from telemetry payload
                    } catch (err) {
                        console.error('[sse] Telemetry parse error:', err, 'Raw data:', e.data?.substring(0, 200));
                    }
                };

                sse.addEventListener('telemetry', onData);
                sse.addEventListener('message', onData);
                sse.addEventListener('tetra_update', (e) => {
                    try {
                        if (!e.data) return;
                        let parsed;
                        try {
                            parsed = JSON.parse(e.data);
                            console.log('[sse] Received tetra_update');
                        } catch (parseErr) {
                            console.warn('[sse] Failed to parse tetra_update:', parseErr);
                            return;
                        }

                        const d = parsed?.data || parsed;
                        if (Array.isArray(d)) {
                            d.forEach(item => {
                                if (!tetraInitialized) enqueueEarlyTetra(item);
                                else upsertInsightTetra(item);
                            });
                        } else if (d) {
                            if (!tetraInitialized) enqueueEarlyTetra(d);
                            else upsertInsightTetra(d);
                        }
                    } catch (err) {
                        console.error('[sse] Bad tetra_update event:', err);
                    }
                });

                sse.onerror = (event) => {
                    console.warn('[sse] SSE connection error:', event);
                    try { sse.close(); } catch (e) { console.warn('[sse] Error closing SSE:', e); }

                    // Only reconnect if this was the active connection
                    if (currentEventSource === sse) {
                        DOM.status.textContent = 'SSE connection lost. Retrying...';
                        DOM.runTag.style.color = 'var(--warn)';
                        DOM.runTag.textContent = 'RECONNECTING';

                        currentEventSource = null;
                        __sseAttempts++;
                        telemetryTry++;

                        const delay = Math.min(3000 * Math.pow(1.8, Math.min(telemetryTry, 8)), 30000) + Math.random() * 1000;
                        console.log(`[connection] Retrying connection in ${Math.round(delay)}ms (attempt ${telemetryTry})`);
                        setTimeout(() => {
                            isConnecting = false; // Reset flag before attempting reconnection
                            connectTelemetryStream();
                        }, delay);
                    } else {
                        console.log('[sse] Ignoring error event from inactive SSE connection');
                    }
                };
            } catch (error) {
                console.error('[connection] Connection setup failed:', error);
                isConnecting = false;

                // Fallback to polling on critical error
                console.log('[connection] Using polling fallback due to connection setup error');
                startPolling(API.telemetrySnapshot, 2000);
            }
        }

        // Periodically sync all concepts to ensure tetrahedron count matches concept count
        async function syncAllConcepts() {
            try {
                console.log('[sync] Requesting full concept sync from server...');

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout for graph data

                const response = await fetch(`${API_BASE_URL}/api/graph`, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.warn(`[sync] Graph API failed: HTTP ${response.status} ${response.statusText}`);
                    return;
                }

                const graphData = await response.json();
                if (!graphData || !Array.isArray(graphData.nodes)) {
                    console.warn('[sync] Invalid graph data received:', typeof graphData, graphData ? Object.keys(graphData) : 'null');
                    return;
                }

                console.log(`[sync] Received ${graphData.nodes.length} total concepts from server`);

                // Convert graph nodes to tetrahedron format
                const allConcepts = graphData.nodes.map((node, idx) => ({
                    node_id: node.id || node.node_id || `concept_${idx}`,
                    label: node.label || node.name || `Concept ${idx}`,
                    type: node.type || 'concept',
                    rating: node.rating || node.reward || Math.random() * 0.5 + 0.25,
                    shell_dim: node.shell_dim || (node.vector ? 8 : 8),
                    vec8D: node.vector || node.vec8D || null,
                    coords_3d: node.coords_3d || node.position || null,
                    temperature: node.temperature || 1.0,
                    age: node.age || 0,
                    connectivity: node.connectivity || Math.random(),
                    x: node.x || (Math.random() - 0.5) * 20,
                    y: node.y || (Math.random() - 0.5) * 20,
                    z: node.z || (Math.random() - 0.5) * 20
                }));

                // Filter out concepts that already have tetrahedrons
                const newConcepts = allConcepts.filter(concept => !tetraIndexById.has(concept.node_id));

                if (newConcepts.length > 0) {
                    console.log(`[sync] Creating ${newConcepts.length} missing tetrahedra (${tetraIndexById.size} existing)`);
                    enqueueInsights(newConcepts);
                } else {
                    console.log(`[sync] All ${allConcepts.length} concepts already have tetrahedra`);
                }

                // Update concept count display
                const conceptCountElement = document.querySelector('[data-concept-count]');
                if (conceptCountElement) {
                    conceptCountElement.textContent = allConcepts.length;
                }

            } catch (error) {
                console.error('[sync] Failed to sync concepts:', error);
            }
        }

        // Start periodic concept synchronization
        function startConceptSync() {
            // Prevent multiple sync intervals
            if (currentSyncInterval) {
                clearInterval(currentSyncInterval);
                currentSyncInterval = null;
            }

            // Initial sync after 5 seconds
            setTimeout(syncAllConcepts, 5000);

            // Then sync every 30 seconds
            currentSyncInterval = setInterval(syncAllConcepts, 30000);
        }

        // Clear any existing demo tetrahedra
        function clearDemoTetrahedra() {
            console.log('[demo] Clearing existing demo tetrahedra...');

            // Find all demo tetrahedra by ID pattern
            const demoIndices = [];
            tetraInstanceData.forEach((inst, index) => {
                if (inst && inst.fullData && inst.fullData.node_id &&
                    inst.fullData.node_id.startsWith('demo_')) {
                    demoIndices.push(index);
                }
            });

            console.log(`[demo] Found ${demoIndices.length} demo tetrahedra to remove`);

            // Remove from tetraIndexById map and tetraInstanceData array
            demoIndices.forEach(index => {
                const inst = tetraInstanceData[index];
                if (inst && inst.fullData && inst.fullData.node_id) {
                    tetraIndexById.delete(inst.fullData.node_id);
                    console.log(`[demo] Removed demo tetra: ${inst.fullData.node_id}`);
                }
            });

            // Clear the instances from the array (set to null to maintain indices)
            demoIndices.forEach(index => {
                tetraInstanceData[index] = null;
            });

            // Update mesh counts - reset all meshes
            if (window.tetraMeshes) {
                window.tetraMeshes.forEach(mesh => {
                    if (mesh && typeof mesh.count === 'number') {
                        mesh.count = 0; // Reset count to rebuild from real data only
                    }
                });
            }

            console.log('[demo] Demo tetrahedra cleared successfully');
        }

        // Create demo tetrahedra for testing the visualization (DISABLED)
        function createDemoTetrahedra() {
            // Check if meshes are ready
            const validMeshes = window.tetraMeshes?.filter(m => m?.instanceMatrix && typeof m.count === 'number') || [];
            if (validMeshes.length === 0) {
                console.warn('[demo] No valid meshes available yet, skipping demo creation');
                return;
            }

            console.log(`[demo] Found ${validMeshes.length} valid meshes for demo tetrahedra`);

            const demoTypes = [
                'monologue_thought', 'phase_summary', 'reflection',
                'concept', 'insight', 'hypothesis',
                'memory', 'consolidation', 'remnant',
                'arxiv_api', 'pubmed_api', 'json_api',
                'emergence', 'validation', 'meta', 'unknown'
            ];

            console.log('[demo] Creating demo tetrahedra...');

            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = 8 + (i % 3) * 3; // Vary radius: 8, 11, 14
                const height = (Math.sin(i * 0.7) * 3); // Vary height: -3 to 3

                const demoData = {
                    id: `demo_tetra_${i}`,
                    node_id: `demo_node_${i}`,
                    label: `Demo ${demoTypes[i % demoTypes.length]} ${i}`,
                    type: demoTypes[i % demoTypes.length],
                    rating: (i % 10) / 10 + 0.1, // Rating from 0.1 to 1.0
                    shell_dim: [8, 16, 32, 64][i % 4], // Vary shell dimensions
                    x: Math.cos(angle) * radius,
                    y: height,
                    z: Math.sin(angle) * radius,
                    temperature: Math.random() * 2.0,
                    age: Math.random() * 100,
                    connectivity: Math.random(),
                    coherence: Math.random(),
                    novelty: Math.random()
                };

                console.log(`[demo] Creating tetra ${i} of type ${demoData.type} at position (${demoData.x.toFixed(2)}, ${demoData.y.toFixed(2)}, ${demoData.z.toFixed(2)})`);

                // Stagger the creation timing for a nice cascading effect
                setTimeout(() => {
                    createTetraInstanceFromE8Data(demoData);
                }, i * 150); // 150ms delay between each tetrahedron
            } console.log(`[demo] Created ${tetraInstanceData.length} demo tetrahedra`);
            console.log(`[demo] Mesh counts:`, validMeshes.map(m => `${m.userData.geometryType}: ${m.count}`));
        }

        let initializationInProgress = false;

        async function init() {
            // Prevent multiple initialization calls
            if (initializationInProgress) {
                console.log('[init] Initialization already in progress, skipping duplicate call');
                return;
            }

            initializationInProgress = true;
            console.log('[init] Starting initialization...');
            DOM.status.textContent = "Building visualization...";

            await initializeTetraMode();
            await ensureLatticeLoaded(); // Make sure this completes

            flushEarlyTetras();

            // Clear any existing demo tetrahedra from previous sessions (immediate + delayed)
            clearDemoTetrahedra();
            setTimeout(() => {
                clearDemoTetrahedra(); // Clear again in case any were created during init
                // Start concept sync after clearing demos
                startConceptSync();
            }, 500);

            // Demo tetrahedra disabled - using real concept sync instead
            // setTimeout(() => {
            //     if (tetraInstanceData.length === 0) {
            //         createDemoTetrahedra();
            //     }
            // }, 1000);

            // Start animation loop
            animate();

            // Prime UI with latest telemetry before establishing live stream
            fetchTelemetrySnapshot();

            // Connect to data stream
            setTimeout(connectTelemetryStream, 500);

            // Start BH panel fallback poller
            setTimeout(pollBhPanel, 1000);

            initializationInProgress = false;
            console.log('[init] Initialization complete');
        }

        DOM.themeToggle.addEventListener('click', () => {
            const html = document.documentElement;
            const light = html.getAttribute('data-theme') === 'light';
            html.setAttribute('data-theme', light ? 'dark' : 'light');
            DOM.themeToggle.textContent = light ? 'Light' : 'Dark';
            if (window.applyThemeBackground) window.applyThemeBackground();
            if (fluidVisualizer) fluidVisualizer.refreshTheme();
        });

        document.addEventListener('click', (e) => {
            const btn = e.target.closest('.collapse-btn');
            if (!btn) return;
            const key = btn.dataset.collapse; if (!key) return;
            const header = btn.parentElement;
            const collapsed = header.classList.toggle('collapsed');
            btn.textContent = collapsed ? '+' : '-';
        });

        init();
    </script>
</body>

</html>