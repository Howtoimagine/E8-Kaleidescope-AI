<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>E8 Mind-Crystal (Live HUD) - M23 Robust</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧠</text></svg>">
    <style>
        :root {
            --bg: #0b0f17;
            --fg: #d9e1ff;
            --muted: #a7b0d6;
            --glow: #7aa2ff;
            --glass: rgba(16, 22, 33, 0.65);
            --glass-2: rgba(16, 22, 33, 0.35);
            --accent: #8ef1ff;
            --accent-2: #c792ea;
            --ok: #6ee7b7;
            --warn: #fde047;
            --bad: #fb7185;
            --border-color: rgba(255, 255, 255, 0.06);
        }

        html[data-theme="light"] {
            --bg: #f0f2f7;
            --fg: #1c1e26;
            --muted: #5a647e;
            --glow: #0052d6;
            --glass: rgba(255, 255, 255, 0.6);
            --glass-2: rgba(255, 255, 255, 0.3);
            --accent: #0097b3;
            --accent-2: #9e28d4;
            --ok: #069668;
            --warn: #d97706;
            --bad: #e11d48;
            --border-color: rgba(0, 0, 0, 0.1);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden;
        }

        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            display: grid;
            grid-template-columns: clamp(300px, 24vw, 380px) 1fr clamp(320px, 26vw, 420px);
            grid-template-rows: 60px 1fr 40px;
            grid-template-areas: "header header header" "left main right" "footer footer footer";
            gap: 16px;
            padding: 16px;
        }

        .panel {
            background: rgba(16, 22, 33, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .left-panel {
            grid-area: left;
        }

        .right-panel {
            grid-area: right;
            min-width: 300px;
            max-width: 100%;
        }

        #tetraPanel {
            grid-area: main;
        }

        #tetraCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .panel-title {
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: .5px;
            opacity: .8;
            flex-grow: 1;
        }

        .collapse-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--muted);
            width: 22px;
            height: 22px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background .2s, color .2s;
        }

        .collapse-btn:hover {
            background: var(--glass-2);
            color: var(--accent);
        }

        .collapsed+.panel-content {
            display: none !important;
        }

        .panel-content {
            padding: 16px;
            overflow-y: auto;
            overflow-x: hidden;
            flex-grow: 1;
            scrollbar-width: thin;
        }

        .panel-content.no-padding {
            padding: 0;
            position: relative;
        }

        header {
            grid-area: header;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            pointer-events: auto;
            background: linear-gradient(to right, rgba(20, 26, 40, 0.7), rgba(20, 26, 40, 0.3));
            border-bottom: 1px solid var(--border-color);
            border-radius: 12px;
        }

        .brand {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent);
        }

        .brand span {
            opacity: .7;
            font-weight: 400;
            font-size: 14px;
        }

        .status-tag {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(125, 145, 255, 0.15);
            color: #9ab0ff;
            border: 1px solid rgba(125, 145, 255, 0.25);
        }

        .footer {
            grid-area: footer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            color: var(--muted);
            font-size: 12px;
        }

        .weather-box {
            margin-top: 12px;
            padding: 8px 12px;
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 12px;
        }

        .weather-box .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .weather-box .label {
            color: var(--muted);
        }

        .weather-box .value {
            color: var(--fg);
            font-weight: 600;
            text-align: right;
        }

        .ring {
            position: relative;
            width: 92px;
            height: 92px;
        }

        .ring canvas {
            position: absolute;
            inset: 0;
        }

        .ring .ring-label {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--muted);
        }

        .tab-header {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            padding: 0 8px;
            flex-shrink: 0;
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--muted);
            padding: 10px 16px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 2px solid transparent;
        }

        .tab-btn.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            display: none;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
            min-height: 0;
            /* allow flex children to shrink */
        }

        .tab-content.active {
            display: flex;
        }

        .theme-toggle-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--fg);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* NEW STYLES FOR COMBINED SHELL DYNAMICS PANEL */
        #shellDynamicsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .shell-card {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            font-size: 12px;
        }

        .shell-card .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .shell-card .label {
            color: var(--muted);
        }

        .shell-card .value {
            color: var(--fg);
            font-weight: 600;
        }

        .shell-card canvas {
            width: 100%;
            height: 40px;
            margin-top: 8px;
        }

        /* --- Slice 1: Adaptive Proximity Styles --- */
        #proximityPanel {
            font-size: 12px;
        }

        #proximityEventsList {
            display: flex;
            flex-direction: column-reverse;
            gap: 4px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .proximity-event {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 6px 8px;
            background: var(--glass-2);
            display: flex;
            flex-direction: column;
            gap: 2px;
            line-height: 1.25;
        }

        .proximity-event .meta {
            display: flex;
            justify-content: space-between;
        }

        .proximity-tier-lock {
            border-color: var(--accent-2);
            box-shadow: 0 0 0 1px var(--accent-2) inset;
        }

        .proximity-tier-strong {
            border-color: var(--accent);
        }

        .proximity-tier-moderate {
            border-color: var(--warn);
        }

        .proximity-tier-weak,
        .proximity-tier-noise {
            opacity: 0.65;
        }

        .proximity-metric-chip {
            display: inline-block;
            background: var(--glass);
            padding: 2px 6px;
            border-radius: 999px;
            margin: 2px 4px 2px 0;
            border: 1px solid var(--border-color);
            font-size: 10px;
            letter-spacing: .3px;
        }

        #proximitySummary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 6px;
            margin-bottom: 8px;
        }

        .prox-stat {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            padding: 6px 8px;
            border-radius: 8px;
        }

        .prox-stat .k {
            display: block;
            font-size: 10px;
            opacity: .6;
            text-transform: uppercase;
        }

        .prox-stat .v {
            font-size: 12px;
            font-weight: 600;
        }

        .proximity-empty {
            opacity: .6;
            font-style: italic;
        }

        /* --- Slice 2 Additions --- */
        .proximity-badge {
            background: var(--accent-2);
            color: #fff;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 999px;
            margin-left: 8px;
            letter-spacing: .5px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .proximity-badge span {
            font-weight: 600;
        }

        #proximityFilters {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 4px 0 10px;
        }

        #proximityFilters button {
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            color: var(--muted);
            padding: 4px 8px;
            font-size: 10px;
            border-radius: 6px;
            cursor: pointer;
            letter-spacing: .4px;
        }

        #proximityFilters button.active {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--glass);
        }

        #proximitySparkline {
            width: 100%;
            height: 45px;
            display: block;
            margin: 2px 0 8px;
        }

        /* Slice 3: Proximity controls and tooltip */
        #proximityControls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        #proximityControls .left,
        #proximityControls .right {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        #proximityControls button {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid var(--border-color);
            background: var(--panel-bg);
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
        }

        #proximityControls button:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        #proximitySparklineTooltip {
            position: fixed;
            display: none;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            z-index: 9999;
            white-space: nowrap;
        }

        .threshold-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 6px;
        }

        .threshold-chips .chip {
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 999px;
            background: var(--glass-2);
            border: 1px solid var(--border-color);
            letter-spacing: .4px;
        }

        .chip-lock {
            border-color: var(--accent-2);
        }

        .chip-strong {
            border-color: var(--accent);
        }

        .chip-moderate {
            border-color: var(--warn);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>

    <script>
        // Fix TWEEN reference for UMD version
        if (typeof TWEEN === 'undefined' && typeof window.TWEEN !== 'undefined') {
            TWEEN = window.TWEEN;
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "d3-delaunay": "https://cdn.skypack.dev/d3-delaunay"
            }
        }
    </script>
</head>

<body>

    <div class="ui-overlay">
        <header>
            <div class="brand">E8 Mind-Crystal <span>// M23 Enhanced Real-Time</span></div>
            <div style="display:flex; align-items:center; gap:12px;">
                <div class="status-tag memory-stats" style="font-size: 11px; padding: 3px 8px;">
                    <span class="memory-count">0</span> nodes | <span class="graph-links-count">0</span> links
                </div>
                <div class="status-tag" id="runTag">OFFLINE</div>
                <div class="status-tag psi-entropy-badge"
                    style="background: rgba(199, 146, 234, 0.15); color: #c792ea; border-color: rgba(199, 146, 234, 0.25);">
                    Ψ: <span>0.000</span>
                </div>
                <button id="themeToggle" class="theme-toggle-btn">Light</button>
            </div>
        </header>

        <aside class="left-panel panel">
            <div class="panel-header">
                <div class="panel-title">System Vitals</div>
            </div>
            <div class="panel-content">
                <div class="weather-box">
                    <div class="row"><span class="label">Weather</span><span class="value" id="wx-mood">-</span></div>
                    <div class="row"><span class="label">Region</span><span class="value" id="wx-region">-</span></div>
                    <div class="row"><span class="label">BH Pressure</span><span class="value"
                            id="wx-pressure">0.00</span></div>
                </div>
                <div style="margin-top: 16px; display:flex; gap:14px; flex-wrap:wrap;">
                    <div class="ring"><canvas width="92" height="92" id="ringPressure"></canvas>
                        <div class="ring-label">Collapse</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringTeacher"></canvas>
                        <div class="ring-label">Teacher</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringExplorer"></canvas>
                        <div class="ring-label">Explorer</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringReward"></canvas>
                        <div class="ring-label">Reward</div>
                    </div>
                </div>

                <div style="margin-top: 16px">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Live Mood State</div>
                    <div class="weather-box">
                        <div class="row"><span class="label">Mood Vector</span><span class="value mood-vector">[0.00,
                                0.00, 0.00]</span></div>
                        <div class="row"><span class="label">Symbolic Weather</span><span class="value"
                                id="symbolic-weather">Clear</span></div>
                        <div class="row"><span class="label">Environment</span><span class="value"
                                id="environment-theme">Default</span></div>
                    </div>
                    <div style="margin-top: 8px;">
                        <div class="row"><span class="label">Intensity</span><progress id="mood-intensity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Entropy</span><progress id="mood-entropy" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Coherence</span><progress id="mood-coherence" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Positivity</span><progress id="mood-positivity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Fluidity</span><progress id="mood-fluidity" max="1"
                                value="0.5" style="width:160px"></progress></div>
                        <div class="row"><span class="label">Intelligibility</span><progress id="mood-intelligibility"
                                max="1" value="0.5" style="width:160px"></progress></div>
                    </div>
                </div>

                <div style="margin-top: 16px;">
                    <div class="panel-title" style="font-size: 11px; margin-bottom: 4px;">Dialogue</div>
                    <div class="weather-box">
                        <div class="row" style="align-items: flex-start;"><span class="label">Teacher</span><span
                                class="value" id="teacher-question">-</span></div>
                        <div class="row" style="align-items: flex-start; margin-top: 8px;"><span
                                class="label">Explorer</span><span class="value" id="explorer-answer">-</span></div>
                    </div>
                </div>
            </div>
            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Quantum Attention</div>
            </div>
            <div class="panel-content">
                <div style="display:flex; gap:14px; flex-wrap:wrap;">
                    <div class="ring"><canvas width="92" height="92" id="ringPsi"></canvas>
                        <div class="ring-label">Psi Entropy</div>
                    </div>
                    <div class="ring"><canvas width="92" height="92" id="ringLambda"></canvas>
                        <div class="ring-label">Lambda (L<->V)</div>
                    </div>
                </div>
                <div class="weather-box" style="margin-top:10px;">
                    <div class="row"><span class="label">Psi Entropy</span><span class="value" id="val-psi">N/A</span>
                    </div>
                    <div class="row"><span class="label">Lambda (Laplacian vs Potential)</span><span class="value"
                            id="val-lam">N/A</span></div>
                    <div class="row"><span class="label">Disagreement</span><span class="value"
                            id="val-disagreement">N/A</span></div>
                    <div class="row" style="margin-top: 6px; opacity: 0.6;"><span class="label"
                            style="font-style: italic;">Engine Params</span><span class="value"></span></div>
                    <div class="row"><span class="label">Q. Time Step (dt)</span><span class="value"
                            id="val-q-dt">N/A</span></div>
                    <div class="row"><span class="label">Q. Hamiltonian (gamma)</span><span class="value"
                            id="val-q-gamma">N/A</span></div>
                    <div class="row"><span class="label">Q. Dephasing</span><span class="value"
                            id="val-q-dephase">N/A</span></div>
                </div>
            </div>
            <div class="panel-header" style="border-top:1px solid var(--border-color);">
                <div class="panel-title">Goals Field</div>
            </div>
            <div class="panel-content" id="goalsList"></div>
        </aside>

        <div id="tetraPanel" class="panel">
            <div class="panel-header">
                <div class="panel-title">E8 Lattice Projection</div>
            </div>
            <div class="panel-content no-padding">
                <canvas id="tetraCanvas"></canvas>
            </div>
        </div>

        <aside class="right-panel panel">
            <div class="tab-header">
                <button class="tab-btn active" data-tab="dynamics">Core Dynamics</button>
                <button class="tab-btn" data-tab="insights">System Insights</button>
            </div>

            <div id="tab-dynamics" class="tab-content active">
                <div class="panel-header">
                    <div class="panel-title">Encoder</div>
                    <button class="collapse-btn" data-collapse="encoder">-</button>
                </div>
                <div class="panel-content" data-section="encoder" style="font-size:12px; flex-grow: 0; flex-shrink: 0;">
                    <div class="weather-box">
                        <div class="row"><span class="label">Autoencoder</span><span class="value"
                                id="encoder-status">Untrained</span></div>
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Discovery Metrics</div>
                    <button class="collapse-btn" data-collapse="discovery">-</button>
                </div>
                <div class="panel-content" data-section="discovery">
                    <div class="weather-box">
                        <div class="row"><span class="label">Novelty</span><span class="value"
                                id="val-novelty">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-novelty" style="margin-top:6px;"></div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Compression Delta</span><span class="value"
                                id="val-compression">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-compression" style="margin-top:6px;"></div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Disagreement</span><span class="value"
                                id="val-discovery-disagreement">N/A</span></div>
                    </div>
                    <div class="weather-box" id="spark-disagreement" style="margin-top:6px;"></div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Shell Dynamics</div>
                    <button class="collapse-btn" data-collapse="shell-dynamics">-</button>
                </div>
                <div class="panel-content" data-section="shell-dynamics">
                    <div class="weather-box">
                        <div class="row"><span class="label">Global Tension</span><span class="value"
                                id="global-tension">0.000</span></div>
                        <div class="row"><span class="label">KDTree Failures</span><span class="value"
                                id="val-kdtree">N/A</span></div>
                    </div>
                    <div id="shellDynamicsGrid" style="margin-top: 12px;">
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Fluid Consciousness</div>
                    <button class="collapse-btn" data-collapse="fluid">-</button>
                </div>
                <div class="panel-content" data-section="fluid">
                    <div class="weather-box">
                        <div class="row"><span class="label">Fluid Steps</span><span class="value"
                                id="m20-fluid-steps">0</span></div>
                        <div class="row"><span class="label">Valence Updates</span><span class="value"
                                id="m20-valence-updates">0</span></div>
                        <div class="row"><span class="label">Energy Explorations</span><span class="value"
                                id="m20-energy-explorations">0</span></div>
                        <div class="row"><span class="label">Topology Adaptations</span><span class="value"
                                id="m20-topology-adaptations">0</span></div>
                        <div class="row"><span class="label">Recursive Implementations</span><span class="value"
                                id="m20-recursive-implementations">0</span></div>
                    </div>
                    <div class="weather-box" style="margin-top:10px;">
                        <div class="row"><span class="label">Flow Rate</span><span class="value"
                                id="m20-flow-rate">0.000</span></div>
                        <div class="row"><span class="label">Spacetime Curvature</span><span class="value"
                                id="m20-curvature">0.000</span></div>
                    </div>
                </div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Mantle Metrics</div>
                    <button class="collapse-btn" data-collapse="mantle">-</button>
                </div>
                <div class="panel-content" data-section="mantle">
                    <div class="weather-box">
                        <div class="row"><span class="label">Flux</span><span class="value"
                                id="mantle-flux">1.000</span></div>
                        <div class="row"><span class="label">Curvature</span><span class="value"
                                id="mantle-curvature">6.000</span></div>
                        <div class="row"><span class="label">Flow</span><span class="value"
                                id="mantle-flow">1.500</span></div>
                        <div class="row"><span class="label">Tension</span><span class="value"
                                id="mantle-tension">0.700</span></div>
                    </div>
                </div>
            </div>

            <div id="tab-insights" class="tab-content">
                <div class="panel-header">
                    <div class="panel-title">Ingestion Feed</div>
                    <button class="collapse-btn" data-collapse="ingestion">-</button>
                </div>
                <div class="panel-content" data-section="ingestion" id="ingestionFeed">...</div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title" style="display:flex; align-items:center; gap:6px;">Adaptive Proximity <div
                            id="proximityBadge" class="proximity-badge" style="display:none;">LOCK <span
                                id="proximityBadgeCount">0</span></div>
                    </div>
                    <button class="collapse-btn" data-collapse="proximity">-</button>
                </div>
                <div class="panel-content" data-section="proximity" id="proximityPanel">
                    <div id="proximitySummary"></div>
                    <div id="proximityControls">
                        <div class="left">
                            <span class="chip chip-lock" id="proxCountLock">LOCK 0</span>
                            <span class="chip chip-strong" id="proxCountStrong">STRONG 0</span>
                            <span class="chip chip-moderate" id="proxCountModerate">MODERATE 0</span>
                            <span class="chip" id="proxCountWeak" style="display:none;">WEAK 0</span>
                            <span class="chip" id="proxCountNoise" style="display:none;">NOISE 0</span>
                        </div>
                        <div class="right">
                            <button id="proxResetFilters">Reset Filters</button>
                            <button id="proxExportCsv">Export CSV</button>
                        </div>
                    </div>
                    <div class="threshold-chips" id="proximityThresholdChips"></div>
                    <canvas id="proximitySparkline"></canvas>
                    <div id="proximityFilters"></div>
                    <div id="proximityEventsList" class="weather-box"
                        style="background:transparent; border:none; padding:0;"></div>
                </div>
                <div id="proximitySparklineTooltip"></div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Validation Lab</div>
                    <button class="collapse-btn" data-collapse="validation">-</button>
                </div>
                <div class="panel-content" data-section="validation" id="validationLab">...</div>
                <div class="panel-header" style="border-top:1px solid var(--border-color);">
                    <div class="panel-title">Insight Holocron</div>
                    <button class="collapse-btn" data-collapse="holocron">-</button>
                </div>
                <div class="panel-content" data-section="holocron" id="insightHolocron">...</div>
            </div>
        </aside>

        <footer class="footer">
            <div id="status">Initializing...</div>
        </footer>
    </div>

    <script type="module">
        /*
         * PATCH: This version handles missing telemetry data gracefully.
         */
        // --- Non-blocking processing of insight bursts ---
        const insightsQueue = [];
        let insightsIdleHandle = null;

        // Global utility: hexToRgba (hoisted once)
        function hexToRgba(hex, a = 1) {
            try {
                if (!hex) return `rgba(255,255,255,${a})`;
                hex = String(hex).trim();
                if (hex.startsWith('var(')) {
                    const m = /var\((--[^)]+)\)/.exec(hex);
                    if (m) {
                        const styles = getComputedStyle(document.documentElement);
                        const resolved = styles.getPropertyValue(m[1]).trim();
                        if (resolved) hex = resolved;
                    }
                }
                if (!hex.startsWith('#')) return `rgba(255,255,255,${a})`;
                const raw = hex.slice(1);
                let r, g, b;
                if (raw.length === 3 || raw.length === 4) {
                    r = parseInt(raw[0] + raw[0], 16);
                    g = parseInt(raw[1] + raw[1], 16);
                    b = parseInt(raw[2] + raw[2], 16);
                } else if (raw.length === 6 || raw.length === 8) {
                    r = parseInt(raw.slice(0, 2), 16);
                    g = parseInt(raw.slice(2, 4), 16);
                    b = parseInt(raw.slice(4, 6), 16);
                } else {
                    return `rgba(255,255,255,${a})`;
                }
                const alpha = Math.max(0, Math.min(1, a));
                return `rgba(${r},${g},${b},${alpha})`;
            } catch (_) {
                return `rgba(255,255,255,${a})`;
            }
        }

        // Readiness queue for early tetra insertions arriving before tetra system init
        const earlyTetraQueue = [];
        function enqueueEarlyTetra(data) {
            earlyTetraQueue.push(data);
        }
        function flushEarlyTetras() {
            // Explicit, defensive readiness check for tetra system before applying queued updates.
            const meshes = Array.isArray(window.tetraMeshes) ? window.tetraMeshes : [];
            const meshesAvailable = meshes.length > 0 && meshes.every(m => m && m.isInstancedMesh === true || m instanceof THREE.InstancedMesh);
            // require both initialization flags and at least one instanced mesh available
            if (!tetraInitialized || !tetraMeshesReady || !meshesAvailable) return;

            if (earlyTetraQueue.length) console.log(`[tetra] Flushing ${earlyTetraQueue.length} queued tetra updates`);
            while (earlyTetraQueue.length) {
                const d = earlyTetraQueue.shift();
                try { upsertInsightTetra(d); } catch (e) { console.warn('Early tetra flush failed', e); }
            }
        }

        function enqueueInsights(list) {
            for (const item of list) insightsQueue.push(item);
            pumpInsights();
        }

        function pumpInsights() {
            if (insightsIdleHandle) return;

            const consume = (deadline) => {
                let count = 0;
                const MAX_PER_SLICE = 8;

                while (insightsQueue.length && count < MAX_PER_SLICE && (!deadline || deadline.timeRemaining() > 5)) {
                    upsertInsightTetra(insightsQueue.shift());
                    count++;
                }

                insightsIdleHandle = null;

                if (insightsQueue.length) {
                    if ('requestIdleCallback' in window) {
                        insightsIdleHandle = requestIdleCallback(consume, {
                            timeout: 33
                        });
                    } else {
                        insightsIdleHandle = setTimeout(() => consume(), 0);
                    }
                }
            };

            if ('requestIdleCallback' in window) {
                insightsIdleHandle = requestIdleCallback(consume, {
                    timeout: 33
                });
            } else {
                insightsIdleHandle = setTimeout(() => consume(), 0);
            }
        }

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Delaunay } from 'd3-delaunay';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';

        // Global variables initialization
        let __sseAttempts = 0;
        let __frameCounter = 0;
        const TETRA_LOCAL_SIZE = 0.8;

        // Global declarations for fluid visualizer and tetra rotation state
        let fluidVisualizer = null;
        let tetraRotationState = { current: new Map() };

        // Helper function to check TWEEN availability
        function createTween(object) {
            if (typeof TWEEN !== 'undefined' && TWEEN.Tween) {
                return new TWEEN.Tween(object);
            }
            console.warn('TWEEN library not available, animation will be skipped');
            // Return a mock TWEEN object that supports chaining
            const mockTween = {
                to: () => mockTween,
                easing: () => mockTween,
                onUpdate: () => mockTween,
                onComplete: () => mockTween,
                start: () => mockTween,
                stop: () => mockTween
            };
            return mockTween;
        }

        const API_BASE_URL = new URLSearchParams(location.search).get('api') || (location.origin && location.origin.startsWith('http') ? location.origin : 'http://localhost:7870');
        const API = {
            telemetryStream: `${API_BASE_URL}/api/telemetry/stream`,
        };
        const TELEMETRY_CANDIDATES = [
            `${API_BASE_URL}/api/telemetry/stream`,
            `${API_BASE_URL}/api/telemetry`,
            `${API_BASE_URL}/telemetry/stream`,
            `${API_BASE_URL}/telemetry`
        ];
        let telemetryTry = 0;

        const TEACHER_CYCLE_LENGTH = 25;

        const state = {
            rotors: {
                '3': { angle: 0, target: 0, vel: 0 },
                '5': { angle: 0, target: 0, vel: 0 },
                '8': { angle: 0, target: 0, vel: 0 }
            },
            shellSparklines: new Map(),
            noveltySeries: [],
            compressionSeries: [],
            disagreementSeries: [],
            smooth: {
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                moodPositivity: 0.5,
                moodFluidity: 0.5,
                moodIntelligibility: 0.5,
                wxPressure: 0,
                globalTension: 0,
                psi: 0,
                lam: 0,
                novelty: 0,
                compression: 0,
                disagreement: 0
            },
            targets: {
                pressure: 0,
                teacher: 0,
                explorer: 0,
                reward: 0,
                moodIntensity: 0.5,
                moodEntropy: 0.5,
                moodCoherence: 0.5,
                moodPositivity: 0.5,
                moodFluidity: 0.5,
                moodIntelligibility: 0.5,
                wxPressure: 0,
                globalTension: 0,
                psi: 0,
                lam: 0,
                novelty: 0,
                compression: 0,
                disagreement: 0
            },
            proximity: {
                events: [],
                stats: null,
                lastEvent: null,
                activeTiers: new Set(['lock', 'strong', 'moderate', 'weak']),
                distanceSeries: [],
                maxSeries: 180,
                tierCounts: { lock: 0, strong: 0, moderate: 0, weak: 0 }
            }
        };
        // Initialize rotors with immediate base spin for visual feedback
        Object.values(state.rotors).forEach((r, i) => {
            r.hadTarget = false;
            r.baseSpin = [0.008, 0.012, 0.018][i]; // Immediate base spin
        });
        console.log('[rotor] Initialized rotors with base spin:', state.rotors);

        let clock = new THREE.Clock();
        const DOM = {
            moodIntensity: document.getElementById('mood-intensity'),
            moodEntropy: document.getElementById('mood-entropy'),
            moodCoherence: document.getElementById('mood-coherence'),
            moodPositivity: document.getElementById('mood-positivity'),
            moodFluidity: document.getElementById('mood-fluidity'),
            moodIntelligibility: document.getElementById('mood-intelligibility'),
            encoderStatus: document.getElementById('encoder-status'),
            globalTension: document.getElementById('global-tension'),
            m20FluidSteps: document.getElementById('m20-fluid-steps'),
            m20ValenceUpdates: document.getElementById('m20-valence-updates'),
            m20EnergyExplorations: document.getElementById('m20-energy-explorations'),
            m20TopologyAdaptations: document.getElementById('m20-topology-adaptations'),
            m20RecursiveImplementations: document.getElementById('m20-recursive-implementations'),
            m20FlowRate: document.getElementById('m20-flow-rate'),
            m20Curvature: document.getElementById('m20-curvature'),
            ringReward: document.getElementById('ringReward'),
            runTag: document.getElementById('runTag'),
            status: document.getElementById('status'),
            themeToggle: document.getElementById('themeToggle'),
            tetraCanvas: document.getElementById('tetraCanvas'),
            wxMood: document.getElementById('wx-mood'),
            wxRegion: document.getElementById('wx-region'),
            wxPressure: document.getElementById('wx-pressure'),
            ringPressure: document.getElementById('ringPressure'),
            ringTeacher: document.getElementById('ringTeacher'),
            ringExplorer: document.getElementById('ringExplorer'),
            goalsList: document.getElementById('goalsList'),
            teacherQuestion: document.getElementById('teacher-question'),
            explorerAnswer: document.getElementById('explorer-answer'),
            ingestionFeed: document.getElementById('ingestionFeed'),
            validationLab: document.getElementById('validationLab'),
            insightHolocron: document.getElementById('insightHolocron'),
            ringPsi: document.getElementById('ringPsi'),
            ringLambda: document.getElementById('ringLambda'),
            valPsi: document.getElementById('val-psi'),
            valLam: document.getElementById('val-lam'),
            valQADisagreement: document.getElementById('val-disagreement'),
            valDisagreement: document.getElementById('val-discovery-disagreement'),
            valNovelty: document.getElementById('val-novelty'),
            valCompression: document.getElementById('val-compression'),
            sparkNovelty: document.getElementById('spark-novelty'),
            sparkCompression: document.getElementById('spark-compression'),
            sparkDisagreement: document.getElementById('spark-disagreement'),
            shellDynamicsGrid: document.getElementById('shellDynamicsGrid'), // New unified container
            valKDTree: document.getElementById('val-kdtree'),
            valQDt: document.getElementById('val-q-dt'),
            valQGamma: document.getElementById('val-q-gamma'),
            valQDephase: document.getElementById('val-q-dephase'),
            proximityPanel: document.getElementById('proximityPanel'),
            proximitySummary: document.getElementById('proximitySummary'),
            proximityEventsList: document.getElementById('proximityEventsList'),
            proximityBadge: document.getElementById('proximityBadge'),
            proximityBadgeCount: document.getElementById('proximityBadgeCount'),
            proximityFilters: document.getElementById('proximityFilters'),
            proximitySparkline: document.getElementById('proximitySparkline'),
            proximityThresholdChips: document.getElementById('proximityThresholdChips'),
            proxCountLock: document.getElementById('proxCountLock'),
            proxCountStrong: document.getElementById('proxCountStrong'),
            proxCountModerate: document.getElementById('proxCountModerate'),
            proxResetFilters: document.getElementById('proxResetFilters'),
            proxExportCsv: document.getElementById('proxExportCsv'),
            proximitySparklineTooltip: document.getElementById('proximitySparklineTooltip'),
            mantleFlux: document.getElementById('mantle-flux'),
            mantleCurvature: document.getElementById('mantle-curvature'),
            mantleFlow: document.getElementById('mantle-flow'),
            mantleTension: document.getElementById('mantle-tension'),
        };

        class FluidLatticeVisualizer {
            constructor(scene, camera, renderer) {
                this.scene = scene;
                this.camera = camera;
                this.renderer = renderer;
                this.root = new THREE.Group();
                this.root.name = 'FluidLatticeVisualizer';
                this.scene.add(this.root);
                this.pointGroup = new THREE.Group();
                this.edgeGroup = new THREE.Group();
                this.streamlineGroup = new THREE.Group();
                this.root.add(this.pointGroup);
                this.root.add(this.edgeGroup);
                this.root.add(this.streamlineGroup);
                this.latticePoints = [];
                this.flowParticles = [];
                this.projectionMatrix = this.createProjectionMatrix();
                this.flowSpeed = 1.4;
                this.flowSpeedTarget = this.flowSpeed;
                this.rotationSpeed = 0.6;
                this.rotationSpeedTarget = this.rotationSpeed;
                this.streamlineColor = 0x7aa2ff;
                this.latticeColor = 0x4a90e2;
                this.time = 0;
                this.lastMetrics = {};
                this.refreshTheme();
            }

            refreshTheme() {
                try {
                    const styles = getComputedStyle(document.documentElement);
                    const glow = styles.getPropertyValue('--glow').trim();
                    const accent = styles.getPropertyValue('--accent').trim();
                    if (glow) {
                        this.streamlineColor = new THREE.Color(glow).getHex();
                    }
                    if (accent) {
                        const lattice = new THREE.Color(accent);
                        this.latticeColor = lattice.offsetHSL(0, -0.08, 0).getHex();
                    }
                    this.recolorMaterials();
                } catch (err) {
                    console.debug('FluidVisualizer theme refresh failed', err);
                }
            }

            createProjectionMatrix() {
                const matrix = [];
                for (let i = 0; i < 8; i++) {
                    const row = [];
                    for (let j = 0; j < 3; j++) {
                        const u1 = Math.random() || 1e-6;
                        const u2 = Math.random();
                        row.push(Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.35);
                    }
                    matrix.push(row);
                }
                return matrix;
            }

            projectTo3D(vec) {
                const out = [0, 0, 0];
                for (let i = 0; i < Math.min(vec.length, this.projectionMatrix.length); i++) {
                    out[0] += vec[i] * this.projectionMatrix[i][0];
                    out[1] += vec[i] * this.projectionMatrix[i][1];
                    out[2] += vec[i] * this.projectionMatrix[i][2];
                }
                return out;
            }

            generateFallbackRoots() {
                const roots = [];
                for (let i = 0; i < 8; i++) {
                    for (let j = i + 1; j < 8; j++) {
                        for (const [a, b] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                            const vec = new Array(8).fill(0);
                            vec[i] = a;
                            vec[j] = b;
                            roots.push(vec);
                        }
                    }
                }
                return roots;
            }

            normalizePoints(points) {
                if (!points.length) return;
                const center = new THREE.Vector3();
                points.forEach(p => center.add(p));
                center.divideScalar(points.length || 1);
                let radius = 0;
                points.forEach(p => { radius = Math.max(radius, p.distanceTo(center)); });
                const scale = radius > 0 ? 8 / radius : 1;
                points.forEach(p => p.sub(center).multiplyScalar(scale));
            }

            setBlueprintLattice(points) {
                if (!Array.isArray(points) || !points.length) return;
                this.latticePoints = points.map(p => p.clone ? p.clone() : new THREE.Vector3(p[0] || 0, p[1] || 0, p[2] || 0));
                this.normalizePoints(this.latticePoints);
                this.buildLatticeGeometry();
                this.initializeFlowField(true);
            }

            initializeFluidVisualization() {
                if (!this.latticePoints.length) {
                    try {
                        const roots = typeof generateE8Roots === 'function' ? generateE8Roots() : this.generateFallbackRoots();
                        this.latticePoints = roots.map(root => {
                            const projected = this.projectTo3D(root);
                            return new THREE.Vector3(projected[0], projected[1], projected[2]);
                        });
                        this.normalizePoints(this.latticePoints);
                    } catch (err) {
                        console.warn('FluidVisualizer: E8 lattice generation failed', err);
                        this.latticePoints = [];
                    }
                }
                this.buildLatticeGeometry();
                this.initializeFlowField(true);
            }

            buildLatticeGeometry() {
                this.clearGroup(this.pointGroup);
                this.clearGroup(this.edgeGroup);
                if (!this.latticePoints.length) return;
                const positions = new Float32Array(this.latticePoints.length * 3);
                this.latticePoints.forEach((p, i) => p.toArray(positions, i * 3));
                const pointGeo = new THREE.BufferGeometry();
                pointGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const pointMat = new THREE.PointsMaterial({
                    size: 0.05,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.85,
                    color: this.latticeColor
                });
                this.pointGroup.add(new THREE.Points(pointGeo, pointMat));

                const edgePositions = this.computeEdgePositions();
                if (edgePositions.length) {
                    const edgeGeo = new THREE.BufferGeometry();
                    edgeGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(edgePositions), 3));
                    const edgeMat = new THREE.LineBasicMaterial({
                        color: this.latticeColor,
                        transparent: true,
                        opacity: 0.15
                    });
                    this.edgeGroup.add(new THREE.LineSegments(edgeGeo, edgeMat));
                }
            }

            computeEdgePositions() {
                if (!this.latticePoints.length) return [];
                const data = [];
                const seen = new Set();
                const maxNeighbors = Math.min(6, this.latticePoints.length - 1);
                for (let i = 0; i < this.latticePoints.length; i++) {
                    const neighbors = this.findNearestIndices(i, maxNeighbors);
                    for (const j of neighbors) {
                        const key = i < j ? `${i}-${j}` : `${j}-${i}`;
                        if (seen.has(key)) continue;
                        seen.add(key);
                        const a = this.latticePoints[i];
                        const b = this.latticePoints[j];
                        data.push(a.x, a.y, a.z, b.x, b.y, b.z);
                    }
                }
                return data;
            }

            findNearestIndices(index, count) {
                const base = this.latticePoints[index];
                const entries = [];
                for (let i = 0; i < this.latticePoints.length; i++) {
                    if (i === index) continue;
                    entries.push({ i, d: base.distanceToSquared(this.latticePoints[i]) });
                }
                entries.sort((a, b) => a.d - b.d);
                return entries.slice(0, count).map(e => e.i);
            }

            initializeFlowField(force = false) {
                this.clearGroup(this.streamlineGroup);
                this.flowParticles = [];
                if (!this.latticePoints.length) return;
                const streamlineCount = Math.min(24, Math.max(6, Math.floor(this.latticePoints.length / 6)));
                const particleGeometry = new THREE.SphereGeometry(0.05, 10, 10);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: this.streamlineColor, transparent: true, opacity: 0.6 });
                const lineMaterial = new THREE.LineBasicMaterial({ color: this.streamlineColor, transparent: true, opacity: 0.12 });
                for (let i = 0; i < streamlineCount; i++) {
                    const path = this.sampleStreamlinePath();
                    if (path.length < 2) continue;
                    const curve = new THREE.CatmullRomCurve3(path, false, 'centripetal');
                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(path), lineMaterial.clone());
                    this.streamlineGroup.add(line);
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                    this.streamlineGroup.add(particle);
                    this.flowParticles.push({
                        mesh: particle,
                        curve,
                        t: Math.random(),
                        speed: 0.6 + Math.random() * 0.8,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            sampleStreamlinePath() {
                if (!this.latticePoints.length) return [];
                const path = [];
                let index = Math.floor(Math.random() * this.latticePoints.length);
                path.push(this.latticePoints[index].clone());
                const visited = new Set([index]);
                const steps = 4;
                for (let i = 0; i < steps; i++) {
                    const neighbors = this.findNearestIndices(index, 6).filter(idx => !visited.has(idx));
                    if (!neighbors.length) break;
                    index = neighbors[Math.floor(Math.random() * neighbors.length)];
                    visited.add(index);
                    path.push(this.latticePoints[index].clone());
                }
                return path;
            }

            updateWithMetrics(metrics = {}) {
                // Use mantle flow metric to modulate flow speed (overrides m20 flow_rate if available)
                const mantleFlow = state.mantle ? (state.mantle.flow || 1.5) : 1.5;
                const hasFlow = metrics && Object.prototype.hasOwnProperty.call(metrics, 'consciousness_flow_rate');
                if (hasFlow && Number.isFinite(metrics.consciousness_flow_rate)) {
                    this.flowSpeedTarget = 0.6 + Math.max(0, metrics.consciousness_flow_rate) * (mantleFlow / 1.5);
                } else {
                    this.flowSpeedTarget = 1.4 * (mantleFlow / 1.5);
                }

                // Use mantle curvature metric to modulate rotation speed (overrides m20 curvature if available)
                const mantleCurvature = state.mantle ? (state.mantle.curvature || 6.0) : 6.0;
                const hasCurvature = metrics && Object.prototype.hasOwnProperty.call(metrics, 'spacetime_curvature');
                if (hasCurvature && Number.isFinite(metrics.spacetime_curvature)) {
                    this.rotationSpeedTarget = 0.3 + Math.min(Math.max(metrics.spacetime_curvature, 0), 40) * 0.04 * (mantleCurvature / 6.0);
                } else {
                    this.rotationSpeedTarget = 0.6 * (mantleCurvature / 6.0);
                }

                const activity = (metrics.fluid_steps || 0) + (metrics.valence_updates || 0) + (metrics.energy_explorations || 0);
                const opacity = 0.12 + Math.min(activity, 400) * 0.0003;
                this.streamlineGroup.children.forEach(child => {
                    if (child.material && typeof child.material.opacity === 'number') {
                        child.material.opacity = Math.min(0.4, opacity);
                    }
                });
            }

            update(delta) {
                if (!this.root) return;
                this.time = (this.time || 0) + delta;
                const lerp = Math.min(1, delta * 2.4);
                this.flowSpeed += (this.flowSpeedTarget - this.flowSpeed) * lerp;
                this.rotationSpeed += (this.rotationSpeedTarget - this.rotationSpeed) * lerp;
                this.root.rotation.y += delta * 0.22 * this.rotationSpeed;
                this.root.rotation.x += delta * 0.05 * Math.sin(this.time * 0.35);

                for (const particle of this.flowParticles) {
                    particle.t = (particle.t + delta * this.flowSpeed * particle.speed * 0.08) % 1;
                    const position = particle.curve.getPointAt(particle.t);
                    const look = particle.curve.getPointAt((particle.t + 0.015) % 1);
                    particle.mesh.position.copy(position);
                    particle.mesh.lookAt(look);
                    const pulse = 0.45 + 0.45 * Math.sin(this.time * 2.0 + particle.phase);
                    particle.mesh.material.opacity = 0.3 + pulse * 0.4;
                }
            }

            recolorMaterials() {
                this.pointGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.latticeColor);
                });
                this.edgeGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.latticeColor);
                });
                this.streamlineGroup.traverse(obj => {
                    if (obj.material && obj.material.color) obj.material.color.setHex(this.streamlineColor);
                });
            }

            clearGroup(group) {
                while (group.children.length) {
                    const child = group.children.pop();
                    if (child.geometry && child.geometry.dispose) child.geometry.dispose();
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat && mat.dispose && mat.dispose());
                    } else if (child.material && child.material.dispose) {
                        child.material.dispose();
                    }
                }
            }
        }
        // --- START: Tetra Mode 3D Scene ---

        // Three.js scene setup for tetra mode - lazy initialization
        let tetraRenderer = null;
        let tetraScene = null;
        let tetraCamera = null;
        let composer, outlinePass;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        // Global tetra system state
        let tetraInitialized = false;
        let tetraMeshesReady = false;

        // Instanced tetra system for performance
        let tetraMeshes = [];
        let tetraInstanceData = [];
        const tetraIndexById = new Map();
        const MAX_INSTANCES = 1000;
        const MAX_TWEEN_DURATION = 1500;

        // ==== Kaleidoscope Tunables (Ring Layout / Rotors) ====
        const LAYOUT_MODE = 'projected';
        const RING_RADIUS = 14;
        const DEPTH_SCALE = 2.0;
        const MIN_SCALE = 0.12;
        const MAX_SCALE = 0.25;

        // Global rotation speed multiplier for easy tuning (reduced to prevent bugs)
        const GLOBAL_ROTATION_SPEED_MULTIPLIER = 1.2;

        // Reusable temps
        const VEC_Z = new THREE.Vector3(0, 0, 1);
        const TMP_Q = new THREE.Quaternion();
        const TMP_M = new THREE.Matrix4();
        const TMP_V = new THREE.Vector3();

        // Throttled TWEEN update
        const throttledTweenUpdate = (() => {
            let lastTime = 0;
            return (time) => {
                if (time - lastTime > 16) { // roughly 60fps
                    if (typeof TWEEN !== 'undefined' && TWEEN.update) {
                        TWEEN.update(time);
                    }
                    lastTime = time;
                }
            }
        })();

        async function initializeTetraMode() {
            if (tetraInitialized) return;

            tetraRenderer = new THREE.WebGLRenderer({
                canvas: DOM.tetraCanvas,
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance',
                stencil: false
            });
            tetraRenderer.outputColorSpace = THREE.SRGBColorSpace;
            tetraRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            tetraRenderer.toneMappingExposure = 1.15;

            let dpr = Math.min(window.devicePixelRatio, 2.0);
            tetraRenderer.setPixelRatio(dpr);

            tetraScene = new THREE.Scene();
            tetraScene.fog = new THREE.FogExp2(0x0b1321, 0.012);

            function applyThemeBackground() {
                const cssBg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0b0f17';
                const bg = new THREE.Color(cssBg);
                tetraScene.background = bg;
                tetraRenderer.setClearColor(bg, 1);
                tetraRenderer.setClearAlpha(1);
                const isLight = document.documentElement.getAttribute('data-theme') === 'light';
                if (tetraScene.fog) {
                    tetraScene.fog.color.set(bg);
                    tetraScene.fog.density = isLight ? 0.007 : 0.012;
                }
            }
            window.applyThemeBackground = applyThemeBackground;
            applyThemeBackground();

            const rect = DOM.tetraCanvas.parentElement.getBoundingClientRect();
            tetraCamera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.2, 120);
            tetraCamera.position.set(0, 0, 14);
            tetraCamera.updateProjectionMatrix();

            fluidVisualizer = new FluidLatticeVisualizer(tetraScene, tetraCamera, tetraRenderer);
            fluidVisualizer.initializeFluidVisualization();
            window.fluidVisualizer = fluidVisualizer;

            const pmrem = new THREE.PMREMGenerator(tetraRenderer);
            const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
            envTex.generateMipmaps = false;
            envTex.minFilter = THREE.LinearFilter;
            envTex.magFilter = THREE.LinearFilter;
            envTex.needsUpdate = true;
            tetraScene.environment = envTex;

            tetraScene.add(new THREE.HemisphereLight(0xa0d8ef, 0x0b1321, 0.6));
            const key = new THREE.DirectionalLight(0xffffff, 1.2);
            key.position.set(2.5, 4.0, 3.0);
            key.castShadow = true;
            tetraScene.add(key);
            const fill = new THREE.DirectionalLight(0xffffff, 0.6);
            fill.position.set(-3.0, 1.0, 2.5);
            tetraScene.add(fill);
            const rim = new THREE.DirectionalLight(0xffffff, 0.6);
            rim.position.set(-2.0, 0.5, -3.0);
            tetraScene.add(rim);

            const tetraControls = new OrbitControls(tetraCamera, tetraRenderer.domElement);
            tetraControls.enableDamping = true;
            tetraControls.dampingFactor = 0.06;
            tetraControls.minDistance = 0.1;
            tetraControls.maxDistance = 40;
            window.__tetraControls = tetraControls;

            composer = new EffectComposer(tetraRenderer);
            const renderPass = new RenderPass(tetraScene, tetraCamera);
            composer.addPass(renderPass);

            outlinePass = new OutlinePass(new THREE.Vector2(rect.width, rect.height), tetraScene, tetraCamera);
            outlinePass.edgeStrength = 5.0;
            outlinePass.edgeGlow = 0.5;
            outlinePass.edgeThickness = 1.0;
            outlinePass.pulsePeriod = 2;
            outlinePass.visibleEdgeColor.set('#8ef1ff');
            outlinePass.hiddenEdgeColor.set('#192a46');
            composer.addPass(outlinePass);
            try {
                if (composer?.renderTarget1?.texture) {
                    composer.renderTarget1.texture.generateMipmaps = false;
                    composer.renderTarget1.texture.minFilter = THREE.LinearFilter;
                }
                if (composer?.renderTarget2?.texture) {
                    composer.renderTarget2.texture.generateMipmaps = false;
                    composer.renderTarget2.texture.minFilter = THREE.LinearFilter;
                }
            } catch (e) {
                console.warn('Failed to adjust composer render targets', e);
            }

            await createInstancedTetraMesh();

            new ResizeObserver(() => {
                const p = DOM.tetraCanvas.parentElement;
                if (!p) return;
                const w = p.clientWidth; const h = p.clientHeight;
                if (w === 0 || h === 0) return;

                tetraCamera.aspect = w / h;
                tetraCamera.updateProjectionMatrix();

                tetraRenderer.setSize(w, h, false);
                composer.setSize(w, h);
                outlinePass.resolution.set(w, h);
            }).observe(DOM.tetraCanvas.parentElement);

            await ensureLatticeLoaded();
            tetraInitialized = true;
        }

        function generateE8Roots() {
            const roots = new Set();
            for (let i = 0; i < 8; i++) {
                for (let j = i + 1; j < 8; j++) {
                    for (const [s1, s2] of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                        const vec = new Array(8).fill(0); vec[i] = s1; vec[j] = s2; roots.add(vec.join(','));
                    }
                }
            }
            for (let signs = 0; signs < 256; signs++) {
                const vec = [];
                let negCount = 0;
                for (let i = 0; i < 8; i++) {
                    if ((signs >> i) & 1) { vec.push(-0.5); negCount++; } else { vec.push(0.5); }
                }
                if (negCount % 2 === 0) { roots.add(vec.join(',')); }
            }
            return Array.from(roots).map(s => s.split(',').map(Number));
        }

        function createE8ProjectionMatrix() {
            const matrix = [];
            for (let i = 0; i < 8; i++) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const u1 = Math.random(); const u2 = Math.random();
                    row.push(Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.3);
                }
                matrix.push(row);
            }
            return matrix;
        }

        async function generateLatticeTetrahedra() {
            if (latticePoints.length) {
                const selectedPoints = latticePoints.slice(0, Math.min(12, latticePoints.length));
                return selectedPoints.map(p => p.clone().multiplyScalar(TETRA_LOCAL_SIZE * 0.5));
            }
            const e8Roots = generateE8Roots();
            const projMatrix = createE8ProjectionMatrix();
            const points3D = e8Roots.map(root => {
                const x = root.reduce((s, v, i) => s + v * projMatrix[i][0], 0);
                const y = root.reduce((s, v, i) => s + v * projMatrix[i][1], 0);
                const z = root.reduce((s, v, i) => s + v * projMatrix[i][2], 0);
                return new THREE.Vector3(x, y, z);
            });
            const center = new THREE.Vector3();
            points3D.forEach(p => center.add(p));
            center.divideScalar(points3D.length);
            points3D.forEach(p => p.sub(center));
            const maxCoord = Math.max(...points3D.flatMap(p => [Math.abs(p.x), Math.abs(p.y), Math.abs(p.z)]));
            if (maxCoord > 0) points3D.forEach(p => p.multiplyScalar(TETRA_LOCAL_SIZE / maxCoord));
            return points3D.slice(0, 12);
        }

        async function createInstancedTetraMesh() {
            const latticeTetraPoints = await generateLatticeTetrahedra();
            const geometries = [];
            if (latticeTetraPoints.length >= 8) {
                try {
                    const createHullFromIndices = (indices) => {
                        const points = indices.map(i => latticeTetraPoints[i]).filter(Boolean);
                        if (points.length < 4 || tetraVolume(...points.slice(0, 4)) < 0.001) return null;
                        try { return new ConvexGeometry(points); } catch (e) { return null; }
                    };
                    let geo1 = createHullFromIndices([0, 1, 2, 3]); if (geo1) geometries.push(geo1);
                    let geo2 = createHullFromIndices([0, 4, 7, 11]); if (geo2) geometries.push(geo2);
                    let geo3 = createHullFromIndices([1, 5, 8, 10]); if (geo3) geometries.push(geo3);
                    let geo4 = createHullFromIndices([0, 2, 5, 9, 11]); if (geo4) geometries.push(geo4);
                    if (geometries.length === 0) throw new Error("All geometry variants failed.");
                } catch (e) { geometries.length = 0; }
            }
            if (geometries.length === 0) geometries.push(createFallbackTetraGeometry());
            const material = createTetraMaterial();
            const instancesPerGeometry = Math.ceil(MAX_INSTANCES / geometries.length);
            geometries.forEach((geo, idx) => {
                if (!geo?.attributes?.position) return;
                try {
                    geo.computeVertexNormals();
                    geo.computeBoundingSphere();

                    // Convert to non-indexed with vertex colors based on metrics
                    const positions = geo.attributes.position.array;
                    const indices = geo.index ? geo.index.array : null;

                    if (indices) {
                        const newPositions = [];
                        const colors = [];

                        // Generate face colors based on a safe default metric object.
                        // The original code referenced a `tetra` variable which may be undefined
                        // during geometry construction. Use a small deterministic default
                        // so the UI doesn't throw and meshes can be created reliably.
                        const defaultMetric = { rating: 0.5, shell_dim: 8, id: `geo-${idx}` };
                        const baseColor = pastelFromMetrics(defaultMetric); // returns a THREE.Color
                        const faceColors = [
                            baseColor.clone().multiplyScalar(1.2), // slightly brighter
                            baseColor.clone().multiplyScalar(1.0), // base color
                            baseColor.clone().multiplyScalar(0.8), // slightly darker
                            baseColor.clone().multiplyScalar(0.9)  // medium
                        ];

                        for (let i = 0; i < indices.length; i += 3) {
                            const faceIndex = Math.floor(i / 3);
                            const color = faceColors[faceIndex % faceColors.length];
                            for (let j = 0; j < 3; j++) {
                                const idx = indices[i + j];
                                newPositions.push(positions[idx * 3], positions[idx * 3 + 1], positions[idx * 3 + 2]);
                                colors.push(color.r, color.g, color.b);
                            }
                        }

                        const newGeo = new THREE.BufferGeometry();
                        newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                        newGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        newGeo.computeVertexNormals();
                        geo = newGeo;
                    }

                    const mesh = new THREE.InstancedMesh(geo, material.clone(), instancesPerGeometry);
                    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                    const colors = new Float32Array(instancesPerGeometry * 3).fill(1.0);
                    mesh.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);
                    mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                    mesh.count = 0;
                    mesh.userData.geometryType = idx;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    tetraMeshes.push(mesh);
                    tetraScene.add(mesh);
                } catch (e) { }
            });
            if (tetraMeshes.length === 0) { console.error('CRITICAL: No instanced meshes could be created.'); return; }
            window.tetraMeshes = tetraMeshes;
            tetraMeshesReady = true;
        }

        function createFallbackTetraGeometry() {
            const h = Math.sqrt(2 / 3) * TETRA_LOCAL_SIZE, r = Math.sqrt(3) / 3 * TETRA_LOCAL_SIZE;
            const points = [
                new THREE.Vector3(0, h, 0),
                new THREE.Vector3(r, -h / 3, r * Math.sqrt(3) / 3),
                new THREE.Vector3(r, -h / 3, -r * Math.sqrt(3) / 3),
                new THREE.Vector3(-r, -h / 3, 0)
            ];
            const geo = new ConvexGeometry(points);

            // Convert to non-indexed geometry with vertex colors for per-face coloring
            const positions = geo.attributes.position.array;
            const indices = geo.index ? geo.index.array : null;

            if (indices) {
                // Duplicate vertices for per-face colors
                const newPositions = [];
                const colors = [];
                const faceColors = [
                    new THREE.Color(0xff0000), // red
                    new THREE.Color(0x00ff00), // green  
                    new THREE.Color(0x0000ff), // blue
                    new THREE.Color(0xffff00)  // yellow
                ];

                for (let i = 0; i < indices.length; i += 3) {
                    const faceIndex = Math.floor(i / 3);
                    const color = faceColors[faceIndex % faceColors.length];
                    for (let j = 0; j < 3; j++) {
                        const idx = indices[i + j];
                        newPositions.push(positions[idx * 3], positions[idx * 3 + 1], positions[idx * 3 + 2]);
                        colors.push(color.r, color.g, color.b);
                    }
                }

                const newGeo = new THREE.BufferGeometry();
                newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                newGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                newGeo.computeVertexNormals();
                return newGeo;
            }

            return geo;
        }
        let latticeGroup = null, latticePoints = [], BASE_TETRA_VERTS = null;
        function ensureBaseTetraVerts() {
            if (BASE_TETRA_VERTS) return BASE_TETRA_VERTS;
            return BASE_TETRA_VERTS = [
                new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, -1, -1)
            ].map(p => p.multiplyScalar(TETRA_LOCAL_SIZE));
        }
        async function ensureLatticeLoaded() {
            if (latticePoints.length) return latticePoints;
            try {
                const controller = new AbortController();
                const t = setTimeout(() => controller.abort(), 4500);
                const res = await fetch(`${API_BASE_URL}/api/blueprint`, { cache: 'no-store', signal: controller.signal });
                clearTimeout(t);
                if (!res.ok) throw new Error('blueprint fetch failed');
                const arr = await res.json();
                latticePoints = (arr || []).map(p => new THREE.Vector3(
                    Number(p.render_x ?? p.x ?? 0),
                    Number(p.render_y ?? p.y ?? 0),
                    Number(p.render_z ?? p.z ?? 0)
                ));
            } catch (e) { latticePoints = []; return latticePoints; }
            try {
                if (fluidVisualizer) {
                    fluidVisualizer.setBlueprintLattice(latticePoints);
                    return latticePoints;
                }
                if (!latticeGroup) {
                    latticeGroup = new THREE.Group();
                    latticeGroup.name = "E8_Lattice_3D_projection";
                    tetraScene.add(latticeGroup);
                } else {
                    while (latticeGroup.children.length) {
                        latticeGroup.remove(latticeGroup.children[0]);
                    }
                }

                // Render lattice points
                const pos = new Float32Array(latticePoints.length * 3);
                for (let i = 0; i < latticePoints.length; i++) {
                    latticePoints[i].toArray(pos, i * 3);
                }
                const pointsGeo = new THREE.BufferGeometry();
                pointsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const pointsMat = new THREE.PointsMaterial({
                    size: 0.02,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.6,
                    color: 0x7aa2ff
                });
                latticeGroup.add(new THREE.Points(pointsGeo, pointsMat));

                // ADD LATTICE EDGES - Connect nearby points
                const edges = [];
                const maxDistance = 2.0; // Adjust this to control connection density

                for (let i = 0; i < latticePoints.length; i++) {
                    for (let j = i + 1; j < latticePoints.length; j++) {
                        const dist = latticePoints[i].distanceTo(latticePoints[j]);
                        if (dist < maxDistance) {
                            edges.push(latticePoints[i], latticePoints[j]);
                        }
                    }
                }

                // Create edge geometry
                const edgeGeometry = new THREE.BufferGeometry();
                const edgePositions = new Float32Array(edges.length * 3);
                for (let i = 0; i < edges.length; i++) {
                    edges[i].toArray(edgePositions, i * 3);
                }
                edgeGeometry.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));

                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0x7aa2ff,
                    transparent: true,
                    opacity: 0.15,
                    linewidth: 1
                });

                const latticeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                latticeGroup.add(latticeLines);

            } catch (e) {
                console.warn("Lattice visualization error:", e);
            }
            return latticePoints;
        }
        function closestKPoints(targetVec3, k = 4) {
            if (!latticePoints.length) return [];
            const arr = latticePoints.map((p, i) => ({ i, d2: p.distanceToSquared(targetVec3) }));
            arr.sort((a, b) => a.d2 - b.d2);
            return arr.slice(0, k).map(o => latticePoints[o.i].clone());
        }
        function affineFromTetraMap(B, T) {
            const Bb = new THREE.Matrix3().set(
                B[1].x - B[0].x, B[2].x - B[0].x, B[3].x - B[0].x,
                B[1].y - B[0].y, B[2].y - B[0].y, B[3].y - B[0].y,
                B[1].z - B[0].z, B[2].z - B[0].z, B[3].z - B[0].z
            );
            if (Math.abs(Bb.determinant()) < 1e-8) return null;
            const Tb = new THREE.Matrix3().set(
                T[1].x - T[0].x, T[2].x - T[0].x, T[3].x - T[0].x,
                T[1].y - T[0].y, T[2].y - T[0].y, T[3].y - T[0].y,
                T[1].z - T[0].z, T[2].z - T[0].z, T[3].z - T[0].z
            );
            const L = new THREE.Matrix3().multiplyMatrices(Tb, Bb.invert());
            const L4 = new THREE.Matrix4().setFromMatrix3(L);
            const t = new THREE.Vector3().subVectors(T[0], B[0].clone().applyMatrix4(L4));
            const T4 = new THREE.Matrix4().makeTranslation(t.x, t.y, t.z);
            return new THREE.Matrix4().multiplyMatrices(T4, L4);
        }
        function chooseNearestLatticeTetra(centerVec3) {
            if (latticePoints.length < 4) return null;

            // Find 4 closest lattice points to form a tetrahedron
            const pts = closestKPoints(centerVec3, 8); // Get more candidates for better selection

            if (pts.length < 4) return null;

            // Try to find 4 points that form a well-shaped tetrahedron
            let bestTetra = null;
            let bestVolume = 0;

            // Try different combinations of 4 points from the 8 closest
            for (let i = 0; i < Math.min(pts.length - 3, 5); i++) {
                for (let j = i + 1; j < Math.min(pts.length - 2, 6); j++) {
                    for (let k = j + 1; k < Math.min(pts.length - 1, 7); k++) {
                        for (let l = k + 1; l < Math.min(pts.length, 8); l++) {
                            const tetra = [pts[i], pts[j], pts[k], pts[l]];
                            const volume = tetraVolume(tetra[0], tetra[1], tetra[2], tetra[3]);

                            // Prefer tetrahedra with reasonable volume (not too flat)
                            if (volume > bestVolume && volume > 0.1) {
                                bestVolume = volume;
                                bestTetra = tetra;
                            }
                        }
                    }
                }
            }

            // If no good tetrahedron found, just use the 4 closest points
            return bestTetra || pts.slice(0, 4);
        }
        function createTetraMaterial() {
            return new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.4,
                metalness: 0.0,
                transparent: true,
                opacity: 0.75,
                flatShading: false,
                side: THREE.DoubleSide,
                depthWrite: true,  // Enable depth writing for proper sorting
                blending: THREE.NormalBlending,
                alphaTest: 0.01  // Add alpha test for better transparency
            });
        }
        function animateOrganicCrystalGlow(material, time) {
            if (!material.userData) return;
            const { baseEmissive, glowPhase, glowSpeed } = material.userData;
            const pulse = Math.sin(time * glowSpeed + glowPhase) * 0.5 + 0.5;

            // Modulate glow intensity with mantle flux (0.5-2.0 range, default 1.0)
            const fluxModulation = state.mantle ? (state.mantle.flux || 1.0) : 1.0;
            const baseGlowIntensity = 0.1 + pulse * 0.3;
            const glowIntensity = baseGlowIntensity * (0.5 + fluxModulation * 0.5); // Scale flux to 0.5-1.5x intensity

            material.emissive.copy(baseEmissive).multiplyScalar(glowIntensity);
            material.opacity = 0.8 + Math.sin(time * glowSpeed * 0.6 + glowPhase) * 0.1;
        }
        function addOrganicCrystalFloating(instance, time) {
            if (!instance.userData) instance.userData = {};
            if (!instance.userData.organicMotion) {
                instance.userData.organicMotion = {
                    floatPhase: Math.random() * Math.PI * 2,
                    floatSpeed: 0.4 + Math.random() * 0.5,
                    floatAmplitude: 0.08 + Math.random() * 0.12,
                    rotPhase: Math.random() * Math.PI * 2,
                    rotSpeed: 0.2 + Math.random() * 0.3
                };
            }
            const { floatPhase, floatSpeed, floatAmplitude, rotPhase, rotSpeed } = instance.userData.organicMotion;
            instance.userData.organicOffset = {
                x: Math.cos(time * floatSpeed + floatPhase) * floatAmplitude * 0.7,
                y: Math.sin(time * floatSpeed + floatPhase) * floatAmplitude,
                z: Math.sin(time * floatSpeed * 0.8 + floatPhase + 1) * floatAmplitude * 0.5,
                rotationOffset: Math.sin(time * rotSpeed + rotPhase) * 0.1
            };
        }
        function addTetraInstance(id, matrix, color, omega, axis3, base) {
            if (!window.tetraMeshes || window.tetraMeshes.length === 0) return -1;
            const validMeshes = window.tetraMeshes.filter(m => m?.instanceMatrix && m.count < m.instanceMatrix.count);
            if (validMeshes.length === 0) return -1;
            let targetMesh = validMeshes[Math.abs(id) % validMeshes.length];
            if (!targetMesh || targetMesh.count >= targetMesh.instanceMatrix.count) targetMesh = validMeshes[0];
            if (!targetMesh) return -1;
            const perMeshIndex = targetMesh.count++;
            const globalIndex = tetraInstanceData.length;
            if (!color) color = new THREE.Color(0xffffff); // Default to white if no color provided
            console.log(`Setting instance color to:`, color.getHexString()); // Debug instance color
            try {
                targetMesh.setMatrixAt(perMeshIndex, matrix);
                if (targetMesh.instanceColor) targetMesh.setColorAt(perMeshIndex, color);
                targetMesh.instanceMatrix.needsUpdate = true;
                if (targetMesh.instanceColor) targetMesh.instanceColor.needsUpdate = true;
                const instanceRecord = { id, matrix, color, omega, axis3, base, index: perMeshIndex, mesh: targetMesh, fullData: null, globalIndex, rotAxis: null };
                tetraInstanceData.push(instanceRecord);
                tetraIndexById.set(id, globalIndex);
                return globalIndex;
            } catch (e) { targetMesh.count--; return -1; }
        }
        function updateTetraInstance(globalIndex, matrix, color) {
            if (typeof globalIndex !== 'number' || isNaN(globalIndex) || globalIndex < 0 || globalIndex >= tetraInstanceData.length) return;
            const instanceData = tetraInstanceData[globalIndex];
            if (!instanceData || !instanceData.mesh) return;
            const { mesh, index: perMeshIndex } = instanceData;
            if (typeof perMeshIndex !== 'number' || perMeshIndex < 0 || perMeshIndex >= mesh.count) return;
            try {
                mesh.setMatrixAt(perMeshIndex, matrix);
                if (color) { mesh.setColorAt(perMeshIndex, color); instanceData.color = color; }
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
            } catch (e) { }
        }
        function extractVec8D(o) {
            return o?.vec8D || o?.vec8d || o?.vec8 || o?.coords_8d || o?.e8_coords || (Array.isArray(o?.vec) && o.vec.length >= 8 ? o.vec.slice(0, 8) : null);
        }
        function seededScatter3(id) {
            let h = 2166136261 >>> 0; const s = String(id ?? '');
            for (let i = 0; i < s.length; i++) h = Math.imul(h ^ s.charCodeAt(i), 16777619);

            // Create more distributed positioning using spherical coordinates
            const h1 = h >>> 0;
            const h2 = (h >>> 8) >>> 0;
            const h3 = (h >>> 16) >>> 0;

            // Map to spherical coordinates for better distribution
            const radius = 5.0 + ((h1 % 1000) / 1000.0) * 10.0; // Radius 5-15
            const phi = ((h2 % 10007) / 10007.0) * Math.PI * 2; // Full rotation
            const theta = ((h3 % 10007) / 10007.0) * Math.PI; // Full hemisphere

            const x = radius * Math.sin(theta) * Math.cos(phi);
            const y = radius * Math.sin(theta) * Math.sin(phi);
            const z = radius * Math.cos(theta);

            return [x, y, z];
        }
        function safeCoords3D(d) {
            // First, try to get coordinates from the node position map if available
            if (nodePositionMap && nodePositionMap.has(d.node_id)) {
                const pos = nodePositionMap.get(d.node_id);
                return [pos.x, pos.y, pos.z];
            }

            // Try explicit 3D coordinates
            if (Array.isArray(d.final_coords_3d) && d.final_coords_3d.length >= 3) return d.final_coords_3d;
            if (Array.isArray(d.coords_3d) && d.coords_3d.length >= 3) return d.coords_3d;

            // Try to extract from 8D coordinates and project to 3D
            const v8 = extractVec8D(d);
            if (Array.isArray(v8) && v8.length >= 8) {
                // Project 8D to 3D using shell dimension for radial distance
                const shellDim = d.shell_dim || 8;
                const radius = (shellDim / 64) * 12.0; // Scale with shell dimension

                // Use first 3 components for direction, normalize and scale
                const dir = new THREE.Vector3(v8[0], v8[1], v8[2]).normalize();
                return [dir.x * radius, dir.y * radius, dir.z * radius];
            }

            // Only fall back to scattered position if no other data available
            return seededScatter3(d.node_id);
        }
        function baseCenter3(d) { const p = safeCoords3D(d); return [Number(p[0]) || 0, Number(p[1]) || 0, Number(p[2]) || 0]; }
        function extractLabel(d) { return d?.label || d?.id || d?.node_id || 'unknown'; }
        function ratingScale(d) { return MIN_SCALE + (MAX_SCALE - MIN_SCALE) * Math.max(0, Math.min(1, Number(d.rating) || 0.5)); }
        function seededAxisSpeed(id) {
            let h = 2166136261 >>> 0;
            const s = String(id);
            for (let i = 0; i < s.length; i++) h = Math.imul(h ^ s.charCodeAt(i), 16777619);
            const x = ((h) & 1023) / 512 - 1, y = ((h >> 10) & 1023) / 512 - 1, z = ((h >> 20) & 1023) / 512 - 1;
            return { axis: new THREE.Vector3(x, y, z).normalize(), speed: ((h >> 20) & 255) / 256 * 0.5 + 0.1 };
        }
        function axisAngleQuat(axis, angle) { return new THREE.Quaternion().setFromAxisAngle(axis, angle); }
        function createTetraInstanceFromE8Data(d) {
            const validMeshes = window.tetraMeshes?.filter(m => m?.instanceMatrix && typeof m.count === 'number') || [];
            if (validMeshes.length === 0) return;

            const base3 = baseCenter3(d);
            const color = pastelFromMetrics(d);
            console.log(`Creating tetra for ${extractLabel(d)} at position:`, base3, 'with color:', color.getHexString()); // Debug positioning

            const scale = ratingScale(d);
            const { axis, speed } = seededAxisSpeed(extractLabel(d));
            const initQ = axisAngleQuat(axis, speed * 30.0 * GLOBAL_ROTATION_SPEED_MULTIPLIER);

            let center = new THREE.Vector3(...base3);
            let baseAffine = null;

            ensureBaseTetraVerts();

            // If lattice points exist, find the best tetrahedron formed by lattice points
            if (latticePoints.length >= 4) {
                const chosen = chooseNearestLatticeTetra(center);
                if (chosen?.length === 4) {
                    const affine = affineFromTetraMap(BASE_TETRA_VERTS, chosen);
                    if (affine) {
                        // Use the centroid of the chosen lattice tetrahedron as the center
                        center = centroid(chosen);
                        baseAffine = affine;
                        console.log(`Tetra ${extractLabel(d)} mapped to lattice tetra at:`, center); // Debug lattice mapping
                    }
                }
            }

            // If no lattice mapping, create tetrahedron at the node's actual position
            if (!baseAffine) {
                const scl = new THREE.Vector3(scale, scale, scale);
                TMP_M.compose(center, initQ.clone(), scl);
                baseAffine = TMP_M.clone();
                console.log(`Tetra ${extractLabel(d)} positioned at node coords:`, center); // Debug direct positioning
            }

            d.__initQ = initQ.clone();
            d.__axis = axis.clone();
            d.__speed = speed;
            d.__scale = scale;
            d.__affine = baseAffine.clone();
            d.__centroid = center.clone();

            const globalIndex = addTetraInstance(d.node_id, baseAffine, color, 0, VEC_Z, center.clone());
            if (globalIndex >= 0) {
                const inst = tetraInstanceData[globalIndex];
                if (inst) {
                    inst.fullData = d;
                    inst.rotAxis = axis.clone();
                    inst.realPosition = center.clone(); // Store the real position for updates
                }
            }
        }
        function updateTetraInstanceFromE8Data(inst, d) {
            if (!inst) return;
            inst.omega = calculateRotorSpeed(d);
            inst.axis3 = new THREE.Vector3(...(d.rotor_axis || [0, 1, 0])).normalize();
            inst.fullData = d;

            // Update position based on current node mapping
            const base3 = baseCenter3(d);
            let center = new THREE.Vector3(...base3);
            let baseAffine = null;

            ensureBaseTetraVerts();

            // If lattice points exist and we have a good node position, update the tetrahedron
            if (latticePoints.length >= 4) {
                const chosen = chooseNearestLatticeTetra(center);
                if (chosen?.length === 4) {
                    const affine = affineFromTetraMap(BASE_TETRA_VERTS, chosen);
                    if (affine) {
                        center = centroid(chosen);
                        baseAffine = affine;
                        console.log(`Updated tetra ${d.node_id} lattice position:`, center); // Debug position updates
                    }
                }
            }

            // Update the instance matrix if position changed
            if (baseAffine && inst.realPosition && !inst.realPosition.equals(center)) {
                inst.realPosition = center.clone();
                inst.matrix.copy(baseAffine);

                // Mark for update
                const meshIndex = inst.meshIndex || 0;
                if (tetraMeshes[meshIndex] && tetraMeshes[meshIndex].instanceMatrix) {
                    tetraMeshes[meshIndex].instanceMatrix.needsUpdate = true;
                }
            }
        }

        // New function to refresh all tetrahedron positions after lattice/node updates
        function refreshAllTetrahedronPositions() {
            if (!tetraInstanceData || !nodePositionMap.size) return;

            console.log('Refreshing all tetrahedron positions...'); // Debug refresh

            for (let i = 0; i < tetraInstanceData.length; i++) {
                const inst = tetraInstanceData[i];
                if (inst && inst.fullData && inst.nodeId) {
                    // Force position recalculation
                    updateTetraInstanceFromE8Data(inst, inst.fullData);
                }
            }

            // Update all mesh instance matrices
            tetraMeshes.forEach(mesh => {
                if (mesh && mesh.instanceMatrix) {
                    mesh.instanceMatrix.needsUpdate = true;
                }
            });
        }
        function pastelFromMetrics(d) {
            const r = (typeof d.rating === 'number') ? Math.max(0, Math.min(1, d.rating)) : 0.5;
            const sdim = d.shell_dim || 8;
            const id = extractLabel(d);
            let idHashNum = 0;
            for (let i = 0; i < id.length; i++) idHashNum = ((idHashNum << 5) - idHashNum + id.charCodeAt(i)) & 0xffffffff;
            const idHash = Math.abs(idHashNum) / 0xffffffff;
            const hue = ((idHash * 360) + (sdim * 23) + (r * 60)) % 360;

            // Use mantle tension to modulate saturation and lightness for visual tension effects
            const tensionMod = state.mantle ? (state.mantle.tension || 0.7) : 0.7;
            const tensionFactor = Math.max(0.3, Math.min(1.7, tensionMod / 0.7)); // Normalize around 0.7 default

            const baseSat = 0.65 + (idHash * 0.3);
            const sat = Math.max(0.2, Math.min(0.95, baseSat * tensionFactor)); // Tension increases saturation

            const baseLig = 0.60 + (r * 0.15);
            const lig = Math.max(0.3, Math.min(0.9, baseLig / tensionFactor)); // Tension decreases lightness

            return new THREE.Color().setHSL(hue / 360, sat, lig);
        }
        function centroid(points) {
            const sum = new THREE.Vector3();
            points.forEach(p => sum.add(p));
            return sum.divideScalar(points.length);
        }
        function tetraVolume(a, b, c, d) {
            if (!a || !b || !c || !d) return 0;
            const ba = b.clone().sub(a), ca = c.clone().sub(a), da = d.clone().sub(a);
            return Math.abs(ba.dot(ca.clone().cross(da))) / 6;
        }
        function upsertInsightTetra(tetraData) {
            if (!tetraInitialized || !tetraMeshesReady || !window.tetraMeshes?.length) return;
            const validMeshes = window.tetraMeshes.filter(m => m?.instanceMatrix && typeof m.count === 'number');
            if (validMeshes.length === 0) return;
            const nodeId = tetraData.node_id;
            const globalIndex = tetraIndexById.get(nodeId);
            if (globalIndex !== undefined && tetraInstanceData[globalIndex]) {
                updateTetraInstanceFromE8Data(tetraInstanceData[globalIndex], tetraData);
                updateTetrahedronTargets();
            } else {
                createTetraInstanceFromE8Data(tetraData);
                setTimeout(() => updateTetrahedronTargets(), 100);
            }
        }
        function calculateRotorSpeed(d) {
            const r = d.rating || 0, sdim = d.shell_dim || 8, axis = d.rotor_axis || [0, 1, 0];
            let speed = Math.min(Math.max(r, 0), 1) * 0.3 + 0.1;
            speed *= (sdim / 8.0);
            speed *= Math.max(Math.sqrt(axis[0] ** 2 + axis[1] ** 2 + axis[2] ** 2), 0.5);
            return speed * GLOBAL_ROTATION_SPEED_MULTIPLIER;
        }

        // Function to update tetrahedron targets based on current rotor state
        function updateTetrahedronTargets() {
            // Update rotation state for all tetra instances based on current rotor state
            tetraInstanceData.forEach(inst => {
                if (inst.rotAxis) {
                    const currentQuat = tetraRotationState.current.get(inst.globalIndex) || new THREE.Quaternion();
                    tetraRotationState.current.set(inst.globalIndex, currentQuat);
                }
            });
        }
        async function fetchCognitiveState() {
            try {
                const res = await fetch(`${API_BASE_URL}/api/state`);
                if (!res.ok) return null;
                const state = await res.json();
                window.latestCognitiveState = state;
                if (state.telemetry?.shells) {
                    const shells = Object.values(state.telemetry.shells);
                    if (shells.length > 0) {
                        const ps = shells[0];
                        if (ps.orientation) {
                            const yaw = ps.orientation.yaw || 0, omega = ps.omega || 0.5;
                            const axis = new THREE.Vector3(Math.cos(yaw), Math.sin(yaw), 0.3 * Math.sin(window.__frameCounter * 0.01)).normalize();
                            const angle = omega * (window.__frameCounter || 0) * 0.05 * GLOBAL_ROTATION_SPEED_MULTIPLIER;
                            state.rotor = { axis: axis, angle, omega, shells_data: shells };
                        }
                    }
                }
                if (state.telemetry) {
                    const tel = state.telemetry;
                    if (!state.rotor) state.rotor = {};
                    state.rotor.learningMetrics = {
                        novelty: tel.novelty || 0,
                        compression: tel.compression || 0,
                        disagreement: tel.disagreement || 0,
                        timestamp: Date.now()
                    };
                }
                return state;
            } catch (e) { return null; }
        }
        // ===== ENHANCED TELEMETRY SYSTEM =====
        let telemetryConnection = null;
        let graphData = null;
        let lastGraphUpdateTime = 0;
        let nodePositionMap = new Map(); // Maps node IDs to 3D positions
        let isRealTimeConnected = false;

        // WebSocket connection for real-time telemetry
        function connectTelemetryWebSocket() {
            try {
                if (telemetryConnection && telemetryConnection.readyState === WebSocket.OPEN) {
                    return;
                }

                telemetryConnection = new WebSocket(`ws://${window.location.host}/ws/telemetry`);

                telemetryConnection.onopen = () => {
                    console.log('WebSocket telemetry connected');
                    isRealTimeConnected = true;
                    updateConnectionStatus(true);
                };

                telemetryConnection.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        processFullTelemetryUpdate(data);
                    } catch (e) {
                        console.warn('Failed to parse telemetry data:', e);
                    }
                };

                telemetryConnection.onclose = () => {
                    console.log('WebSocket telemetry disconnected');
                    isRealTimeConnected = false;
                    updateConnectionStatus(false);
                    // Reconnect after delay
                    setTimeout(connectTelemetryWebSocket, 2000);
                };

                telemetryConnection.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    isRealTimeConnected = false;
                    updateConnectionStatus(false);
                };
            } catch (e) {
                console.error('Failed to connect WebSocket:', e);
                // Fallback to polling
                setTimeout(startPollingFallback, 1000);
            }
        }

        // Fallback polling system
        let pollingInterval = null;
        function startPollingFallback() {
            if (isRealTimeConnected) return;

            pollingInterval = setInterval(async () => {
                try {
                    const [telemetryRes, graphRes] = await Promise.all([
                        fetch(`${API_BASE_URL}/api/telemetry`),
                        fetch(`${API_BASE_URL}/api/graph`)
                    ]);

                    if (telemetryRes.ok && graphRes.ok) {
                        const telemetry = await telemetryRes.json();
                        const graph = await graphRes.json();

                        processFullTelemetryUpdate({
                            ...telemetry,
                            graph_data: graph
                        });
                    }
                } catch (e) {
                    console.warn('Polling failed:', e);
                }
            }, 1000);
        }

        function updateConnectionStatus(connected) {
            const statusEl = document.querySelector('.status-tag');
            if (statusEl) {
                statusEl.textContent = connected ? 'Live Stream Connected' : 'Reconnecting...';
                statusEl.style.background = connected ? 'rgba(110, 231, 183, 0.15)' : 'rgba(251, 113, 133, 0.15)';
                statusEl.style.color = connected ? '#6ee7b7' : '#fb7185';
                statusEl.style.borderColor = connected ? 'rgba(110, 231, 183, 0.25)' : 'rgba(251, 113, 133, 0.25)';
            }
        }

        // Comprehensive telemetry processor
        function processFullTelemetryUpdate(data) {
            // Update state with new data
            window.latestCognitiveState = data;

            // Process rotor/shell updates
            if (data.shells) {
                updateRotorState(Object.values(data.shells));
            }

            // Process new memory nodes
            if (data.new_memory_nodes && Array.isArray(data.new_memory_nodes)) {
                data.new_memory_nodes.forEach(nodeData => {
                    if (nodeData.blueprint_location_id !== null) {
                        upsertInsightTetra(nodeData);
                    }
                });
            }

            // Process graph updates
            if (data.graph_data) {
                updateMemoryGraph(data.graph_data);
                // Update node position mapping when graph changes
                updateNodePositionMapping();
                // Refresh tetrahedron positions to match new node positions
                refreshAllTetrahedronPositions();
            }

            // Update lattice morphing based on graph topology
            if (graphData && latticePoints.length > 0) {
                morphLatticeToGraphTopology();
            }

            // Update node visualization
            if (nodeGroup) {
                updateNodeVisualization();
            }

            // Update all UI panels
            updateTelemetryPanels(data);
        }

        // New function to update memory graph visualization
        function updateMemoryGraph(newGraphData) {
            if (!newGraphData) return;

            const currentTime = Date.now();
            graphData = newGraphData;
            lastGraphUpdateTime = currentTime;

            // Update node position mapping for lattice morphing
            updateNodePositionMapping();

            // Update graph cache for existing tetra system
            window.graphCache = graphData;

            console.log(`Graph updated: ${graphData.nodes?.length || 0} nodes, ${graphData.links?.length || 0} links`);
        }

        // Map memory nodes to 3D space for lattice morphing
        function updateNodePositionMapping() {
            if (!graphData || !graphData.nodes) return;

            nodePositionMap.clear();

            graphData.nodes.forEach((node, index) => {
                // Use shell dimension to determine radial distance
                const shellDim = node.shell_dim || 8;
                const radius = Math.max(2.0, (shellDim / 64) * 15.0); // Better radius scaling

                // Use node properties for more natural positioning
                const idHash = hashString(node.id || String(index));
                const ratingHash = hashString(String(node.rating || 0.5));

                // Combine multiple hash sources for better distribution
                const phi = ((idHash % 10007) / 10007.0) * Math.PI * 2;
                const theta = ((ratingHash % 10007) / 10007.0) * Math.PI;

                // Add some variation based on node content
                const contentHash = hashString(node.content || node.label || '');
                const radiusVar = 1.0 + ((contentHash % 1000) / 1000.0 - 0.5) * 0.3; // ±15% radius variation

                const x = radius * radiusVar * Math.sin(theta) * Math.cos(phi);
                const y = radius * radiusVar * Math.sin(theta) * Math.sin(phi);
                const z = radius * radiusVar * Math.cos(theta);

                const position = new THREE.Vector3(x, y, z);
                nodePositionMap.set(node.id, position);

                console.log(`Mapped node ${node.id} (shell: ${shellDim}) to position:`, position); // Debug node mapping
            });

            console.log(`Mapped ${nodePositionMap.size} nodes to 3D positions`); // Debug total mapping
        }

        // Hash function for consistent node positioning
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }

        // Morph lattice points to reflect memory graph topology
        function morphLatticeToGraphTopology() {
            if (!latticePoints.length || !graphData || !nodePositionMap.size) return;

            // Create new morphed positions
            const morphedPositions = [];
            const maxNodes = Math.min(latticePoints.length, nodePositionMap.size);

            // Update existing lattice points to node positions
            let nodeIndex = 0;
            for (const [nodeId, position] of nodePositionMap.entries()) {
                if (nodeIndex >= latticePoints.length) break;

                // Smoothly interpolate lattice points toward node positions
                const target = position.clone();
                const current = latticePoints[nodeIndex];
                const morphed = current.clone().lerp(target, 0.1); // Smooth interpolation

                morphedPositions.push(morphed);
                nodeIndex++;
            }

            // Fill remaining lattice points with variations
            while (morphedPositions.length < latticePoints.length) {
                const baseIndex = morphedPositions.length % Math.max(1, nodePositionMap.size);
                const base = morphedPositions[baseIndex] || latticePoints[morphedPositions.length];
                const variation = base.clone().add(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    )
                );
                morphedPositions.push(variation);
            }

            // Update lattice visualization
            updateLatticeVisualization(morphedPositions);
        }

        // Update the actual lattice visualization
        function updateLatticeVisualization(newPositions) {
            if (!latticeGroup || !newPositions.length) return;

            // Update lattice points
            latticePoints = newPositions;

            // Clear and rebuild lattice group
            while (latticeGroup.children.length) {
                latticeGroup.remove(latticeGroup.children[0]);
            }

            // Render updated lattice points
            const pos = new Float32Array(latticePoints.length * 3);
            for (let i = 0; i < latticePoints.length; i++) {
                latticePoints[i].toArray(pos, i * 3);
            }

            const pointsGeo = new THREE.BufferGeometry();
            pointsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            // Dynamic point material based on graph activity
            const activity = graphData ? Math.min(graphData.nodes.length / 100, 1.0) : 0.5;
            const pointsMat = new THREE.PointsMaterial({
                size: 0.02 + activity * 0.01,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.6 + activity * 0.2,
                color: new THREE.Color().setHSL(0.6 + activity * 0.2, 0.8, 0.6)
            });

            latticeGroup.add(new THREE.Points(pointsGeo, pointsMat));

            // Add dynamic edges based on graph connections
            if (graphData && graphData.links) {
                addGraphBasedEdges();
            }
        }

        // Add dynamic edges based on memory graph connections
        function addGraphBasedEdges() {
            if (!graphData.links || !nodePositionMap.size) return;

            const edgeGeometry = new THREE.BufferGeometry();
            const positions = [];

            graphData.links.forEach(link => {
                const sourcePos = nodePositionMap.get(link.source);
                const targetPos = nodePositionMap.get(link.target);

                if (sourcePos && targetPos) {
                    positions.push(sourcePos.x, sourcePos.y, sourcePos.z);
                    positions.push(targetPos.x, targetPos.y, targetPos.z);
                }
            });

            if (positions.length > 0) {
                edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0x7aa2ff,
                    transparent: true,
                    opacity: 0.3
                });

                const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                latticeGroup.add(edges);
            }
        }

        // ===== REAL-TIME NODE VISUALIZATION SYSTEM =====
        let nodeGroup = null;
        let nodeInstances = new Map(); // Maps node IDs to THREE.js objects
        let nodeMaterial = null;

        function initializeNodeVisualization() {
            if (!tetraScene) return;

            // Create node group
            nodeGroup = new THREE.Group();
            nodeGroup.name = "MemoryNodes";
            tetraScene.add(nodeGroup);

            // Create shared node material
            nodeMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0.8
            });
        }

        function updateNodeVisualization() {
            if (!graphData || !nodeGroup) return;

            const currentNodes = new Set(graphData.nodes.map(n => n.id));

            // Remove nodes that no longer exist
            for (const [nodeId, nodeObj] of nodeInstances.entries()) {
                if (!currentNodes.has(nodeId)) {
                    nodeGroup.remove(nodeObj);
                    nodeInstances.delete(nodeId);
                }
            }

            // Add or update existing nodes
            graphData.nodes.forEach(node => {
                const nodeId = node.id;
                const position = nodePositionMap.get(nodeId);

                if (!position) return;

                let nodeObj = nodeInstances.get(nodeId);

                if (!nodeObj) {
                    // Create new node
                    const geometry = new THREE.SphereGeometry(0.05, 8, 6);
                    const material = nodeMaterial.clone();

                    // Color based on node type and shell
                    const color = getNodeColor(node);
                    material.color = color;

                    nodeObj = new THREE.Mesh(geometry, material);
                    nodeObj.userData = { nodeId, nodeData: node };

                    nodeGroup.add(nodeObj);
                    nodeInstances.set(nodeId, nodeObj);
                }

                // Update position and properties
                nodeObj.position.copy(position);

                // Animate based on node activity
                const time = performance.now() * 0.001;
                const rating = node.rating || 0.5;
                const scale = 1.0 + Math.sin(time * rating * 2.0) * 0.2;
                nodeObj.scale.setScalar(scale);

                // Update color based on current state
                const newColor = getNodeColor(node);
                nodeObj.material.color = newColor;
            });
        }

        function getNodeColor(node) {
            const type = node.type || 'concept';
            const rating = node.rating || 0.5; // General importance/relevance
            const shellDim = node.shell_dim || 8; // Dimensionality of the shell
            const novelty = node.novelty || 0; // How novel the memory is (0-1)
            const synthesis = node.synthesis || 0; // How much it contributes to synthesis (0-1)
            const creationTime = node.creation_time ? new Date(node.creation_time).getTime() : Date.now(); // Timestamp of creation

            // Base hue for different types
            let baseHue;
            switch (type) {
                case 'insight_synthesis':
                    baseHue = 0.3; // Green for synthesis
                    break;
                case 'explorer_insight':
                    baseHue = 0.8; // Purple for novelty/exploration
                    break;
                case 'external_concept':
                    baseHue = 0.1; // Orange for external data
                    break;
                case 'meta_reflection':
                    baseHue = 0.9; // Pink for self-reflection
                case 'memory_creation':
                    baseHue = 0.6; // Blue for general memory creation
                    break;
                default:
                    baseHue = 0.6; // Default blue for 'concept' or unknown
                    break;
            }

            // Adjust hue based on creation time (newer memories are slightly different hue)
            const ageFactor = Math.min(1, (Date.now() - creationTime) / (1000 * 60 * 60 * 24 * 7)); // Max 1 week old
            baseHue = (baseHue + ageFactor * 0.1) % 1; // Shift hue slightly for newer nodes

            // Saturation based on rating and synthesis
            const saturation = Math.min(1, 0.5 + rating * 0.3 + synthesis * 0.2);

            // Lightness based on novelty and shell dimension
            const lightness = Math.min(1, 0.4 + novelty * 0.2 + (shellDim / 16) * 0.1);

            return new THREE.Color().setHSL(baseHue, saturation, lightness);
        }

        // Enhanced telemetry panel updates
        function updateTelemetryPanels(data) {
            // Update shell population displays
            if (data.shell_population) {
                updateShellPopulationDisplays(data.shell_population);
            }

            // Update quantum telemetry
            if (data.quantum_telemetry) {
                updateQuantumTelemetryDisplays(data.quantum_telemetry);
            }

            // Update mood and environmental data
            if (data.mood) {
                updateMoodDisplays(data.mood);
            }

            // Update memory count
            if (typeof data.memory_count === 'number') {
                updateMemoryCountDisplay(data.memory_count);
            }

            // Update enhanced displays
            if (data.symbolic_weather) {
                const weatherEl = document.getElementById('symbolic-weather');
                if (weatherEl) weatherEl.textContent = data.symbolic_weather;
            }

            if (data.environment_theme) {
                const themeEl = document.getElementById('environment-theme');
                if (themeEl) themeEl.textContent = data.environment_theme;
            }

            // Update graph link count
            if (graphData && graphData.links) {
                const linksEl = document.querySelector('.graph-links-count');
                if (linksEl) linksEl.textContent = graphData.links.length.toLocaleString();
            }
        }

        function updateShellPopulationDisplays(shellPop) {
            Object.entries(shellPop).forEach(([dim, count]) => {
                const shellCard = document.querySelector(`[data-shell="${dim}"]`);
                if (shellCard) {
                    const countEl = shellCard.querySelector('.population-count');
                    if (countEl) countEl.textContent = count;
                }
            });
        }

        function updateQuantumTelemetryDisplays(qdata) {
            const psiBadge = document.querySelector('.psi-entropy-badge');
            if (psiBadge && typeof qdata.psi_entropy === 'number') {
                psiBadge.textContent = qdata.psi_entropy.toFixed(3);
            }
        }

        function updateMoodDisplays(mood) {
            if (Array.isArray(mood) && mood.length >= 3) {
                const moodEl = document.querySelector('.mood-vector');
                if (moodEl) {
                    moodEl.textContent = `[${mood.map(x => x.toFixed(2)).join(', ')}]`;
                }
            }
        }

        function updateMemoryCountDisplay(count) {
            const memCountEl = document.querySelector('.memory-count');
            if (memCountEl) {
                memCountEl.textContent = count.toLocaleString();
            }
        }

        // Initialize enhanced telemetry system
        function initializeEnhancedTelemetry() {
            // Initialize node visualization
            initializeNodeVisualization();

            // Try WebSocket first, fallback to polling
            connectTelemetryWebSocket();

            // Initialize graph data
            loadGraph().then(graph => {
                if (graph) {
                    updateMemoryGraph(graph);
                    // Initialize node position mapping and refresh tetrahedron positions
                    updateNodePositionMapping();
                    setTimeout(() => {
                        refreshAllTetrahedronPositions();
                    }, 500); // Small delay to ensure everything is loaded
                }
            });

            console.log('Enhanced telemetry system initialized');
        }

        // Start the enhanced system
        window.addEventListener('load', () => {
            setTimeout(initializeEnhancedTelemetry, 1000);
        });
        function animateTetras(now) {
            if (!tetraInitialized || !tetraScene || !tetraRenderer || !tetraCamera) return;
            animateOrganicCrystalEffects(now * 0.001);
            animateTetrahedronRotations();
            if (window.__tetraControls) window.__tetraControls.update();
            throttledTweenUpdate(now);
            if (composer?.render) try { composer.render(); } catch (e) { }
        }
        function animateOrganicCrystalEffects(time) { }
        function createGearRotationProfile(index) {
            const types = ['clockwork', 'industrial', 'precision', 'chaotic', 'synchronized'];
            const type = types[index % types.length];
            switch (type) {
                case 'clockwork': return { speedPattern: 'steady', directionChanges: 'periodic', acceleration: 'smooth', stepSize: 0.05, baseSpeed: 0.6, speedVariation: 0.3 };
                case 'industrial': return { speedPattern: 'heavy', directionChanges: 'abrupt', acceleration: 'jerky', stepSize: 0.15, baseSpeed: 0.4, speedVariation: 0.8 };
                case 'precision': return { speedPattern: 'precise', directionChanges: 'calculated', acceleration: 'linear', stepSize: 0.02, baseSpeed: 0.8, speedVariation: 0.2 };
                case 'chaotic': return { speedPattern: 'erratic', directionChanges: 'random', acceleration: 'explosive', stepSize: 0.25, baseSpeed: 0.3, speedVariation: 1.2 };
                case 'synchronized': return { speedPattern: 'harmonic', directionChanges: 'synchronized', acceleration: 'wave', stepSize: 0.08, baseSpeed: 0.7, speedVariation: 0.5 };
            }
        }
        // Simplified tetrahedron rotation - replaced complex gear system
        function animateTetrahedronRotations() {
            if (!tetraInitialized || !window.tetraMeshes) return;

            const deltaTime = clock.getDelta();
            const time = performance.now() * 0.001;

            for (let i = 0; i < tetraInstanceData.length; i++) {
                const inst = tetraInstanceData[i];
                if (!inst || !inst.fullData || !inst.mesh) continue;

                // Simple, reliable rotation based on rating and time, modulated by mantle curvature
                const rating = inst.fullData.rating || 0.5;
                const baseRotSpeed = (rating * 2.0 + 0.5) * GLOBAL_ROTATION_SPEED_MULTIPLIER;

                // Use mantle curvature to modulate rotation complexity (curvature affects how "twisted" the rotation is)
                const curvatureMod = state.mantle ? (state.mantle.curvature || 6.0) : 6.0;
                const curvatureFactor = Math.max(0.3, Math.min(3.0, curvatureMod / 6.0)); // Normalize around 6.0 default
                const rotSpeed = baseRotSpeed * curvatureFactor;

                // Create rotation quaternion with curvature-influenced complexity
                const rotX = Math.sin(time * rotSpeed * 0.7) * 0.5 * curvatureFactor;
                const rotY = time * rotSpeed;
                const rotZ = Math.cos(time * rotSpeed * 0.3) * 0.3 * curvatureFactor;

                const quat = new THREE.Quaternion();
                quat.setFromEuler(new THREE.Euler(rotX, rotY, rotZ));

                // Apply rotation relative to stored base affine and centroid
                const fd = inst.fullData;
                if (fd && fd.__centroid && fd.__affine) {
                    const c = fd.__centroid;
                    const Tto = new THREE.Matrix4().makeTranslation(c.x, c.y, c.z);
                    const Tfrom = new THREE.Matrix4().makeTranslation(-c.x, -c.y, -c.z);
                    const R = new THREE.Matrix4().makeRotationFromQuaternion(quat);
                    TMP_M.identity().multiply(Tto).multiply(R).multiply(Tfrom).multiply(fd.__affine);
                    inst.mesh.setMatrixAt(inst.index, TMP_M);
                }
            }

            // Update all meshes
            window.tetraMeshes.forEach(mesh => {
                if (mesh.instanceMatrix) {
                    mesh.instanceMatrix.needsUpdate = true;
                }
            });
        }
        let hoveredInstance = null, selectedInstance = null, graphCache = null;
        {
            const st = document.createElement('style');
            st.textContent = `
        #insightPopup { position: fixed; z-index: 1000; display: none; min-width: 260px; max-width: 360px; padding: 12px 14px; border-radius: 14px; border: 1px solid var(--border-color); background: var(--glass); backdrop-filter: blur(8px); box-shadow: 0 12px 40px rgba(0,0,0,0.35); color: var(--fg); font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        #insightPopup .title { font-weight: 600; margin-bottom: 6px; }
        #insightPopup .row { display:flex; justify-content:space-between; gap:8px; margin:2px 0; }
            #insightPopup .row .k { opacity: .7 }
            #insightPopup .chips { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px }
            #insightPopup .chip { padding:4px 8px; border-radius:999px; border:1px solid var(--border-color); opacity:.9; background: var(--glass-2); }
          `;
            document.head.appendChild(st);
        }
        const popup = document.createElement('div');
        popup.id = 'insightPopup';
        document.body.appendChild(popup);
        function setInstanceScale(inst, s) {
            if (!inst || !inst.fullData?.__affine || !inst.fullData?.__centroid) return;
            const { __affine: baseAffine, __centroid: c } = inst.fullData;
            const { mesh, index } = inst;
            const currentQuat = tetraRotationState.current.get(inst.globalIndex) || new THREE.Quaternion();
            const Tto = new THREE.Matrix4().makeTranslation(c.x, c.y, c.z);
            const Tfrom = new THREE.Matrix4().makeTranslation(-c.x, -c.y, -c.z);
            const R = new THREE.Matrix4().makeRotationFromQuaternion(currentQuat);
            const S = new THREE.Matrix4().makeScale(s, s, s);
            TMP_M.identity().multiply(Tto).multiply(R).multiply(S).multiply(Tfrom).multiply(baseAffine);
            mesh.setMatrixAt(index, TMP_M);
            mesh.instanceMatrix.needsUpdate = true;
        }
        function setInstanceColor(inst, hex) {
            if (!inst) return;
            inst.mesh.setColorAt(inst.index, new THREE.Color(hex));
            if (inst.mesh.instanceColor) inst.mesh.instanceColor.needsUpdate = true;
        }
        function restoreInstanceColor(inst) {
            if (!inst) return;
            inst.mesh.setColorAt(inst.index, inst.color);
            if (inst.mesh.instanceColor) inst.mesh.instanceColor.needsUpdate = true;
        }
        async function loadGraph() {
            if (graphCache) return graphCache;
            try {
                const res = await fetch(`${API_BASE_URL}/api/graph`, { cache: 'no-store' });
                if (!res.ok) throw new Error(String(res.status));
                graphCache = await res.json();
            } catch (e) { graphCache = { nodes: [], links: [] }; }
            return graphCache;
        }
        async function nodeDetails(nodeId) {
            const g = await loadGraph();
            const node = (g.nodes || []).find(n => n.id === nodeId) || {};
            const links = (g.links || []).filter(l => (l.source === nodeId || l.target === nodeId));
            const neighborIds = links.map(l => l.source === nodeId ? l.target : l.source);
            const neighbors = neighborIds.map(id => (g.nodes || []).find(n => n.id === id)).filter(Boolean).slice(0, 8);
            return { node, links, neighbors };
        }
        function showPopupAt(x, y, html) {
            popup.innerHTML = html;
            popup.style.left = `${x + 12}px`;
            popup.style.top = `${y + 12}px`;
            popup.style.display = 'block';
        }
        function hidePopup() { popup.style.display = 'none'; }
        function getHoveredInstance() {
            if (!window.tetraMeshes) return null;
            raycaster.setFromCamera(mouse, tetraCamera);
            const hits = raycaster.intersectObjects(window.tetraMeshes, false);
            if (hits.length > 0 && hits[0].instanceId !== undefined) {
                const hit = hits[0];
                return tetraInstanceData.find(d => d.mesh === hit.object && d.index === hit.instanceId);
            }
            return null;
        }
        function onPointerMove(ev) {
            const rect = DOM.tetraCanvas.getBoundingClientRect();
            mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            const inst = getHoveredInstance();
            if (inst !== hoveredInstance) {
                if (hoveredInstance && hoveredInstance !== selectedInstance) { setInstanceScale(hoveredInstance, 1.0); restoreInstanceColor(hoveredInstance); }
                hoveredInstance = inst;
                if (hoveredInstance && hoveredInstance !== selectedInstance) { setInstanceScale(hoveredInstance, 1.10); setInstanceColor(hoveredInstance, 0xffffff); }
            }
        }
        async function onClick(ev) {
            const rect = DOM.tetraCanvas.getBoundingClientRect();
            mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            const inst = getHoveredInstance();
            if (!inst) { hidePopup(); return; }
            if (selectedInstance) { setInstanceScale(selectedInstance, 1.0); restoreInstanceColor(selectedInstance); }
            selectedInstance = inst;
            setInstanceScale(selectedInstance, 1.20);
            setInstanceColor(selectedInstance, 0x9ad5ff);
            const { node, neighbors } = await nodeDetails(inst?.id);
            const title = node?.label || '(unnamed concept)';
            const typ = node?.type || 'concept';
            const rating = (node?.rating != null) ? Number(node.rating).toFixed(2) : '-';
            const chips = neighbors.map(n => `<span class="chip">${(n.label || n.id || '...')}</span>`).join('');
            showPopupAt(ev.clientX, ev.clientY, `
                <div class="title">${title}</div>
                <div class="row"><span class="k">Type</span><span>${typ}</span></div>
                <div class="row"><span class="k">Rating</span><span>${rating}</span></div>
                <div class="row"><span class="k">Node</span><span>${inst?.id || '-'}</span></div>
                <div class="row"><span class="k">Connections</span><span>${neighbors.length}</span></div>
                ${chips ? `<div class="chips">${chips}</div>` : ''}
            `);
            if (inst.fullData?.__centroid && window.__tetraControls) {
                const target = inst.fullData.__centroid.clone();
                const cam = tetraCamera, ctrl = window.__tetraControls;
                const startPos = cam.position.clone();
                const endPos = target.clone().add(new THREE.Vector3(0, 0, 9));
                createTween({ t: 0 }).to({ t: 1 }, 650).easing(typeof TWEEN !== 'undefined' && TWEEN.Easing ? TWEEN.Easing.Cubic.InOut : t => t).onUpdate(o => {
                    cam.position.lerpVectors(startPos, endPos, o.t);
                    ctrl.target.lerpVectors(ctrl.target, target, o.t);
                    ctrl.update();
                }).start();
            }
        }
        DOM.tetraCanvas.addEventListener('pointermove', onPointerMove);
        DOM.tetraCanvas.addEventListener('click', onClick);
        window.addEventListener('scroll', hidePopup, { passive: true });
        window.addEventListener('resize', hidePopup, { passive: true });

        function escapeHTML(str) { return String(str ?? '').replace(/[&<>"']/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[s]); }
        function num(v, fallback = 0) { const n = Number(v); return Number.isFinite(n) ? n : fallback; }
        function clamp01(v) { return Math.max(0, Math.min(1, num(v, 0))); }
        function asArray(x) {
            // PATCH: Handle null or undefined gracefully
            if (x == null) return [];
            if (Array.isArray(x)) return x;
            if (typeof x === 'string') return x.trim() ? [x] : [];
            if (typeof x === 'object') return Object.entries(x).map(([k, v]) => `${k}: ${typeof v === 'object' ? JSON.stringify(v) : v}`);
            return [String(x)];
        }
        function renderList(elem, data, { boxed = true } = {}) {
            if (!elem) return;
            const rows = asArray(data).slice(-200);
            if (!rows.length) { elem.innerHTML = '<div class="weather-box" style="opacity: 0.5;"><div class="row"><span class="value">Awaiting data...</span></div></div>'; return; }
            elem.innerHTML = rows.map(line => boxed ? `<div class="weather-box" style="margin-bottom:6px;"><div class="row" style="align-items:flex-start;"><span class="label" style="opacity:0.6;">*</span><span class="value" style="white-space:pre-wrap;text-align:left">${escapeHTML(line)}</span></div></div>` : `<div style="white-space:pre-wrap">${escapeHTML(line)}</div>`).join('');
        }
        function lerp(a, b, t) { return a + (b - a) * t; }
        function drawRing(canvas, val, colorVar = '--accent') {
            const ctx = canvas.getContext('2d'), w = canvas.width, h = canvas.height, v = clamp01(val);
            const color = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
            ctx.clearRect(0, 0, w, h);
            ctx.lineWidth = 6;
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.beginPath(); ctx.arc(w / 2, h / 2, w / 2 - 4, 0, 2 * Math.PI); ctx.stroke();
            if (v > 0) {
                ctx.strokeStyle = color;
                ctx.beginPath(); ctx.arc(w / 2, h / 2, w / 2 - 4, -0.5 * Math.PI, -0.5 * Math.PI + v * 2 * Math.PI); ctx.stroke();
            }
        }
        function sparkline(elem, values, maxPoints = 64) {
            const canvas = elem.querySelector('canvas') || (() => { const c = document.createElement('canvas'); c.width = 140; c.height = 40; elem.innerHTML = ''; elem.appendChild(c); return c; })();
            const ctx = canvas.getContext('2d'), w = canvas.width, h = canvas.height;
            if (values.length > maxPoints) values.splice(0, values.length - maxPoints);
            ctx.clearRect(0, 0, w, h);
            if (!Array.isArray(values) || values.length < 2) return;
            const safeVals = values.map(v => num(v, 0));
            const minVal = Math.min(...safeVals), maxVal = Math.max(...safeVals), range = (maxVal - minVal) || 1;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            ctx.lineWidth = 1.5; ctx.beginPath();
            for (let i = 0; i < safeVals.length; i++) {
                const x = (i / (safeVals.length - 1)) * w;
                const y = h - ((safeVals[i] - minVal) / range) * (h - 6) - 3;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        function __clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function unwrapAngle(curr, prev) {
            if (prev == null) return curr;
            let a = curr;
            while (a - prev > Math.PI) a -= Math.PI * 2;
            while (a - prev < -Math.PI) a += Math.PI * 2;
            return a;
        }
        function parseOrientationToYaw(o) {
            if (!o) return null; if (typeof o === 'number') return o; if (typeof o.yaw === 'number') return o.yaw;
            if (typeof o.x === 'number') { const { x, y, z, w } = o; return Math.atan2(2 * (w * y + z * x), 1 - 2 * (y * y + x * x)); }
            return null;
        }
        function updateRotorState(shellsData) {
            if (!shellsData) { Object.values(state.rotors).forEach(r => { if (!r.baseSpin) r.baseSpin = 0.005; }); return; }
            const tensions = (state.currentTelemetry || {}).shell_tensions || {};
            const now = performance.now() * 0.001;
            for (const dim in shellsData) {
                const sd = shellsData[dim];
                const rotor = state.rotors[dim] || (state.rotors[dim] = { angle: Math.random() * Math.PI * 2, angleTarget: null, angleVelocity: 0, speed: 0, speedTarget: 0, speedVelocity: 0, lastAngleFromOri: null, lastUpdate: null, interpolationStart: null, interpolationDuration: 0.55 });
                const yaw = parseOrientationToYaw(sd.orientation), omega = sd.omega;
                if (yaw != null) {
                    if (rotor.lastAngleFromOri == null) {
                        rotor.lastAngleFromOri = yaw; rotor.lastUpdate = now; rotor.angle = rotor.angleTarget = yaw; rotor.interpolationStart = now;
                    } else {
                        const dtObs = Math.max(1e-3, now - rotor.lastUpdate);
                        const unwrapped = unwrapAngle(yaw, rotor.lastAngleFromOri);
                        const observedOmega = (unwrapped - rotor.lastAngleFromOri) / dtObs;
                        rotor.lastAngleFromOri = unwrapped; rotor.lastUpdate = now;
                        const rawOmega = (omega != null) ? 0.6 * observedOmega + 0.4 * __clamp(omega, -8, 8) : observedOmega;
                        const tensionGain = 1.0 + __clamp(Number(tensions[dim] ?? 0), 0, 10) * 0.05;
                        rotor.speedTarget = __clamp(rawOmega * tensionGain, -6, 6);
                        if (rotor.angleTarget == null || Math.abs(unwrapAngle(unwrapped, rotor.angleTarget)) > 0.12) {
                            rotor.angleTarget = unwrapAngle(unwrapped, rotor.angleTarget);
                            rotor.interpolationStart = now;
                        }
                    }
                } else if (omega != null) {
                    const tensionGain = 1.0 + __clamp(Number(tensions[dim] ?? 0), 0, 10) * 0.05;
                    rotor.speedTarget = __clamp(omega * tensionGain, -6, 6);
                    if (rotor.angleTarget == null) { rotor.angleTarget = rotor.angle; rotor.interpolationStart = now; }
                }
            }
        }
        function drawRotors(dt) { /* Stub - visualization removed */ }

        document.querySelectorAll('.tab-btn').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(`tab-${tabName}`).classList.add('active');
            });
        });
        function updateUI(telemetry) {
            if (!telemetry) return;
            DOM.wxMood.textContent = telemetry.symbolic_weather || '-';
            DOM.wxRegion.textContent = telemetry.environment_theme || '-';
            state.targets.wxPressure = num(telemetry.black_hole_pressure, 0);
            const m = telemetry.mood || {};
            state.targets.moodIntensity = clamp01(m.intensity);
            state.targets.moodEntropy = clamp01(m.entropy);
            state.targets.moodCoherence = clamp01(m.coherence);
            state.targets.moodPositivity = clamp01(m.positivity);
            state.targets.moodFluidity = clamp01(m.fluidity);
            state.targets.moodIntelligibility = clamp01(m.intelligibility);
            state.targets.pressure = clamp01(telemetry.black_hole_pressure);
            state.targets.teacher = 1 - clamp01(num(telemetry.teacher_in, 0) / TEACHER_CYCLE_LENGTH);
            state.targets.explorer = 1 - clamp01(num(telemetry.explorer_in, 0) / TEACHER_CYCLE_LENGTH);
            state.targets.reward = clamp01(num(telemetry.insight_agent_avg_reward, 0));
            // PATCH: Handle goals being null/undefined gracefully
            const goals = telemetry.goals || {};
            const goalRows = Object.entries(goals).map(([k, v]) => `<div class="row"><span class="label">${escapeHTML(k)}</span><span class="value">${num(v, null) !== null ? num(v).toFixed(3) : escapeHTML(String(v))}</span></div>`).join('');
            DOM.goalsList.innerHTML = goalRows || '<div class="row"><span class="label">No goals</span><span class="value">-</span></div>';
            DOM.teacherQuestion.textContent = telemetry.teacher_question || '-';
            DOM.explorerAnswer.textContent = telemetry.explorer_answer || '-';
            DOM.encoderStatus.textContent = telemetry.autoencoder_trained ? 'Trained' : 'Untrained';
            state.targets.globalTension = num(telemetry.global_tension, 0);

            // ***** MODIFICATION START: Logic for combined shell panel *****
            const st = telemetry.shell_tensions || {};
            const sp = telemetry.shell_population || {};
            const allDims = new Set([...Object.keys(st), ...Object.keys(sp)]);
            DOM.shellDynamicsGrid.innerHTML = ''; // Clear previous state

            [...allDims].sort((a, b) => num(a) - num(b)).forEach(dim => {
                let card = document.getElementById(`shell-card-${dim}`);
                if (!card) {
                    card = document.createElement('div');
                    card.id = `shell-card-${dim}`;
                    card.className = 'shell-card';
                    DOM.shellDynamicsGrid.appendChild(card);
                }
                const tension = num(st[dim], 0);
                const pop = num(sp[dim], 0);
                const series = state.shellSparklines.get(dim) || [];
                series.push(tension);
                state.shellSparklines.set(dim, series);

                card.innerHTML = `
                    <div class="row"><span class="label">Shell ${escapeHTML(dim)}D</span><span class="value">Pop: ${pop}</span></div>
                    <div class="row"><span class="label">Tension</span><span class="value">${tension.toFixed(3)}</span></div>
                    <canvas></canvas>
                `;
                sparkline(card, series);
            });
            // ***** MODIFICATION END *****
        }

        function processTelemetry(telemetry) {
            state.currentTelemetry = telemetry;
            updateUI(telemetry);
            // PATCH: Handle proximity telemetry gracefully if the key is missing
            if (typeof handleProximityTelemetry === 'function') {
                try { handleProximityTelemetry(telemetry.proximity); } catch (e) { console.warn('proximity telemetry error', e); }
            }
            // PATCH: Use safe access for nested objects
            const q = telemetry.quantum_telemetry || {};
            const lamVal = num(q.lam, NaN);
            state.targets.lam = clamp01(lamVal);
            if (Number.isFinite(lamVal)) DOM.valLam.textContent = lamVal.toFixed(3); else DOM.valLam.textContent = 'N/A';
            const psiH = num(q.psi_entropy, NaN);
            const totalPop = Object.values(telemetry.shell_population || {}).reduce((a, b) => a + num(b, 0), 0);
            const maxH = totalPop > 1 ? Math.log(totalPop) : 1;
            const psiNorm = clamp01(psiH / (maxH || 1));
            state.targets.psi = psiNorm;
            DOM.valPsi.textContent = (Number.isFinite(psiH) ? `${psiH.toFixed(3)} (norm ${psiNorm.toFixed(3)})` : 'N/A');
            DOM.valQDt.textContent = num(q.dt, NaN).toFixed(4);
            DOM.valQGamma.textContent = num(q.gamma, NaN).toFixed(3);
            DOM.valQDephase.textContent = num(q.dephase, NaN).toFixed(3);

            const nov = num(telemetry.novelty, NaN);
            state.targets.novelty = clamp01(nov); DOM.valNovelty.textContent = nov.toFixed(3); state.noveltySeries.push(nov);
            // M20 server exports 'compression_gain'. Older drafts used 'compression'. Support both.
            const cgRaw = ("compression_gain" in telemetry) ? telemetry.compression_gain : telemetry.compression;
            const cg = num(cgRaw, NaN);
            state.targets.compression = clamp01(cg + 0.5);
            if (Number.isFinite(cg)) {
                DOM.valCompression.textContent = cg.toFixed(4);
                state.compressionSeries.push(cg);
            }
            const dis = num(telemetry.disagreement, NaN);
            state.targets.disagreement = clamp01(0.5 + 0.5 * Math.tanh(dis)); DOM.valDisagreement.textContent = dis.toFixed(4); state.disagreementSeries.push(dis);
            const trimSeries = (arr, max = 512) => { if (arr.length > max) arr.splice(0, arr.length - max); };
            trimSeries(state.noveltySeries); trimSeries(state.compressionSeries); trimSeries(state.disagreementSeries);
            sparkline(DOM.sparkNovelty, state.noveltySeries, 96);
            sparkline(DOM.sparkCompression, state.compressionSeries, 96);
            sparkline(DOM.sparkDisagreement, state.disagreementSeries, 96);

            const failures = num(telemetry.kdtree_failures, -1);
            if (failures >= 0) {
                DOM.valKDTree.textContent = String(failures);
                DOM.valKDTree.style.color = failures > 0 ? 'var(--warn)' : 'var(--ok)';
            }

            updateRotorState(telemetry.shells); // M20 uses 'shells'
            // PATCH: Check for existence of keys before rendering lists
            renderList(DOM.ingestionFeed, telemetry.ingestion_feed || []);
            renderList(DOM.validationLab, telemetry.validation_lab || []);
            renderList(DOM.insightHolocron, telemetry.insight_holocron || []);

            const metrics20 = telemetry.m20_metrics || {};
            DOM.m20FluidSteps.textContent = String(Math.max(0, Math.floor(num(metrics20.fluid_steps, 0))));
            DOM.m20ValenceUpdates.textContent = String(Math.max(0, Math.floor(num(metrics20.valence_updates, 0))));
            DOM.m20EnergyExplorations.textContent = String(Math.max(0, Math.floor(num(metrics20.energy_explorations, 0))));
            DOM.m20TopologyAdaptations.textContent = String(Math.max(0, Math.floor(num(metrics20.topology_adaptations, 0))));
            DOM.m20RecursiveImplementations.textContent = String(Math.max(0, Math.floor(num(metrics20.recursive_implementations, 0))));
            DOM.m20FlowRate.textContent = num(metrics20.consciousness_flow_rate, 0).toFixed(3);
            DOM.m20Curvature.textContent = num(metrics20.spacetime_curvature, 0).toFixed(3);

            // Process mantle metrics for visual effects
            const mantle = telemetry.mantle || {};
            state.mantle = {
                flux: num(mantle.flux, 1.0),
                curvature: num(mantle.curvature, 6.0),
                flow: num(mantle.flow, 1.5),
                tension: num(mantle.tension, 0.7)
            };

            if (fluidVisualizer) fluidVisualizer.updateWithMetrics(metrics20);
            if (telemetry.run_id) DOM.runTag.textContent = `LIVE #${telemetry.run_id}`;

            let insights = [];
            if (Array.isArray(telemetry.new_memory_nodes) && telemetry.new_memory_nodes.length) {
                insights = telemetry.new_memory_nodes;
            } else if (Array.isArray(telemetry.insights) && telemetry.insights.length) {
                insights = telemetry.insights.map((it, idx) => ({
                    node_id: it.id || it.node_id || `insight_${idx}`,
                    rating: it.reward ?? it.rating ?? 0.5,
                    shell_dim: 8,
                    vec8D: it.vec8D || it.vector || it.vec || null,
                    coords_3d: it.vec8D || it.vector || it.vec || null,
                    label: it.label || (it.meta_label || 'Insight')
                }));
            }
            if (Array.isArray(insights) && insights.length) enqueueInsights(insights);
        }

        // --- Slice 1: Adaptive Proximity Helpers (inserted) ---
        function handleProximityTelemetry(proxData) {
            // PATCH: This function now expects the `proximity` object from telemetry, which might not exist.
            if (!proxData || typeof proxData !== 'object') return;

            const evt = normalizeProximityEvent(proxData);
            if (!evt) return;

            state.proximity.events.push(evt);
            if (state.proximity.events.length > 140) state.proximity.events.splice(0, state.proximity.events.length - 140);
            state.proximity.lastEvent = evt;
            if (evt.stats) state.proximity.stats = evt.stats;

            if (isFinite(evt.distance)) {
                state.proximity.distanceSeries.push(evt.distance);
                if (state.proximity.distanceSeries.length > state.proximity.maxSeries) state.proximity.distanceSeries.splice(0, state.proximity.distanceSeries.length - state.proximity.maxSeries);
            }
            const t = (evt.tier || 'unknown').toLowerCase();
            if (t in state.proximity.tierCounts) state.proximity.tierCounts[t]++;

            renderProximity();
        }
        function normalizeProximityEvent(raw) {
            try {
                const tier = (raw.tier || raw.classification || raw.level || '').toLowerCase() || 'unknown';
                const distance = Number(raw.distance ?? raw.dist ?? raw.d);
                const score = Number(raw.score ?? raw.proximity_score ?? raw.s);
                const percentile = Number(raw.percentile ?? raw.pct ?? raw.perc);
                const shells = raw.shell_pair || raw.shells || [raw.shell_a, raw.shell_b].filter(v => v != null);
                const a = Number(raw.a_dim ?? raw.dim_a ?? (Array.isArray(shells) ? shells[0] : undefined));
                const b = Number(raw.b_dim ?? raw.dim_b ?? (Array.isArray(shells) ? shells[1] : undefined));
                const stats = extractProximityStats(raw.stats || raw);
                return { ts: Date.now(), tier, distance, score, percentile, a_dim: isFinite(a) ? a : null, b_dim: isFinite(b) ? b : null }
            } catch (e) {
                console.warn('Failed to normalize proximity event', e);
                return null;
            }
        }
        function extractProximityStats(raw) {
            // PATCH: Extract stats safely from the raw event object
            const stats = {};
            const keys = Object.keys(raw).filter(k => k.startsWith('stat_') || k.startsWith('metric_'));
            keys.forEach(key => {
                const newKey = key.replace(/^stat_/, '').replace(/^metric_/, '');
                stats[newKey] = raw[key];
            });
            return stats;
        }

        function renderProximity() {
            // --- Proximity Summary Stats ---
            const { stats, tierCounts, lastEvent } = state.proximity;
            const totalCount = Object.values(tierCounts).reduce((a, b) => a + b, 0);
            const lockCount = tierCounts.lock || 0;
            const strongCount = tierCounts.strong || 0;
            const moderateCount = tierCounts.moderate || 0;
            const weakCount = tierCounts.weak || 0;
            const noiseCount = totalCount - (lockCount + strongCount + moderateCount + weakCount);
            const hasProximityData = totalCount > 0;

            // Update summary chips
            const updateChip = (id, value, label) => {
                const chip = document.getElementById(id);
                if (chip) {
                    chip.textContent = `${label} ${value}`;
                    chip.style.display = value > 0 ? 'inline-block' : 'none';
                }
            };
            updateChip('proxCountLock', lockCount, 'LOCK');
            updateChip('proxCountStrong', strongCount, 'STRONG');
            updateChip('proxCountModerate', moderateCount, 'MODERATE');
            document.getElementById('proxCountWeak').textContent = `WEAK ${weakCount}`;
            document.getElementById('proxCountNoise').textContent = `NOISE ${noiseCount}`;

            // Proximity sparkline
            const distanceSeries = state.proximity.distanceSeries;
            const sparklineMaxPoints = 64;
            if (distanceSeries.length > sparklineMaxPoints) distanceSeries.splice(0, distanceSeries.length - sparklineMaxPoints);
            const canvas = document.getElementById('proximitySparkline');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0, 0, w, h);
            if (distanceSeries.length < 2) return;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            ctx.lineWidth = 1.5; ctx.beginPath();
            for (let i = 0; i < distanceSeries.length; i++) {
                const x = (i / (distanceSeries.length - 1)) * w;
                const y = h - ((distanceSeries[i] - Math.min(...distanceSeries)) / (Math.max(...distanceSeries) - Math.min(...distanceSeries))) * (h - 6) - 3;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // --- Proximity Events List ---
            const eventsList = document.getElementById('proximityEventsList');
            if (!eventsList) return;
            eventsList.innerHTML = '';
            const maxEventsToShow = 10;
            const eventsToShow = state.proximity.events.slice(-maxEventsToShow);
            for (const evt of eventsToShow) {
                const item = document.createElement('div');
                item.className = 'proximity-event';
                item.innerHTML = `
          <div class="meta">
            <span class="tier ${evt.tier}">${evt.tier}</span>
            <span class="distance">${evt.distance.toFixed(2)} m</span>
          </div>
          <div class="details">
            <div><strong>Score:</strong> ${evt.score.toFixed(3)}</div>
            <div><strong>Percentile:</strong> ${evt.percentile.toFixed(1)}%</div>
          </div>
        `;
                eventsList.appendChild(item);
            }
        }
    </script>
</body>

</html>